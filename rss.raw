<?xml version="1.0" encoding="UTF-8"?><rss dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>in Code — Entries</title><link>https://blog.jle.im/</link><description>Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
</description><item><title>Haskell Nuggets: k-means
</title><link>https://blog.jle.im/entry/haskell-nuggets-kmeans.html</link><description>&lt;p&gt;AI is hot, so let’s talk about some “classical machine learning” in Haskell
with k-means clustering! Let’s throw in some dependent types too.&lt;/p&gt;
&lt;p&gt;There are a bazillion ways of implementing such a simple algorithm, but this
is how &lt;em&gt;I’d&lt;/em&gt; do it, as someone who develops almost exclusively in Haskell
(or functional pure languages) in both personal projects and work. It’s not the
“right” way or the “best” way, but it’s the way that brings me joy. Hopefully it
can also break beyond the simple toy projects you’ll often see in conceptual
tutorials. You’ll see how I integrate dependent types, type-driven development,
mutable data structures, generating random data, and preparation for
parallelism. I have been meaning to shift away from “conceptual” posts and
instead post a bit more about small, practical snippets that demonstrate some
useful Haskell techniques and principles drive how I approach coding in Haskell
overall.&lt;/p&gt;
&lt;p&gt;For reference, the intended audience is for people with knowledge of Haskell
syntax and basic idioms (mapping, traversing, folding, applicatives). The source
code &lt;a
href="https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs"&gt;is
online here&lt;/a&gt;, and is structured as a nix flake script. If you have &lt;a
href="https://nixos.org/"&gt;nix&lt;/a&gt; installed (and flakes enabled), you should be
able to run the script as an executable (&lt;code&gt;./kmeans.hs&lt;/code&gt;). You can also
load it for editing with &lt;code&gt;nix develop&lt;/code&gt; + &lt;code&gt;ghci&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="the-algorithm"&gt;The Algorithm&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/K-means_clustering"&gt;K-means&lt;/a&gt; is a
method of assigning a bunch of data points and samples into &lt;em&gt;k&lt;/em&gt; clusters.
For the purpose of this post, we’re going to talk about data points as points in
a vector space and clustering as grouping together clusters of points that are
close to each other (using Euclidean/L2 distance).&lt;/p&gt;
&lt;p&gt;The basic iteration goes like this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Start with &lt;em&gt;k&lt;/em&gt; cluster centers (“means”, or “centroids” sometimes),
&lt;em&gt;k&lt;/em&gt; arbitrary points in your space.&lt;/li&gt;
&lt;li&gt;Repeat until the stop condition:
&lt;ul&gt;
&lt;li&gt;Assign/bucket each data point to its closest cluster center/mean.&lt;/li&gt;
&lt;li&gt;Move each of the cluster centers to the mean/centroid of the points that
were assigned to it, or the points in its bucket.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Basically, we repeatedly say, “if this was the true cluster center, what
points would be in it?”. Then we adjust our cluster center to the center of
those points at were assigned to it, updating to a better guess. Then we repeat
again. A simple stopping condition would be if none of the k centers move after
the update step.&lt;/p&gt;
&lt;p&gt;The algorithm leaves the assigning of the original points undefined, and it’s
also not optimal either, since it might converge on clusters that aren’t the
best. But it’s simple enough conceptually that it’s taught in every beginner
machine learning course.&lt;/p&gt;
&lt;h2 id="the-haskell"&gt;The Haskell&lt;/h2&gt;
&lt;p&gt;We’re going to be dealing with points in a vector space and distances between
them, so a good thing to each for is the &lt;em&gt;&lt;a
href="http://hackage.haskell.org/package/linear"&gt;linear&lt;/a&gt;&lt;/em&gt; library, which
offers types for 2D vectors, 3D vectors, etc. and how to deal with them as
points in a vector space. &lt;em&gt;linear&lt;/em&gt; offers an abstraction over multiple
vector space points. A point has type &lt;code&gt;p a&lt;/code&gt;: &lt;code&gt;p&lt;/code&gt; is a
vector space over field &lt;code&gt;a&lt;/code&gt;. The library has &lt;code&gt;V2 a&lt;/code&gt; for 2D
points, so &lt;code&gt;V2 Double&lt;/code&gt; is &lt;em&gt;essentially&lt;/em&gt; &lt;span
class="math inline"&gt;\(\mathbb{R}^2\)&lt;/span&gt;, a 2 dimensional point with
double-valued components.&lt;/p&gt;
&lt;p&gt;We want a collection of k cluster centers. We can use &lt;em&gt;&lt;a
href="http://hackage.haskell.org/package/vector-sized"&gt;vector-sized&lt;/a&gt;&lt;/em&gt; for
a fixed-size collection of items, &lt;code&gt;Vector k (V2 Double)&lt;/code&gt; for k 2-D
double points, or &lt;code&gt;Vector k (p a)&lt;/code&gt; for k of any type of points.&lt;a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So overall, our function will have type:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb1-1"&gt;&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;kMeans ::&lt;/span&gt; [p a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It will take a collection of &lt;code&gt;p a&lt;/code&gt; points, and provide the
&lt;code&gt;k&lt;/code&gt; cluster centers. Note here that we have “return-type
polymorphism”, where the &lt;code&gt;k&lt;/code&gt; (number of items) is determined by what
type the user expects the function to return. If they want 3 clusters of 2d
points, they will call it expecting &lt;code&gt;Vector 3 (V2 Double)&lt;/code&gt;. If they
want 10 clusters of 2d points, they would call it expecting
&lt;code&gt;Vector 10 (V2 Double)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We take a &lt;em&gt;list&lt;/em&gt; of &lt;code&gt;p a&lt;/code&gt;’s here because all we are going
to do is &lt;em&gt;iterate&lt;/em&gt; over each one…we don’t really care about random access
or updates, so it’s really the best we can hope for, asymptotically&lt;a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We have some leeway to how we initialize our initial clusters. One simple
solution is to just assign point 0 to cluster 0, point 1 to cluster, point 2 to
cluster 2, etc., cycling around the clusters.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb2-1"&gt;&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L32-L41&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-2"&gt;&lt;a href="#cb2-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-3"&gt;&lt;a href="#cb2-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;initialClusters ::&lt;/span&gt; (&lt;span class="dt"&gt;Additive&lt;/span&gt; p, &lt;span class="dt"&gt;Fractional&lt;/span&gt; a, &lt;span class="dt"&gt;KnownNat&lt;/span&gt; k) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [p a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a)&lt;/span&gt;
&lt;span id="cb2-4"&gt;&lt;a href="#cb2-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;initialClusters pts &lt;span class="ot"&gt;=&lt;/span&gt; runST &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-5"&gt;&lt;a href="#cb2-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  sums &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MV.replicate zero&lt;/span&gt;
&lt;span id="cb2-6"&gt;&lt;a href="#cb2-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  counts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MV.replicate &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-7"&gt;&lt;a href="#cb2-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  ifor_ pts \i p &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-8"&gt;&lt;a href="#cb2-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; i&amp;#39; &lt;span class="ot"&gt;=&lt;/span&gt; modulo (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; i)&lt;/span&gt;
&lt;span id="cb2-9"&gt;&lt;a href="#cb2-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    MV.modify sums (&lt;span class="op"&gt;^+^&lt;/span&gt; p) i&amp;#39;&lt;/span&gt;
&lt;span id="cb2-10"&gt;&lt;a href="#cb2-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    MV.modify counts (&lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) i&amp;#39;&lt;/span&gt;
&lt;span id="cb2-11"&gt;&lt;a href="#cb2-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  V.generateM \i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-12"&gt;&lt;a href="#cb2-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="op"&gt;^/&lt;/span&gt;) &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; MV.read sums i &lt;span class="op"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; MV.read counts i&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;runST&lt;/code&gt; runs the mutable algorithm where we initialize a vector of
point sums and a vector of point counts. We then iterate over all of the points
with their index (with &lt;code&gt;ifor_&lt;/code&gt;), and we add that point to the index
of the cluster, modulo &lt;code&gt;k&lt;/code&gt;. A sized vector &lt;code&gt;Vector k a&lt;/code&gt; is
indexed by a &lt;code&gt;Finite k&lt;/code&gt; (an integer from 0 to &lt;em&gt;k-1&lt;/em&gt;). So,
&lt;code&gt;modulo :: Integer -&amp;gt; Finite k&lt;/code&gt; will convert an integer index to
the &lt;code&gt;Finite k&lt;/code&gt; index type, using modulus to wrap it around if it’s
too big.&lt;/p&gt;
&lt;p&gt;Here we are using some functions from &lt;em&gt;linear&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(^+^) :: (Additive p, Num a) =&amp;gt; p a -&amp;gt; p a -&amp;gt; p a&lt;/code&gt;
which adds together two points&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(^/) :: (Functor p, Fractional a) =&amp;gt; p a -&amp;gt; a -&amp;gt; p a&lt;/code&gt;
which divides a point by a scalar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At the end of it all, we use &lt;code&gt;V.generateM&lt;/code&gt; to assemble our final
(immutable) centroids by reading out the sums and totals at each cluster:&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb3-1"&gt;&lt;a href="#cb3-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;V.generateM&lt;span class="ot"&gt; ::&lt;/span&gt; (&lt;span class="dt"&gt;Finite&lt;/span&gt; k &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Vector&lt;/span&gt; k a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we the lengths of all our intermediate vectors (&lt;code&gt;sums&lt;/code&gt;,
&lt;code&gt;counts&lt;/code&gt;, and the final result) are all implicitly inferred through
type inference (by &lt;code&gt;k&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We can actually do a similar loop to assign/bin each point and compute the
new centroids:&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb4-1"&gt;&lt;a href="#cb4-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L43-L60&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-2"&gt;&lt;a href="#cb4-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb4-3"&gt;&lt;a href="#cb4-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;moveClusters ::&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-4"&gt;&lt;a href="#cb4-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;forall&lt;/span&gt; k p a&lt;span class="op"&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-5"&gt;&lt;a href="#cb4-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (&lt;span class="dt"&gt;Metric&lt;/span&gt; p, &lt;span class="dt"&gt;Floating&lt;/span&gt; a, &lt;span class="dt"&gt;Ord&lt;/span&gt; a, &lt;span class="dt"&gt;KnownNat&lt;/span&gt; k, &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; k) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-6"&gt;&lt;a href="#cb4-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  [p a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-7"&gt;&lt;a href="#cb4-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-8"&gt;&lt;a href="#cb4-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a)&lt;/span&gt;
&lt;span id="cb4-9"&gt;&lt;a href="#cb4-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;moveClusters pts origCentroids &lt;span class="ot"&gt;=&lt;/span&gt; runST &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-10"&gt;&lt;a href="#cb4-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  sums &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MV.replicate zero&lt;/span&gt;
&lt;span id="cb4-11"&gt;&lt;a href="#cb4-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  counts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MV.replicate &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-12"&gt;&lt;a href="#cb4-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  for_ pts \p &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-13"&gt;&lt;a href="#cb4-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; closestIx &lt;span class="ot"&gt;=&lt;/span&gt; V.minIndex &lt;span class="op"&gt;@&lt;/span&gt;a &lt;span class="op"&gt;@&lt;/span&gt;(k &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (distance p &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; origCentroids)&lt;/span&gt;
&lt;span id="cb4-14"&gt;&lt;a href="#cb4-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    MV.modify sums (&lt;span class="op"&gt;^+^&lt;/span&gt; p) closestIx&lt;/span&gt;
&lt;span id="cb4-15"&gt;&lt;a href="#cb4-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    MV.modify counts (&lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) closestIx&lt;/span&gt;
&lt;span id="cb4-16"&gt;&lt;a href="#cb4-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  V.generateM \i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-17"&gt;&lt;a href="#cb4-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    n &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MV.read counts i&lt;/span&gt;
&lt;span id="cb4-18"&gt;&lt;a href="#cb4-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;if&lt;/span&gt; n &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-19"&gt;&lt;a href="#cb4-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="kw"&gt;then&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; origCentroids &lt;span class="ot"&gt;`V.index`&lt;/span&gt; i&lt;/span&gt;
&lt;span id="cb4-20"&gt;&lt;a href="#cb4-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="kw"&gt;else&lt;/span&gt; (&lt;span class="op"&gt;^/&lt;/span&gt; &lt;span class="fu"&gt;fromIntegral&lt;/span&gt; n) &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; MV.read sums i&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We just have to be careful to not move the centroid if there is no points
assigned to it, otherwise we’d be dividing by 0.&lt;/p&gt;
&lt;p&gt;Notice there’s also something a little subtle going on with
&lt;code&gt;closestIx&lt;/code&gt;, which exposes a bit of the awkwardness with working with
type-level numbers in Haskell today. The type of &lt;code&gt;V.minIndex&lt;/code&gt; is:&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb5-1"&gt;&lt;a href="#cb5-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;V.minIndex&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a n&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Ord&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Vector&lt;/span&gt; (n &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Finite&lt;/span&gt; (n &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is because we only ever get a minimum if the vector is non-empty. So the
library takes &lt;code&gt;n + 1&lt;/code&gt; as the size to ensure that only positive length
vectors are passed.&lt;/p&gt;
&lt;p&gt;In our case, we want &lt;code&gt;V.minIndex blah :: Finite k&lt;/code&gt;. However,
remember how typechecking works: we need to unify the type variables
&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; so that &lt;code&gt;n + 1&lt;/code&gt; is equal to
&lt;code&gt;k&lt;/code&gt;. So, what does &lt;em&gt;n&lt;/em&gt; have to be so that &lt;span
class="math inline"&gt;\(n + 1 = k\)&lt;/span&gt;? Well, we can see from algebra that
&lt;code&gt;n&lt;/code&gt; needs to be &lt;code&gt;k - 1&lt;/code&gt;: &lt;code&gt;(k - 1) + 1&lt;/code&gt; is equal
to &lt;code&gt;k&lt;/code&gt;. However, GHC is a little dumb-dumb here in that it cannot
solve for &lt;code&gt;n&lt;/code&gt; itself. We can explicitly pass in &lt;code&gt;@(k - 1)&lt;/code&gt;
to say that &lt;code&gt;n&lt;/code&gt; has to be &lt;code&gt;k - 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For this to work we need to pull in a GHC plugin &lt;a
href="http://hackage.haskell.org/package/ghc-typelits-natnormalise"&gt;ghc-typelits-natnormalise&lt;/a&gt;
which will allow GHC to simplify &lt;code&gt;(k - 1) + 1&lt;/code&gt; to be &lt;code&gt;k&lt;/code&gt;,
which it can’t do by itself for some reason. It also requires the constraint
that &lt;code&gt;1 &amp;lt;= k&lt;/code&gt; in order for &lt;code&gt;k - 1&lt;/code&gt; to make sense for
natural number &lt;code&gt;k&lt;/code&gt;. We can pull in the plugin with:&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb6-1"&gt;&lt;a href="#cb6-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Honestly if we were to design the library from scratch today, I’d define it
as:&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb7-1"&gt;&lt;a href="#cb7-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;V.minIndex&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a n&lt;span class="op"&gt;.&lt;/span&gt; (&lt;span class="dt"&gt;Ord&lt;/span&gt; a, &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; n) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Vector&lt;/span&gt; n a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Finite&lt;/span&gt; n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;in the first place, and we wouldn’t need the typechecker plugin.&lt;/p&gt;
&lt;p&gt;Anyway so that’s the whole thing:&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb8-1"&gt;&lt;a href="#cb8-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L62-L74&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-2"&gt;&lt;a href="#cb8-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb8-3"&gt;&lt;a href="#cb8-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;kMeans ::&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-4"&gt;&lt;a href="#cb8-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;forall&lt;/span&gt; k p a&lt;span class="op"&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-5"&gt;&lt;a href="#cb8-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (&lt;span class="dt"&gt;Metric&lt;/span&gt; p, &lt;span class="dt"&gt;Floating&lt;/span&gt; a, &lt;span class="dt"&gt;Ord&lt;/span&gt; a, &lt;span class="dt"&gt;Eq&lt;/span&gt; (p a), &lt;span class="dt"&gt;KnownNat&lt;/span&gt; k, &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; k) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-6"&gt;&lt;a href="#cb8-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  [p a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-7"&gt;&lt;a href="#cb8-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a)&lt;/span&gt;
&lt;span id="cb8-8"&gt;&lt;a href="#cb8-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;kMeans pts &lt;span class="ot"&gt;=&lt;/span&gt; go &lt;span class="dv"&gt;0&lt;/span&gt; (initialClusters pts)&lt;/span&gt;
&lt;span id="cb8-9"&gt;&lt;a href="#cb8-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-10"&gt;&lt;a href="#cb8-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    go ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a)&lt;/span&gt;
&lt;span id="cb8-11"&gt;&lt;a href="#cb8-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    go &lt;span class="op"&gt;!&lt;/span&gt;i &lt;span class="op"&gt;!&lt;/span&gt;cs&lt;/span&gt;
&lt;span id="cb8-12"&gt;&lt;a href="#cb8-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="op"&gt;|&lt;/span&gt; cs &lt;span class="op"&gt;==&lt;/span&gt; cs&amp;#39; &lt;span class="op"&gt;||&lt;/span&gt; i &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; cs&lt;/span&gt;
&lt;span id="cb8-13"&gt;&lt;a href="#cb8-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="fu"&gt;otherwise&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; go (i &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) cs&amp;#39;&lt;/span&gt;
&lt;span id="cb8-14"&gt;&lt;a href="#cb8-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-15"&gt;&lt;a href="#cb8-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        cs&amp;#39; &lt;span class="ot"&gt;=&lt;/span&gt; moveClusters pts cs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note I also added a stop after 100 steps, just to be safe.&lt;/p&gt;
&lt;h3 id="type-level-advantages-and-usability"&gt;Type-Level Advantages and
Usability&lt;/h3&gt;
&lt;p&gt;Having &lt;code&gt;k&lt;/code&gt; in the type is useful for many reasons:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It helps us ensure that &lt;code&gt;moveClusters&lt;/code&gt; doesn’t change the number
of clusters/centroids. If it was just &lt;code&gt;[p a] -&amp;gt; [p a]&lt;/code&gt; we cannot
guarantee it does not add or drop clusters.&lt;/li&gt;
&lt;li&gt;The type system means we don’t have to manually pass &lt;code&gt;int&lt;/code&gt; sizes
around. For example, in &lt;code&gt;initialClusters&lt;/code&gt;, we implicitly pass the
size around &lt;em&gt;four times&lt;/em&gt; when we do &lt;code&gt;MV.replicate&lt;/code&gt; (twice),
&lt;code&gt;modulo&lt;/code&gt;, and &lt;code&gt;generateM&lt;/code&gt;! And, in the definition of
&lt;code&gt;kMeans&lt;/code&gt;, we implicitly pass it on to our call to
&lt;code&gt;initialClusters&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We don’t have to worry about out-of-bounds indexing because any indices we
generate (using &lt;code&gt;modular&lt;/code&gt; or &lt;code&gt;minIndex&lt;/code&gt;) are guaranteed
(by their types) to be valid.&lt;/li&gt;
&lt;li&gt;It’s useful for the caller to guarantee they are getting what they are
asking for. If &lt;code&gt;kMeans :: Int -&amp;gt; [p a] -&amp;gt; [p a]&lt;/code&gt;, then we (as
the caller) can’t be sure that the result list has the number of items that you
requested. But because we have
&lt;code&gt;kMeans :: [p a] -&amp;gt; Vector k (p a)&lt;/code&gt;, the compiler ensures that the
result has &lt;em&gt;k&lt;/em&gt; items.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However you won’t &lt;em&gt;always&lt;/em&gt; be able to necessarily put in a literal
&lt;code&gt;3&lt;/code&gt; in &lt;code&gt;Vector 3 (V2 Double)&lt;/code&gt;. Maybe your &lt;em&gt;k&lt;/em&gt; comes
from a configuration file or something else you pull in at runtime. We need a
way to call &lt;code&gt;kMeans&lt;/code&gt; with just an &lt;code&gt;Int&lt;/code&gt;! (also known as
“reification”)&lt;/p&gt;
&lt;p&gt;Normally, this means using &lt;code&gt;sumNatVal&lt;/code&gt; to convert a value-level
&lt;code&gt;Natural&lt;/code&gt; into a type-level &lt;code&gt;Nat&lt;/code&gt;. However, in this case
we have to be a bit more careful because &lt;em&gt;k&lt;/em&gt; must be at least 1. So we
can use &lt;a
href="http://hackage.haskell.org/package/typelits-witnesses"&gt;typelits-witnesses&lt;/a&gt;
to also bring in (at runtime) the witnesses that &lt;code&gt;1 &amp;lt;= k&lt;/code&gt; is
fulfilled. Why isn’t this in &lt;em&gt;base&lt;/em&gt;?&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb9-1"&gt;&lt;a href="#cb9-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L76-L85&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-2"&gt;&lt;a href="#cb9-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb9-3"&gt;&lt;a href="#cb9-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;kMeans&amp;#39; ::&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-4"&gt;&lt;a href="#cb9-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;forall&lt;/span&gt; p a&lt;span class="op"&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-5"&gt;&lt;a href="#cb9-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (&lt;span class="dt"&gt;Metric&lt;/span&gt; p, &lt;span class="dt"&gt;Floating&lt;/span&gt; a, &lt;span class="dt"&gt;Ord&lt;/span&gt; a, &lt;span class="dt"&gt;Eq&lt;/span&gt; (p a)) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-6"&gt;&lt;a href="#cb9-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Natural&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-7"&gt;&lt;a href="#cb9-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  [p a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-8"&gt;&lt;a href="#cb9-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  [p a]&lt;/span&gt;
&lt;span id="cb9-9"&gt;&lt;a href="#cb9-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;kMeans&amp;#39; k pts &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; someNatVal k &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-10"&gt;&lt;a href="#cb9-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;SomeNat&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;k pk &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; &lt;span class="dt"&gt;SNat&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="ot"&gt;`isLE`&lt;/span&gt; pk &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-11"&gt;&lt;a href="#cb9-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; []&lt;/span&gt;
&lt;span id="cb9-12"&gt;&lt;a href="#cb9-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;Just&lt;/span&gt; &lt;span class="dt"&gt;Refl&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; toList &lt;span class="op"&gt;$&lt;/span&gt; kMeans &lt;span class="op"&gt;@&lt;/span&gt;k pts&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="applying-the-clusters"&gt;Applying the Clusters&lt;/h3&gt;
&lt;p&gt;Of course, &lt;code&gt;kMeans&lt;/code&gt; only gets us our centroids, so it would be
useful to actually create the clusters themselves and all their member points.
We can do something similar to what we did before with &lt;code&gt;ST&lt;/code&gt; and
mutable vectors and &lt;code&gt;runST&lt;/code&gt;, but life is too short to always be using
mutable state. Let’s instead build up a map of indices to all the points that
are closest to that index. Then we use
&lt;code&gt;generate :: (Finite k -&amp;gt; a) -&amp;gt; Vector k a&lt;/code&gt; to create a vector
by picking out the maps’ value at the index at each spot in the vector. Again
here we see that the type system helps us by not having to manually pass in a
size, and &lt;code&gt;generate&lt;/code&gt; giving us indices &lt;code&gt;i&lt;/code&gt; that match the
number of the centroids we are grouping on.&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb10-1"&gt;&lt;a href="#cb10-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L102-L117&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-2"&gt;&lt;a href="#cb10-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-3"&gt;&lt;a href="#cb10-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;applyClusters ::&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-4"&gt;&lt;a href="#cb10-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;forall&lt;/span&gt; k p a&lt;span class="op"&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-5"&gt;&lt;a href="#cb10-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (&lt;span class="dt"&gt;Metric&lt;/span&gt; p, &lt;span class="dt"&gt;Floating&lt;/span&gt; a, &lt;span class="dt"&gt;Ord&lt;/span&gt; a, &lt;span class="dt"&gt;Ord&lt;/span&gt; (p a), &lt;span class="dt"&gt;KnownNat&lt;/span&gt; k, &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; k) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-6"&gt;&lt;a href="#cb10-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  [p a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-7"&gt;&lt;a href="#cb10-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Vector&lt;/span&gt; k (p a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-8"&gt;&lt;a href="#cb10-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Vector&lt;/span&gt; k (&lt;span class="dt"&gt;Set&lt;/span&gt; (p a))&lt;/span&gt;
&lt;span id="cb10-9"&gt;&lt;a href="#cb10-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;applyClusters pts cs &lt;span class="ot"&gt;=&lt;/span&gt; V.generate \i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; M.findWithDefault S.empty i pointsClosestTo&lt;/span&gt;
&lt;span id="cb10-10"&gt;&lt;a href="#cb10-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-11"&gt;&lt;a href="#cb10-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    pointsClosestTo ::&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; (&lt;span class="dt"&gt;Finite&lt;/span&gt; k) (&lt;span class="dt"&gt;Set&lt;/span&gt; (p a))&lt;/span&gt;
&lt;span id="cb10-12"&gt;&lt;a href="#cb10-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    pointsClosestTo &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-13"&gt;&lt;a href="#cb10-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      M.fromListWith&lt;/span&gt;
&lt;span id="cb10-14"&gt;&lt;a href="#cb10-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        (&lt;span class="op"&gt;&amp;lt;&amp;gt;&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb10-15"&gt;&lt;a href="#cb10-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        [ (closestIx, S.singleton p)&lt;/span&gt;
&lt;span id="cb10-16"&gt;&lt;a href="#cb10-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="op"&gt;|&lt;/span&gt; p &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; pts&lt;/span&gt;
&lt;span id="cb10-17"&gt;&lt;a href="#cb10-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        , &lt;span class="kw"&gt;let&lt;/span&gt; closestIx &lt;span class="ot"&gt;=&lt;/span&gt; V.minIndex &lt;span class="op"&gt;@&lt;/span&gt;a &lt;span class="op"&gt;@&lt;/span&gt;(k &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (distance p &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; cs)&lt;/span&gt;
&lt;span id="cb10-18"&gt;&lt;a href="#cb10-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="parallelization"&gt;Parallelization&lt;/h3&gt;
&lt;p&gt;Typically we parallelize this by assigning each worker thread a chunk of
points it has to deal with, and having each one compute sums and counts and
coordinating it all back in the end. In this case we want to keep the
intermediate sums and counts:&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb11-1"&gt;&lt;a href="#cb11-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L87-L100&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-2"&gt;&lt;a href="#cb11-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb11-3"&gt;&lt;a href="#cb11-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;groupAndSum ::&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-4"&gt;&lt;a href="#cb11-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (&lt;span class="dt"&gt;Metric&lt;/span&gt; p, &lt;span class="dt"&gt;Floating&lt;/span&gt; a, &lt;span class="dt"&gt;Ord&lt;/span&gt; a, &lt;span class="dt"&gt;KnownNat&lt;/span&gt; (k &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-5"&gt;&lt;a href="#cb11-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  [p a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-6"&gt;&lt;a href="#cb11-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Vector&lt;/span&gt; (k &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (p a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-7"&gt;&lt;a href="#cb11-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Vector&lt;/span&gt; (k &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (p a, &lt;span class="dt"&gt;Integer&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb11-8"&gt;&lt;a href="#cb11-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;groupAndSum pts cs0 &lt;span class="ot"&gt;=&lt;/span&gt; runST &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-9"&gt;&lt;a href="#cb11-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  sums &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MV.replicate zero&lt;/span&gt;
&lt;span id="cb11-10"&gt;&lt;a href="#cb11-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  counts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MV.replicate &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-11"&gt;&lt;a href="#cb11-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  for_ pts \p &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-12"&gt;&lt;a href="#cb11-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; closestIx &lt;span class="ot"&gt;=&lt;/span&gt; V.minIndex (distance p &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; cs0)&lt;/span&gt;
&lt;span id="cb11-13"&gt;&lt;a href="#cb11-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    MV.modify sums (&lt;span class="op"&gt;^+^&lt;/span&gt; p) closestIx&lt;/span&gt;
&lt;span id="cb11-14"&gt;&lt;a href="#cb11-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    MV.modify counts (&lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) closestIx&lt;/span&gt;
&lt;span id="cb11-15"&gt;&lt;a href="#cb11-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  V.generateM \i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-16"&gt;&lt;a href="#cb11-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (,) &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; MV.read sums i &lt;span class="op"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; MV.read counts i&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="running-an-example"&gt;Running an example&lt;/h2&gt;
&lt;p&gt;For funsies let us generate sample points that we know are clustered based on
k random cluster centers, using &lt;a
href="http://hackage.haskell.org/package/mwc-random"&gt;mwc-random&lt;/a&gt; for
randomness.&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb12-1"&gt;&lt;a href="#cb12-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L119-L145&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-2"&gt;&lt;a href="#cb12-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb12-3"&gt;&lt;a href="#cb12-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;generateSamples ::&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-4"&gt;&lt;a href="#cb12-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;forall&lt;/span&gt; p g m&lt;span class="op"&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-5"&gt;&lt;a href="#cb12-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (&lt;span class="dt"&gt;Applicative&lt;/span&gt; p, &lt;span class="dt"&gt;Traversable&lt;/span&gt; p, &lt;span class="dt"&gt;StatefulGen&lt;/span&gt; g m) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-6"&gt;&lt;a href="#cb12-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="co"&gt;-- | number of points per cluster&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-7"&gt;&lt;a href="#cb12-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-8"&gt;&lt;a href="#cb12-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="co"&gt;-- | number of clusters&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-9"&gt;&lt;a href="#cb12-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-10"&gt;&lt;a href="#cb12-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  g &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-11"&gt;&lt;a href="#cb12-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  m ([p &lt;span class="dt"&gt;Double&lt;/span&gt;], [p &lt;span class="dt"&gt;Double&lt;/span&gt;])&lt;/span&gt;
&lt;span id="cb12-12"&gt;&lt;a href="#cb12-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;generateSamples numPts numClusters g &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-13"&gt;&lt;a href="#cb12-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (centers, ptss) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-14"&gt;&lt;a href="#cb12-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;unzip&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; replicateM numClusters &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-15"&gt;&lt;a href="#cb12-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="co"&gt;-- generate the centroid uniformly in the box component-by-component&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-16"&gt;&lt;a href="#cb12-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      center &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="fu"&gt;sequenceA&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;p &lt;span class="op"&gt;$&lt;/span&gt; MWC.uniformRM (&lt;span class="dv"&gt;0&lt;/span&gt;, boxSize) g&lt;/span&gt;
&lt;span id="cb12-17"&gt;&lt;a href="#cb12-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="co"&gt;-- generate numPts points...&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-18"&gt;&lt;a href="#cb12-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      pts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-19"&gt;&lt;a href="#cb12-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        replicateM numPts &lt;span class="op"&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-20"&gt;&lt;a href="#cb12-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          &lt;span class="co"&gt;-- .. component-by-component, as normal distribution around the center&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-21"&gt;&lt;a href="#cb12-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          &lt;span class="fu"&gt;traverse&lt;/span&gt; (\c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; MWC.normal c &lt;span class="fl"&gt;0.1&lt;/span&gt; g) center&lt;/span&gt;
&lt;span id="cb12-22"&gt;&lt;a href="#cb12-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="fu"&gt;pure&lt;/span&gt; (center, pts)&lt;/span&gt;
&lt;span id="cb12-23"&gt;&lt;a href="#cb12-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="fu"&gt;pure&lt;/span&gt; (centers, &lt;span class="fu"&gt;concat&lt;/span&gt; ptss)&lt;/span&gt;
&lt;span id="cb12-24"&gt;&lt;a href="#cb12-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-25"&gt;&lt;a href="#cb12-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;-- get the dimension by getting the length of a unit point&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-26"&gt;&lt;a href="#cb12-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    dim &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;length&lt;/span&gt; (&lt;span class="fu"&gt;pure&lt;/span&gt;&lt;span class="ot"&gt; () ::&lt;/span&gt; p ())&lt;/span&gt;
&lt;span id="cb12-27"&gt;&lt;a href="#cb12-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;-- approximately scale the range of the numbers by the area that the&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-28"&gt;&lt;a href="#cb12-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;-- clusters would take up&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-29"&gt;&lt;a href="#cb12-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    boxSize &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; numClusters &lt;span class="op"&gt;**&lt;/span&gt; &lt;span class="fu"&gt;recip&lt;/span&gt; (&lt;span class="fu"&gt;fromIntegral&lt;/span&gt; dim)) &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By the way isn’t it funny that everything just ends up being
&lt;code&gt;traverse&lt;/code&gt; or some derivation of it (like &lt;code&gt;replicateM&lt;/code&gt; or
&lt;code&gt;sequenceA&lt;/code&gt;)? Anyways,&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb13-1"&gt;&lt;a href="#cb13-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/kmeans/kmeans.hs#L147-L156&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-2"&gt;&lt;a href="#cb13-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb13-3"&gt;&lt;a href="#cb13-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb13-4"&gt;&lt;a href="#cb13-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;main &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-5"&gt;&lt;a href="#cb13-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  g &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; MWC.createSystemRandom&lt;/span&gt;
&lt;span id="cb13-6"&gt;&lt;a href="#cb13-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  (centers, samps) &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; generateSamples &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;V2&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt; g&lt;/span&gt;
&lt;span id="cb13-7"&gt;&lt;a href="#cb13-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;* points&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-8"&gt;&lt;a href="#cb13-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="fu"&gt;mapM_&lt;/span&gt; &lt;span class="fu"&gt;print&lt;/span&gt; samps&lt;/span&gt;
&lt;span id="cb13-9"&gt;&lt;a href="#cb13-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;* actual centers&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-10"&gt;&lt;a href="#cb13-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="fu"&gt;print&lt;/span&gt; centers&lt;/span&gt;
&lt;span id="cb13-11"&gt;&lt;a href="#cb13-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;* kmeans centers&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-12"&gt;&lt;a href="#cb13-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="fu"&gt;print&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; kMeans&amp;#39; &lt;span class="dv"&gt;3&lt;/span&gt; samps&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;* points
V2 15.117809404050517 2.4824833627968137
V2 14.825686288414198 2.569457175505424
V2 14.806948346588289 2.3222471406644867
V2 15.012490917145703 2.41735577349797
V2 15.007612893836304 2.3823051676970746
V2 14.866016893659538 2.590777185848723
V2 14.83908442030534 2.5756382736578343
V2 14.969996769619264 2.549568226274995
V2 14.983371307935904 2.4823314218207586
V2 14.931617828479244 2.469607213743923
V2 29.426938075603196 9.90899836541481
V2 29.657363050066813 9.844458859292706
V2 29.487332896419872 9.65240948313236
V2 29.717470180982964 9.756325723236502
V2 29.67198068295402 9.688676918673274
V2 29.564673351390947 9.63896189703656
V2 29.56057222121772 9.833541221236656
V2 29.563747509453506 9.75593412158655
V2 29.497322568720026 9.684752183878274
V2 29.598339480038018 9.968546198295204
V2 3.204536005881443 30.039372398954175
V2 3.1684921057193005 30.082909536200095
V2 3.2040077021183793 29.90694542057959
V2 3.151859377604784 29.89198303817146
V2 3.1027920089123935 30.240061564528673
V2 3.2323285236152937 30.037812094337777
V2 3.2722229374242366 30.05215727709455
V2 2.9723263815754652 30.06281544324189
V2 3.1935700833126437 30.068367400732857
V2 3.253701544151972 29.875079507116222
* actual centers
[V2 14.938139892220267 2.4859265040850276,V2 29.55811494146035 9.808348344980386,V2 3.239842205071254 30.070304958459946]
* kmeans centers
[V2 14.936063507003428 2.484177094150801,V2 29.57457400168471 9.773260497178288,V2 3.175583667031591 30.025750368095725]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neat!&lt;/p&gt;
&lt;h2 id="special-thanks"&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it
possible for me to devote time to researching and writing these posts. Very
special thanks to my supporter at the “Amazing” level on &lt;a
href="https://www.patreon.com/justinle/overview"&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Be mindful, for &lt;code&gt;Vector&lt;/code&gt; here we are using things
strictly as a “fixed-sized collection of values”, whereas for &lt;em&gt;linear&lt;/em&gt;,
we have types like &lt;code&gt;V2&lt;/code&gt; which represent &lt;em&gt;points in a mathematical
vector space&lt;/em&gt;. It’s a bit unfortunate that the terminology overlaps here a
bit.&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Yes, yes, linked lists are notoriously bad for the CPU-level
cache and branch prediction, so if we are in a situation where we really cared,
using a contiguous memory data structure (like Storable Vector) might be
better.&lt;a href="#fnref2" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/haskell-nuggets-kmeans.html</guid><pubDate>Fri, 26 Jul 2024 19:06:27 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2024-07-26</date></item><item><title>I nixified my blog
</title><link>https://blog.jle.im/entry/i-nixified-my-blog.html</link><description>&lt;p&gt;Happy new year! It’s been a while (almost three years) since my last post.
But it’s a new year, a new me – and I just recently started working at &lt;a
href="https://github.com/anduril"&gt;a new job&lt;/a&gt; writing Haskell where everything
is built and deployed using &lt;a href="https://nixos.org/"&gt;nix&lt;/a&gt;. Aside from the
bliss that comes from being able to write Haskell as a day job, I also enjoyed
the push to finally dive into the nix ecosystem for my general personal
computing, which many of my friends have been subtly (or not so subtly) pushing
me to look into for a long time. And I have to say, I’m hooked! I get a lot of
similar joy using nix to organize my projects as I did when I was first learning
Haskell. My path to re-organizing all of my personal projects to using nix has
lead me back to one of my more “longer-running” pieces of legacy code – my 10
year old blog. So, this is a post from a naive new nix user on how I converted
my blog deployment and building from a manual multi-stage build process into an
automatic nix-with-cachix deploy – and some future things I would be hoping to
investigate!&lt;/p&gt;
&lt;p&gt;In this post I’ll also be explaining a bit of &lt;em&gt;nix&lt;/em&gt;, so hopefully it’s
accessible if you are curious like I was too. However, it’s &lt;em&gt;not&lt;/em&gt; a
tutorial — instead, it’s a high-level overview of the concepts that I put
together to achieve the goal.&lt;/p&gt;
&lt;h2 id="how-did-we-get-here"&gt;How Did We Get Here&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://blog.jle.im/entries/category/@meta.html"&gt;development
history&lt;/a&gt; of my blog (which just turned 10 a few months ago, actually) has
gone through a few stages: (which you might be able to track &lt;a
href="https://github.com/mstksg/inCode"&gt;on github&lt;/a&gt;)&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;A simple &lt;em&gt;&lt;a
href="https://hackage.haskell.org/package/scotty"&gt;scotty&lt;/a&gt;&lt;/em&gt; server on
Heroku backed by a cloud-hosted postgresql database. My first ever non-trivial
Haskell project!&lt;/li&gt;
&lt;li&gt;Using &lt;em&gt;&lt;a href="https://hackage.haskell.org/package/fay"&gt;fay&lt;/a&gt;&lt;/em&gt; to
compile to javascript for interactivity and post-processing in blog posts.&lt;/li&gt;
&lt;li&gt;Converting &lt;em&gt;fay&lt;/em&gt; to &lt;em&gt;ghcjs&lt;/em&gt;, to write javascript in
Haskell.&lt;/li&gt;
&lt;li&gt;Switching from “classic cabal” to &lt;em&gt;&lt;a
href="https://docs.haskellstack.org/en/stable/"&gt;stack&lt;/a&gt;&lt;/em&gt; for development
and building.&lt;/li&gt;
&lt;li&gt;Using &lt;em&gt;&lt;a href="https://shakebuild.com/"&gt;shake&lt;/a&gt;&lt;/em&gt; for build/deploy
scripts.&lt;/li&gt;
&lt;li&gt;Converting &lt;em&gt;ghcjs&lt;/em&gt; to &lt;em&gt;&lt;a
href="https://www.purescript.org/"&gt;purescript&lt;/a&gt;&lt;/em&gt;, because I didn’t want to
bundle 1.5 MB of Haskell Runtime just to generate a table of contents.&lt;/li&gt;
&lt;li&gt;The biggest change: moving from &lt;em&gt;scotty&lt;/em&gt; to &lt;em&gt;&lt;a
href="https://jaspervdj.be/hakyll/"&gt;hakyll&lt;/a&gt;&lt;/em&gt; (a static site generator),
from a simple HTTP server to a static site generation.&lt;/li&gt;
&lt;li&gt;Deploying to github pages within a build script, using a custom haskell tool
I had written a long time ago. I honestly don’t remember where the site was
hosted before github pages, but I remember having to configure my own CDN and
https for a my hosted static website and at some point I wondered “why?”.&lt;/li&gt;
&lt;li&gt;Moving from yaml for configuration to &lt;em&gt;&lt;a
href="https://dhall-lang.org/"&gt;dhall&lt;/a&gt;&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you can see, I sort of use my blog as a playground to apply new ideas I’m
learning build familiarity with them, and I have some fun refactoring every
couple of years because Haskell is so fun to refactor.&lt;/p&gt;
&lt;p&gt;However, the current state of things is kind of a monster to build. First,
you have to have purescript &lt;em&gt;and&lt;/em&gt; npm &lt;em&gt;and&lt;/em&gt; bower (for general
javascript deployment) installed. Then the build script (the Shakefile) compiles
javascript and purescript into the working directory, then calls hakyll which
generates the actual site files. It’s a really finicky system that involves
having the correct javascript ecosystem dependencies already installed – and
also uses a deprecated system for building purescript. At least we had
&lt;em&gt;stack&lt;/em&gt; to manage having the correct ghc version.&lt;/p&gt;
&lt;p&gt;Looking at this in 2023, there are a few things that had to change:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;The purescript ecosystem has moved onto &lt;em&gt;&lt;a
href="https://github.com/purescript/spago"&gt;spago&lt;/a&gt;&lt;/em&gt; for dependency
management.&lt;/li&gt;
&lt;li&gt;I have been moving most of my projects from stack back to pure cabal using
the new modern tooling&lt;/li&gt;
&lt;li&gt;I have moved dev environments a few times and every time it is a huge pain
to remember the exact set of things that need to be installed for all stages to
build and work correctly. I’d like to move from an ad-hoc build script dependent
on the environment into a single tool that manages everything.&lt;/li&gt;
&lt;li&gt;I wanted to get automatic deployments to github pages running instead of
having to manually deploy.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Some of these don’t necessarily require nix, but I figured that this would be
a good opportunity to check everything off and seeing what nix had to offer.&lt;/p&gt;
&lt;h2 id="the-game-plan"&gt;The Game Plan&lt;/h2&gt;
&lt;p&gt;Going into this, the general workflow would be:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Create a &lt;em&gt;nix derivation&lt;/em&gt; for all of the purescript scripts, that
generates a single javascript file each.&lt;/li&gt;
&lt;li&gt;Create a nix derivation for the &lt;em&gt;hakyll&lt;/em&gt; static site generator
binary&lt;/li&gt;
&lt;li&gt;Create a nix derivation for the full static site itself: it will assemble
all of the compiled purescript files from step 1, the source files (markdown,
static images, etc.) from the repo, and then run the hakyll binary on it.&lt;/li&gt;
&lt;li&gt;Create a github actions workflow to automatically build the full static site
generation workflow.&lt;/li&gt;
&lt;li&gt;Use &lt;em&gt;&lt;a href="https://www.cachix.org/"&gt;cachix&lt;/a&gt;&lt;/em&gt; to ensure that all
derivations where the dependencies don’t change will not need to be
re-built.&lt;/li&gt;
&lt;li&gt;If step 4 completes, automatically push the derivation’s outputs to the
&lt;em&gt;gh-pages&lt;/em&gt; branch.&lt;/li&gt;
&lt;li&gt;Establish &lt;em&gt;local development environments&lt;/em&gt; that nix can set up for
us:
&lt;ol type="1"&gt;
&lt;li&gt;Haskell development – with haskell language server, cabal for intermediate
building, etc.&lt;/li&gt;
&lt;li&gt;Purescript development – I’ve structured each interactive blog post’s
purescript source as its own spago project, so we actually need to generate a
separate development environment (with purescript language server, etc.) for
each project. I don’t expect to be working on more than one at a given
time.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Writing&lt;/em&gt; – with the hakyll binary available for intermediate caching
for fast builds and updates and hakyll’s local preview server, and the
&lt;em&gt;purescript&lt;/em&gt; compiler available for fast compilation for the scripts
driving interactive blog posts.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One cool thing about cachix is that you get build caching for free for any
derivation you hand-write across all of your environments. You don’t need to
register your “package” to any sort of registry or set up custom cloud caching
in every situation.&lt;/p&gt;
&lt;h3 id="what-is-a-derivation"&gt;What is a Derivation?&lt;/h3&gt;
&lt;p&gt;The main character in all of these steps is the &lt;em&gt;nix derivation&lt;/em&gt;. In
my mental model, a nix derivation is a recipe for building “something” –
sometimes, it’s a binary, and in our case it’s often just going to be a
collection of files. A derivation contains a list of pinned reproducible
dependency derivations — so it’s all reproducible down the whole chain. In our
case:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The final derivation (the static site’s html files and contents)
&lt;em&gt;depends&lt;/em&gt; on the hakyll binary derivation and the compiled purescript
derivation&lt;/li&gt;
&lt;li&gt;The hakyll binary derivation depends on a pinned ghc, cabal, and a
derivation for every haskell library dependency.&lt;/li&gt;
&lt;li&gt;The compiled purescript derivation depends on the purescript compiler
(purs), as well as all purescript library dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When we say “depends”, it just means that uses what the derivation outputs in
one way or another. The final static site derivation uses the &lt;em&gt;binary&lt;/em&gt;
outputted by the hakyll binary derivation. It also uses the &lt;em&gt;javascript
files&lt;/em&gt; outputted by the compiled purescript derivation. And its
&lt;em&gt;output&lt;/em&gt; is just the static pages and contents of the site.&lt;/p&gt;
&lt;p&gt;One major leap for me was realizing that derivations just created output
files. In my mind, before this, I thought that a derivation was something
“executable” — when you first get into nix and nixos, “derivation” and
“executable” can sometimes appear synonymous. To install a new executable in
nixos (like &lt;em&gt;vim&lt;/em&gt; or any other linux program), you installed its
derivation. However, this was a misconception. It’s just a &lt;em&gt;convention&lt;/em&gt;
that if your derivation is meant to provide an executable, you put the binary
file in the &lt;code&gt;./bin/&lt;/code&gt; subdirectory of your output files. In our case,
our output files are sometimes binaries (which we put in &lt;code&gt;./bin/&lt;/code&gt;),
but they’re also sometimes static files, which we put in &lt;code&gt;./dist/&lt;/code&gt; or
&lt;code&gt;./js/&lt;/code&gt; or wherever we want. It’s just a “convention” that the
&lt;code&gt;./bin&lt;/code&gt; subdirectory of your output contains a binary that the caller
would want in their PATH, and so nix automatically puts the &lt;code&gt;./bin&lt;/code&gt;
of any dependency derivation in the PATH/execution environment for convenience.
At least, that’s my mental model and how I understand it — I am definitely new
to this, so if I’m incorrect at any point, feel free to leave a comment.&lt;/p&gt;
&lt;h3 id="what-is-a-development-environment"&gt;What is a development
environment?&lt;/h3&gt;
&lt;p&gt;Very important to this system is the local development environment that lets
us quickly re-build the site (and also lets us use hakyll’s built-in preview
server features). I have a little less refined of a mental model for these than
I do for the derivation — but apparently it’s just a derivation that sets up a
shell with everything we need in the PATH? In any case, we need to set one up
here to drop us in a Haskell development environment to get all of our favorite
Haskell development tools – like Haskell Language Server and cabal – and a
snapshot of all of our Haskell dependencies. And then we need one that just
gives us the hakyll binary, which has interactive development features like
directory watching, local servers, and incremental builds/cache
invalidation.&lt;/p&gt;
&lt;h3 id="prior-art"&gt;Prior Art&lt;/h3&gt;
&lt;p&gt;While researching this further, I noticed that this approach is similar to
that of &lt;em&gt;&lt;a
href="https://github.com/rpearce/hakyll-nix-template"&gt;hakyll-nix-template&lt;/a&gt;&lt;/em&gt;:
have a derivation for the hakyll binary, then a derivation for the final
website, then push to gh-pages with cachix to ensure caching haskell
dependencies. Because of this, I was able to use a lot of code from that
repository to help figure things out for my own path. So, a special thanks to &lt;a
href="https://github.com/rpearce"&gt;Robert Pearce&lt;/a&gt;!&lt;/p&gt;
&lt;h3 id="shortcomings-static-artifact-caching"&gt;Shortcomings: Static Artifact
Caching&lt;/h3&gt;
&lt;p&gt;There is one shortcoming to this approach that I consider very significant –
using nix with &lt;em&gt;cachix&lt;/em&gt; ensures that we don’t redo work at the derivation
level. So, if the purescript files don’t change, we won’t re-build the compiled
javascript. If the haskell files don’t change, we won’t re-build the hakyll
binary. But for a static site, we also have to build the site based on the input
files — mostly, markdown files. For my blog, this is not trivial – each markdown
post gets compiled and outputted into many different formats (latex, pdf, html
multiple times), and actually gets re-combined with re-usable code snippets from
different folders. In addition, we build a page for each of the many tags, a
paginated homepage, a granular history page, and an rss feed. On a whole, a
build from scratch takes about five minutes. This is a significant downgrade —
in the past, I could build and deploy almost instantaneously (under a
minute).&lt;/p&gt;
&lt;p&gt;I’m not sure if this can be optimized on the Haskell side, but it’s still
kind of wasteful in principle, because &lt;em&gt;hakyll&lt;/em&gt; is smart enough to only
re-build what is needed, if it’s run in its normal mode of operation. If you
update only a single post, hakyll will only update the pages that are effected —
the home page, the rss feed, and any tag pages it appears on, etc. It knows not
to re-generate any single blog post pages or pdf files for different blog posts
that aren’t affected by the new update.&lt;/p&gt;
&lt;p&gt;If you’re using github actions in the normal way, you might be able to take
advantage of this with github actions caches? It’s unclear to me how change
detection interacts with this. However, in the “nix style”, if we really want to
view the final generated site as a &lt;em&gt;nix derivation&lt;/em&gt; (and not just, ie, a
build script), it’s a little more complicated to make this fit into the
conceptual model and make sure cache invalidation etc. works correctly.&lt;/p&gt;
&lt;p&gt;What would be really ideal is if these units of cached data (individual web
pages, etc.) could be managed and invalidated by nix itself — maybe each blog
post’s outputs (the html, pdf, post-processed markdown, latex) could be a
derivation, and so these derivations won’t have to be re-built if the blog post
is not changed. There seems to be a few options in terms of “purely nix” static
site generators that could do this I think, but that’s not really an option to
me because the blog at this point is pretty huge, logic-wise, and also I would
rather write the blog in Haskell in the end still.&lt;/p&gt;
&lt;p&gt;Maybe in the future I could figure out how to modify hakyll to use the nix
cache for its caching and invalidation, instead of its own bespoke method? I
wonder if that’s even a viable option. If anyone has any insight, this newbie
would really appreciate hearing!&lt;/p&gt;
&lt;p&gt;In any case, for now, we can still have fast local development building (more
on that later), so it isn’t super painful to actually write test. However, the
deployment lag is still kind of annoying — and the “principal” of it (the wasted
work) does still bother me.&lt;/p&gt;
&lt;h2 id="assembling-the-pieces"&gt;Assembling the pieces&lt;/h2&gt;
&lt;p&gt;Again, this isn’t a tutorial — here, I’m going to explain to explain the
components I put together at a high level.&lt;/p&gt;
&lt;p&gt;We’re going to structure this in terms of a nix flake, which I’m using
to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pin dependencies and package sets&lt;/li&gt;
&lt;li&gt;Describe buildable derivations and the development environments in a single
file, which we can run with &lt;code&gt;nix build&lt;/code&gt; and &lt;code&gt;nix develop&lt;/code&gt;
commands.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For reference, the “final” nix flake described in this post &lt;a
href="https://github.com/mstksg/inCode/blob/bf444098b8773b1b47c0b2e66ca1682cdc5f674d/flake.nix"&gt;can
be found on github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="haskell"&gt;Haskell&lt;/h3&gt;
&lt;p&gt;For Haskell, I ended up using &lt;em&gt;&lt;a
href="https://input-output-hk.github.io/haskell.nix/#haskellnix"&gt;haskell.nix&lt;/a&gt;&lt;/em&gt;,
which is what I also what we use at work. It does this neat thing where it
parses a cabal file and uses &lt;em&gt;that&lt;/em&gt; to generate the derivation needed —
which includes the dependency derivations for all haskell library derivations.
In this way, it can cache all external dependencies. It also lets us solve for
which version of each dependency we need. And, by freezing it with flake lock,
it also allows us to freeze all of the versions of each dependency in a way that
works. There might be other tools that allow this, but I went with haskell.nix
because I’m already familiar with it. It also has a nice development environment
offered that contains haskell language server with all of the right package
versions and artifacts.&lt;/p&gt;
&lt;p&gt;Armed with this, we can easily generate a derivation for the hakyll binary,
by passing the cabal file to the &lt;code&gt;haskell-nix.project'&lt;/code&gt; function
provided by haskell.nix. Now step 1 is complete!&lt;/p&gt;
&lt;p&gt;Note we also get our development environment as well – you get it with the
&lt;code&gt;devShell&lt;/code&gt; property!&lt;/p&gt;
&lt;h3 id="purescript"&gt;Purescript&lt;/h3&gt;
&lt;p&gt;For Purescript, I ended up using &lt;a
href="https://github.com/purifix/purifix"&gt;purifix&lt;/a&gt;, which does a similar
thing with &lt;em&gt;haskell.nix&lt;/em&gt; but for the &lt;em&gt;spago.yaml&lt;/em&gt; file, which is
how modern purescript projects declare their dependencies. Purifix also has this
mode of operation where it auto-detects if you’re working in a monorepo-style
project with multiple binaries, and gives you a &lt;em&gt;separate derivation&lt;/em&gt; for
each binary (or, compiled .js file)! And also a separate development environment
for each binary, too. This works well for me because I structure the javascript
for each interactive blog post as its own project. So, I can export an entire
“project” (blog post file) to a bundled file easily, and also lead development
environments for specific blog posts as well.&lt;/p&gt;
&lt;p&gt;For each project, it provides a &lt;code&gt;bundle-app&lt;/code&gt; derivation that is
literally just the generated bundled-up single javascript file. This is exactly
the derivation we need for the final part where we pull everything together.&lt;/p&gt;
&lt;p&gt;However, it also gives us an easy way to access all of the derivations of all
of the dependencies (the &lt;code&gt;globs&lt;/code&gt; property it adds onto its
derivations) — which is very useful for our final integrated development
environment which needs to do incremental builds quickly.&lt;/p&gt;
&lt;p&gt;A note – finding all of these useful properties and derivations (outside of
the main ones) does take a bit of trial and error – digging through
&lt;code&gt;nix repl&lt;/code&gt; to explore the derivation contents, and the source code of
these projects.&lt;/p&gt;
&lt;h3 id="static-site-derivation"&gt;Static Site derivation&lt;/h3&gt;
&lt;p&gt;Putting it all together is the final derivation to generate the actual
site:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode nix"&gt;&lt;code class="sourceCode nix"&gt;&lt;span id="cb1-1"&gt;&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;web = pkgs.stdenv.mkDerivation &lt;span class="op"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-2"&gt;&lt;a href="#cb1-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;name&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;inCode&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-3"&gt;&lt;a href="#cb1-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;buildInputs&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;[&lt;/span&gt; inCode.haskell &lt;span class="op"&gt;]&lt;/span&gt; &lt;span class="op"&gt;++&lt;/span&gt; lib.attrValues inCode.purescript&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-4"&gt;&lt;a href="#cb1-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;srcs&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;[&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-5"&gt;&lt;a href="#cb1-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./code-samples&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-6"&gt;&lt;a href="#cb1-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./config&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-7"&gt;&lt;a href="#cb1-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./copy&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-8"&gt;&lt;a href="#cb1-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./css&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-9"&gt;&lt;a href="#cb1-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./js&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-10"&gt;&lt;a href="#cb1-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./latex&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-11"&gt;&lt;a href="#cb1-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./scss&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-12"&gt;&lt;a href="#cb1-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ss"&gt;./static&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-13"&gt;&lt;a href="#cb1-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="op"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-14"&gt;&lt;a href="#cb1-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;unpackPhase&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-15"&gt;&lt;a href="#cb1-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    for srcFile in $srcs; do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-16"&gt;&lt;a href="#cb1-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;      cp -a $srcFile/. $(stripHash $srcFile)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-17"&gt;&lt;a href="#cb1-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    done&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-18"&gt;&lt;a href="#cb1-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-19"&gt;&lt;a href="#cb1-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    mkdir _purescript&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-20"&gt;&lt;a href="#cb1-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-21"&gt;&lt;a href="#cb1-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      lib.concatStringsSep &lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="sc"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;(&lt;/span&gt;lib.mapAttrsToList&lt;/span&gt;
&lt;span id="cb1-22"&gt;&lt;a href="#cb1-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          &lt;span class="op"&gt;(&lt;/span&gt;&lt;span class="va"&gt;name&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="va"&gt;value&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;&amp;#39;cp &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;value.bundle&lt;span class="op"&gt;-&lt;/span&gt;app&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt; _purescript/&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;name&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;.js&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-23"&gt;&lt;a href="#cb1-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          inCode.purescript&lt;/span&gt;
&lt;span id="cb1-24"&gt;&lt;a href="#cb1-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="op"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-25"&gt;&lt;a href="#cb1-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;     &lt;span class="sc"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-26"&gt;&lt;a href="#cb1-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;  &amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-27"&gt;&lt;a href="#cb1-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;buildPhase&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-28"&gt;&lt;a href="#cb1-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;inCode.haskell&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;/bin/inCode-build build --verbose&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-29"&gt;&lt;a href="#cb1-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;  &amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-30"&gt;&lt;a href="#cb1-30" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;installPhase&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-31"&gt;&lt;a href="#cb1-31" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    mkdir -p &amp;quot;$out/dist&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-32"&gt;&lt;a href="#cb1-32" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    cp -a _site/. &amp;quot;$out/dist&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-33"&gt;&lt;a href="#cb1-33" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;  &amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-34"&gt;&lt;a href="#cb1-34" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="op"&gt;}&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the only “hand-built” derivation. Hopefully it’s legible enough:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;The &lt;code&gt;buildInputs&lt;/code&gt; attribute tells us what derivations give us the
binaries/generated files in scope for us to do our job.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inCode.haskell&lt;/code&gt; is the derivation that gives us the hakyll
binary, from running &lt;em&gt;haskell.nix&lt;/em&gt; on the haskell hakyll project.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib.attrValues inCode.purescript&lt;/code&gt; gives us each of the
derivations of all of the purescript projects, one for each spago sub-project
(and each blog post/page that uses purescript). In this case, it gives us the
actual compiled javascript bundle that the site generator expects.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;srcs&lt;/code&gt; is the actual source files that the static site generator
uses — in this case, the code samples, configuration files, markdown files for
the actual blog posts in &lt;code&gt;./copy&lt;/code&gt;, the static files, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unpackPhase&lt;/code&gt; is the shell script to get things ready for the
hakyll site generator to run:
&lt;ul&gt;
&lt;li&gt;First, copy all of the source files into the temporary build directory&lt;/li&gt;
&lt;li&gt;Then, copy all of the compiled javascript binaries (from the
&lt;code&gt;bundle-app&lt;/code&gt; property of each derivation) into the
&lt;code&gt;_purescript&lt;/code&gt; folder in the temporary build directory, where the
static site generator expects to find it.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buildPhase&lt;/code&gt; is the shell script to actually run the static site
generator on the work directory that we carefully unpacked. Note that we refer
to the binary using the derivation variable, &lt;code&gt;${inCode.haskell}&lt;/code&gt; and
knowing that it is found under the &lt;code&gt;bin&lt;/code&gt; folder, as convention
states.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;installPhase&lt;/code&gt; copies what the site generated (in the
&lt;code&gt;_site&lt;/code&gt; directory of the temporary work folder) into
&lt;code&gt;$out&lt;/code&gt;, which is the place we put the “results”.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="github-action"&gt;Github Action&lt;/h3&gt;
&lt;p&gt;The final github action is pretty standard — it pulls together the
actions:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;code&gt;cachix/install-nix-action&lt;/code&gt;: Install nix&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cachix/cachix-action&lt;/code&gt;: Use the given cachix cache and upload the
artifacts to it after building&lt;/li&gt;
&lt;li&gt;Actually run &lt;code&gt;nix build&lt;/code&gt; on the static site derivation to
generate the static files. In the process, it will either re-build (if anything
changes) the dependency haskell and purescfript derivations, or pull it straight
from cachix if nothing changed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;crazy-max/ghaction-github-pages&lt;/code&gt; to push the files to the
&lt;code&gt;gh-pages&lt;/code&gt; branch&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This was taken pretty much verbatim from &lt;em&gt;hakyll-nix-template&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="development-environment-for-writing"&gt;Development Environment for
Writing&lt;/h3&gt;
&lt;p&gt;Now, because we don’t have page-level caching for nix (and hakyll manages its
own caching), we have to bite the bullet and create a customized development
environment where we can locally deploy hakyll’s cached incremental builds.
Again, this will be a hand-written environment, so let’s think about what we
want. We need “temporary” directories that hakyll will use to (1) find the
source files, (2) store its cache, and (3) output the static site. Because of
this, if we make any changes to blog posts while we are in our development
environment, hakyll will not do a full re-build — it’ll still have its
development-environment-scoped cache. We can also use hakyll’s built in local
preview server and filesystem watch-and-rebuild features. We also want to do
incremental builds for purescript development as well, and we need to make sure
that this temporary environment also has an incremental build cache area for
&lt;code&gt;purs&lt;/code&gt;. While we &lt;em&gt;could&lt;/em&gt; do this without any temporary
directories by just using the working directory for this, it is kind of nice to
be able to have this all take place in a temporary folder that will go away
after we exit the development environment.&lt;/p&gt;
&lt;p&gt;Unfortunately, the hakyll binary isn’t aware of &lt;code&gt;purs&lt;/code&gt; and
purescript — it just receives the compiled bundles. So, we need a way for the
user to run a command to re-build the purescript dependencies if they have
changed it. There are a few ways we can do this (maybe have nix initiate a
“watcher” that automatically incrementally recompiles, or wrap our hakyll binary
in a wrapper shell script that triggers a re-build). However, the simplest way I
could think of (that also does the job) is for the development environment to
provide a command/shell script that just runs &lt;code&gt;purs&lt;/code&gt; with the right
arguments.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode nix"&gt;&lt;code class="sourceCode nix"&gt;&lt;span id="cb2-1"&gt;&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;rebuild&lt;span class="op"&gt;-&lt;/span&gt;js =&lt;/span&gt;
&lt;span id="cb2-2"&gt;&lt;a href="#cb2-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-3"&gt;&lt;a href="#cb2-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="va"&gt;buildSingleDep&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;name&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="va"&gt;value&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-4"&gt;&lt;a href="#cb2-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="kw"&gt;let&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-5"&gt;&lt;a href="#cb2-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="va"&gt;srcGlob&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;purescript/&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;name&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;/src/**/*.purs&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-6"&gt;&lt;a href="#cb2-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="va"&gt;buildDir&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;$HAKYLL_DIR/_purescript-build/&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;name&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-7"&gt;&lt;a href="#cb2-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="va"&gt;mainModule&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;buildDir&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;/Main/index.js&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-8"&gt;&lt;a href="#cb2-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="va"&gt;outFile&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;$HAKYLL_DIR/_purescript/&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;name&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;.js&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-9"&gt;&lt;a href="#cb2-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-10"&gt;&lt;a href="#cb2-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-11"&gt;&lt;a href="#cb2-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;        mkdir -p &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;buildDir&lt;span class="sc"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-12"&gt;&lt;a href="#cb2-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;        purs compile &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;&lt;span class="bu"&gt;toString&lt;/span&gt; value.globs&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt; &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;srcGlob&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt; -o &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;buildDir&lt;span class="sc"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-13"&gt;&lt;a href="#cb2-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;        chmod -R +w &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;buildDir&lt;span class="sc"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-14"&gt;&lt;a href="#cb2-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;        echo &amp;quot;import {main} from &amp;#39;&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;mainModule&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;; main()&amp;quot; | esbuild --bundle --outfile=&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;outFile&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt; --format=iife&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-15"&gt;&lt;a href="#cb2-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;      &amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-16"&gt;&lt;a href="#cb2-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-17"&gt;&lt;a href="#cb2-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  pkgs.writeShellScriptBin&lt;/span&gt;
&lt;span id="cb2-18"&gt;&lt;a href="#cb2-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="st"&gt;&amp;quot;rebuild-js&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-19"&gt;&lt;a href="#cb2-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-20"&gt;&lt;a href="#cb2-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;      mkdir -p &amp;quot;$HAKYLL_DIR/_purescript&amp;quot;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-21"&gt;&lt;a href="#cb2-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;      &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;lib.concatStringsSep &lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="sc"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;(&lt;/span&gt;lib.mapAttrsToList buildSingleDep inCode.purescript&lt;span class="op"&gt;)&lt;/span&gt;&lt;span class="sc"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-22"&gt;&lt;a href="#cb2-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    &amp;#39;&amp;#39;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;writeShellScriptBin&lt;/code&gt; is a convenient way to provide a derivation
that &lt;em&gt;only&lt;/em&gt; contains a single shell script in its &lt;code&gt;bin/&lt;/code&gt;
subdir. So if we include it as a dependency in our development environment, this
shell script will be in scope. Keep in mind that the hakyll binary expects the
output bundles in the &lt;code&gt;_purescript&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;In the script, &lt;code&gt;$HAKYLL_DIR&lt;/code&gt; is our temporary working directory.
We iterate over each of the derivations in &lt;code&gt;inCode.purescript&lt;/code&gt;, and
for each one, we create a temporary build directory and use &lt;code&gt;purs&lt;/code&gt; to
compile all of the source files for the project (using the &lt;code&gt;globs&lt;/code&gt;
property that &lt;code&gt;purifix&lt;/code&gt; gives us, which contains globs of all the
source files of the dependencies as well, which are found in the global nix
cache). And then we use &lt;code&gt;esbuild&lt;/code&gt; to manually generate the final
bundle in the output directory.&lt;/p&gt;
&lt;p&gt;And, to assemble the initial working directory, we have to:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Copy all of the compiled purescript bundles into the temporary directory,
from the derivation based on the current state at initialization time.&lt;/li&gt;
&lt;li&gt;Simlink all of the source files (markdown, etc.) in the user’s working
directory to the temporary working directory, so any changes to the working
directory will also be reflected in the temporary directory.&lt;/li&gt;
&lt;li&gt;Provide all of the build tools through &lt;code&gt;nativeBuildInputs&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Provide the user-accessible commands through &lt;code&gt;packages&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode nix"&gt;&lt;code class="sourceCode nix"&gt;&lt;span id="cb3-1"&gt;&lt;a href="#cb3-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;devShells.default = pkgs.mkShell &lt;span class="op"&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-2"&gt;&lt;a href="#cb3-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;shellHook&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-3"&gt;&lt;a href="#cb3-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    export HAKYLL_DIR=$(mktemp -d)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-4"&gt;&lt;a href="#cb3-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    echo &amp;quot;Available commands: rebuild-js inCode-build&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-5"&gt;&lt;a href="#cb3-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    echo &amp;quot;Hakyll working directory: \$HAKYLL_DIR&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-6"&gt;&lt;a href="#cb3-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-7"&gt;&lt;a href="#cb3-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    mkdir -p $HAKYLL_DIR/_purescript&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-8"&gt;&lt;a href="#cb3-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;lib.concatStringsSep &lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="sc"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-9"&gt;&lt;a href="#cb3-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;(&lt;/span&gt;lib.mapAttrsToList&lt;/span&gt;
&lt;span id="cb3-10"&gt;&lt;a href="#cb3-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="op"&gt;(&lt;/span&gt;&lt;span class="va"&gt;name&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="va"&gt;value&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-11"&gt;&lt;a href="#cb3-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-12"&gt;&lt;a href="#cb3-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;          cp -a &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;value.deps&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;/output/. purescript/output&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-13"&gt;&lt;a href="#cb3-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;          chmod -R +w purescript/output&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-14"&gt;&lt;a href="#cb3-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;          cp &lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;value.bundle&lt;span class="op"&gt;-&lt;/span&gt;app&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt; $HAKYLL_DIR/_purescript/&lt;/span&gt;&lt;span class="sc"&gt;${&lt;/span&gt;name&lt;span class="sc"&gt;}&lt;/span&gt;&lt;span class="st"&gt;.js&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-15"&gt;&lt;a href="#cb3-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;          &amp;#39;&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-16"&gt;&lt;a href="#cb3-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="op"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-17"&gt;&lt;a href="#cb3-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      inCode.purescript&lt;/span&gt;
&lt;span id="cb3-18"&gt;&lt;a href="#cb3-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;)&lt;/span&gt;&lt;span class="sc"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-19"&gt;&lt;a href="#cb3-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    chmod -R +w $HAKYLL_DIR/_purescript&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-20"&gt;&lt;a href="#cb3-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-21"&gt;&lt;a href="#cb3-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    for srcDir in code-samples config copy css js latex scss static; do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-22"&gt;&lt;a href="#cb3-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;      ln -s &amp;quot;$PWD/$srcDir&amp;quot; $HAKYLL_DIR&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-23"&gt;&lt;a href="#cb3-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;    done&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-24"&gt;&lt;a href="#cb3-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="st"&gt;  &amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-25"&gt;&lt;a href="#cb3-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;nativeBuildInputs&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;[&lt;/span&gt; pkgs.esbuild pkgs.purescript &lt;span class="op"&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-26"&gt;&lt;a href="#cb3-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;++&lt;/span&gt; haskellFlake.devShell.nativeBuildInputs&lt;/span&gt;
&lt;span id="cb3-27"&gt;&lt;a href="#cb3-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;++&lt;/span&gt; lib.attrValues inCode.purescript&lt;/span&gt;
&lt;span id="cb3-28"&gt;&lt;a href="#cb3-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;++&lt;/span&gt; &lt;span class="bu"&gt;map&lt;/span&gt; &lt;span class="op"&gt;(&lt;/span&gt;&lt;span class="va"&gt;value&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; value.develop.buildInputs&lt;span class="op"&gt;)&lt;/span&gt; &lt;span class="op"&gt;(&lt;/span&gt;lib.attrValues inCode.purescript&lt;span class="op"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-29"&gt;&lt;a href="#cb3-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="va"&gt;packages&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;[&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-30"&gt;&lt;a href="#cb3-30" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    rebuild-js&lt;/span&gt;
&lt;span id="cb3-31"&gt;&lt;a href="#cb3-31" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    inCode.haskell&lt;/span&gt;
&lt;span id="cb3-32"&gt;&lt;a href="#cb3-32" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="op"&gt;];&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-33"&gt;&lt;a href="#cb3-33" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="op"&gt;}&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="conclusions"&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Overall, I still feel like I’m hacking things together and figuring things
out as I go. So far, all I have done is automate a set-up that I have been doing
manually, in hopefully a way that is better for long-term maintainability.
However, hopefully as I learn more, I start to open up new doors and new ways of
thinking that enable to me to do things I haven’t been able to do before.&lt;/p&gt;
&lt;p&gt;Thank you for reading this — whether you are looking to get started into nix,
or are an experienced veteran, I hope you were able to get something out of this
post. And, for those with experience, I would definitely appreciate any advice
concerning the things described in this post — things I could have done better,
alternative approaches, or ways to be more idiomatic/maintainable.&lt;/p&gt;</description><author>Justin Le</author><category>Meta</category><guid isPermaLink="true">https://blog.jle.im/entry/i-nixified-my-blog.html</guid><pubDate>Sun,  1 Jan 2023 21:21:32 UTC</pubDate><creator>Justin Le</creator><subject>Meta</subject><date>2023-01-01</date></item><item><title>Breaking a Degenerate Hyper-Dimensional Game of Life
</title><link>https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html</link><description>&lt;p&gt;tldr: Demonstrated with interactive visualizations and simulations — over the
course of a month, we were able to discover successive new mathematical
properties of a “degenerate” hyper-dimensional game of life” to take a “7
dimensions may just barely be possible on a commercial PC, could we ever reach
10 dimensions?” to “10 dimensions is easy enough to be run on any modern browser
(&lt;a href="#gol2D"&gt;jump&lt;/a&gt; &lt;a href="#gol3D"&gt;to&lt;/a&gt; &lt;a href="#gol4D"&gt;spoilers&lt;/a&gt;
&lt;a href="#golFlat"&gt;here&lt;/a&gt;), and 60 dimensions can be reached with a compiled
language”.&lt;/p&gt;
&lt;p&gt;This is a story about breaking a degenerate hyper-dimensional game of life
via interactive exploratory visualizations and math!&lt;/p&gt;
&lt;p&gt;T’was the night before Thursday, December 17, 2020, the release of &lt;a
href="https://adventofcode.com/2020/day/17"&gt;“Conway Cubes”&lt;/a&gt;. It was Day 17 of
&lt;a href="https://adventofcode.com/2020"&gt;Advent of Code 2020&lt;/a&gt;, a series of fun
little themed coding puzzles building up to Christmas; I always enjoyed these
puzzles because they are so self-contained and tidy that they are often
&lt;em&gt;open-ended&lt;/em&gt; in the interesting ways you can solve them or expand on them
(which I’ve written &lt;a
href="https://blog.jle.im/entries/series/+advent-of-code.html"&gt;many blog posts
on&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;On the surface, Day 17 seemed to be a straightforward extension of &lt;a
href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life"&gt;Conway’s Game Of
Life&lt;/a&gt; (“GoL”). GoL is a simulation played out on a 2D grid, where cells are
“on” and “off”, and at each step of the simulation the states spread and
propagate in interesting ways based on the state of their neighbors (a &lt;a
href="https://en.wikipedia.org/wiki/Cellular_automaton"&gt;2D cellular
automaton&lt;/a&gt;). The twist of the Advent of Code puzzle is it asks what would
happen if we played out the rules of GoL in 3D instead, and then 4D.&lt;/p&gt;
&lt;p&gt;I submitted my solution on my assigned puzzle input with a naive
implementation (placing 66 and 66 on the leaderboards for that day), concluding
the “competitive” part. Of course, the real fun always starts after. When
discussing with some friends (on the &lt;a
href="https://www.reddit.com/r/adventofcode"&gt;subreddit&lt;/a&gt; and freenode’s
&lt;code&gt;##adventofcode&lt;/code&gt; channel), we started talking about the trade-offs of
different implementations and realized that the extra dimensionality was no
joke: as you upped the number of dimensions, the number of points you have to
consider grow exponentially, and so does the number of neighbors at each point
to check. 4D can be solved naively, but anything higher is going to be strained.
My naive solution on 6D took three minutes, and 7D in a reasonable amount of
time (requiring as much as 612,220,032 points with 2,186 neighbors each) seemed
&lt;em&gt;impossible&lt;/em&gt; on commercial consumer hardware because of the sheer number
of points in 7D space. But I thought…what if a breakthrough in optimization was
possible? I set an (arbitrary) personal goal of reaching 10D (3,570,467,226,624
points with 59,048 neighbors each), not knowing if it would ever be
possible.&lt;/p&gt;
&lt;p&gt;And soon…a breakthrough did come! Someone brought up that if we look at the
3d version, we see there’s actually a &lt;em&gt;mirror symmetry&lt;/em&gt;! Because
everything starts off on the xy plane, with z=0, the resulting progression must
be symmetrical on both sides (positive and negative z).&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/img/entries/advent-gol/life3d.gif"
title="3D GoL animation demonstrating mirror symmetry by u/ZubSpAcE"
alt="3D GoL animation demonstrating mirror symmetry by u/ZuBsPaCe" /&gt;
&lt;figcaption aria-hidden="true"&gt;3D GoL animation demonstrating mirror symmetry by
&lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfa3nr/2020_day_17_godot_cubes_i_think_i_went_a_bit_too/"&gt;u/ZuBsPaCe&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This meant that we only have to simulate the &lt;em&gt;positive&lt;/em&gt; points (since
the negative points are identical). This saves down the number of points by a
factor of two for each extra dimension! Unfortunately, this wouldn’t quite get
us to 10D, but the discovery completely changed how we saw this puzzle. With one
breakthrough down, we began to believe that there would be more just around the
corner, made possible by our problem’s special 2D-slice starting degeneracy.&lt;/p&gt;
&lt;p&gt;Such a dream (as posed in &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/"&gt;this
reddit thread I started&lt;/a&gt;) turned into a month-long ride of breakthrough after
breakthrough, exploiting different aspects of this degeneracy. It was a month
full of sudden twists and turns and bursts of excitement whenever new
innovations came. And in the end, the hopeful question “7D is barely in reach;
what if 10D was possible?” turned into “10D in 100ms, 40D in eight minutes…can
we do 60D quickly?” This post even includes simulations to prove that we got 10D
fast enough to run on easily on any modern browser. The whole journey became an
adventure in the power of visualization combined with abstract thinking.&lt;/p&gt;
&lt;p&gt;So, let’s take a deep dive — deeper than you probably ever expected to dive
into any particular degenerate starting conditions of a hyper-dimensional game
of life :D&lt;/p&gt;
&lt;p&gt;There will be python code samples here and there, but just for context, my
actual solvers I developed along the way were &lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/src/AOC/Challenge/Day17.hs"&gt;written
in Haskell&lt;/a&gt;, and all of the solving logic embedded in this post was written
in Purescript (&lt;a
href="https://github.com/mstksg/inCode/blob/master/app-purescript/Gol.purs"&gt;online
here&lt;/a&gt;) and compiled to Javascript.&lt;/p&gt;
&lt;h2 id="table-of-figures"&gt;Table of Figures&lt;/h2&gt;
&lt;p&gt;For reference, the interactive elements in this post are:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="#golDrawer"&gt;Initial condition drawer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#gol2D"&gt;2D Game of Life&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#gol3D"&gt;3D Game of Life&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#golSyms3DForward"&gt;3D Forward Neighbor Multiplicities&lt;/a&gt; / &lt;a
href="#golSyms3DReverse"&gt;3D Reverse Neighbor Multiplicities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#gol4D"&gt;4D Game of Life&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#golSyms4DForward"&gt;4D Forward Neighbor Multiplicities&lt;/a&gt; / &lt;a
href="#golSyms4DReverse"&gt;4D Reverse Neighbor Multiplicities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#golSyms5D"&gt;5D Neighbor Multiplicities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#golTree"&gt;General Neighbor Multiplicity Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#golFlat"&gt;N-D Game of Life&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="starting-off"&gt;Starting Off&lt;/h2&gt;
&lt;p&gt;First of all, let’s meet our friend for the rest of this journey. In the
drawer below, you can &lt;em&gt;draw&lt;/em&gt; (with your mouse) the 8x8 grid you want to
simulate for the rest of this post. As you draw, the rest of the visualizations
will update to use this as their initial conditions, so feel free to jump back
and forth as you’re reading to customize and change what you want to
simulate.&lt;/p&gt;
&lt;div id="golDrawer" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 1:&lt;/strong&gt; Initial Condition Drawer&lt;/p&gt;
&lt;div id="golDrawerCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Here are some sample fun ones you can try out (click to load):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=____._▝▖_._▀▘_.____"
class="loadpoints"&gt;classic glider&lt;/a&gt;, a default if only for how iconic it
is.&lt;/li&gt;
&lt;li&gt;The &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=____._▞▖_._▝__.____"
class="loadpoints"&gt;tub&lt;/a&gt;, which is a “still-life” in 2D, but explodes into a
twinkling frenzy during the 4D animation.&lt;/li&gt;
&lt;li&gt;The &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=████.████.████.████"
class="loadpoints"&gt;full block&lt;/a&gt;, which dies out in 2D but produces very
appealing patterns in 3D and 4D. A &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=▛▀▀▜.▌▛▜▐.▌▙▟▐.▙▄▄▟"
class="loadpoints"&gt;bulls-eye&lt;/a&gt; also yields interesting “geometric” patterns at
higher dimensions. A &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=████.▄▗▖▄.▀▝▘▀.████"
class="loadpoints"&gt;broken bar code&lt;/a&gt; also yields explosively intricate
alternating behavior at higher dimensions.&lt;/li&gt;
&lt;li&gt;The &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=██▟█.▜███.███▙.█▛██"
class="loadpoints"&gt;spiral galaxy&lt;/a&gt; with rotational symmetry, which produces
rich spiral galaxy patterns up until 6D, but then all of a sudden becomes blocky
and bland at 7D and above.&lt;/li&gt;
&lt;li&gt;My &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=▛▜▙▐.▜▚▗_.█▟▄▘.▟▌▟█"
class="loadpoints"&gt;own personal assigned puzzle input&lt;/a&gt;, to see what the
typical input looks like that people had to run on December 17th.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I recommend trying out some of the &lt;a
href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Examples_of_patterns"&gt;other
interesting well-known patterns&lt;/a&gt; from 2D GoL, as well! If you find any
interesting ones, I would be excited to hear about them!&lt;/p&gt;
&lt;p&gt;For fun, here’s a 2D vanilla game of life implementation (for six time steps)
to test out your creation. Remember that some starting conditions will putter
out in 2D, but expand forever in 3D+ due to the abundance of neighbors.&lt;/p&gt;
&lt;div id="gol2D" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 2:&lt;/strong&gt; 2D Game of Life&lt;/p&gt;
&lt;div id="gol2DCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now that that’s there, let’s start at the beginning: what’s the naive,
baseline solution?&lt;/p&gt;
&lt;p&gt;A reasonable initial thought would be:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Keep a 2D (or 3D, or 4D, etc.) array of booleans.&lt;/li&gt;
&lt;li&gt;At each step:
&lt;ol type="a"&gt;
&lt;li&gt;Make a fresh copy of the entire space (&lt;span
class="math inline"&gt;\(O(n^d)\)&lt;/span&gt;).&lt;/li&gt;
&lt;li&gt;Loop over each item in your array (&lt;span
class="math inline"&gt;\(O(n^d)\)&lt;/span&gt;). Count all of the neighbors (&lt;span
class="math inline"&gt;\(O(3^d)\)&lt;/span&gt;) that are &lt;code&gt;true&lt;/code&gt; (“alive”), and
write to the new array based on the rules table of GoL (2 or 3 neighbors for a
live cell stays alive, 3 neighbors for a dead cell turns alive).&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;You have a new array! Loop again six times.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Sounds reasonable enough! This does work for the 2D case pretty well (like in
the &lt;a href="https://adventofcode.com/2020/day/11"&gt;Day 11 puzzle&lt;/a&gt;). However,
there are some clear issues when moving into higher dimensions. The size of your
array grows exponentially on your dimension, and so does the number of neighbors
you’d have to check. And the &lt;a
href="https://en.wikipedia.org/wiki/Curse_of_dimensionality"&gt;curse of
dimensionality&lt;/a&gt; assures us that more and more of that array would become
wasted as the proportion of “on” points shrinks to zero for higher
dimensions.&lt;/p&gt;
&lt;p&gt;Oh, but what’s that? The percentage of “on” points shrinks to zero for higher
dimensions? That actually sounds like something we can use to our
&lt;em&gt;advantage&lt;/em&gt;! The &lt;em&gt;blessing&lt;/em&gt; of dimensionality*, I daresay? Because
we know the vast majority of our points will be “off”, there’s another
approach:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Keep a &lt;em&gt;set&lt;/em&gt; of points that are “on”.&lt;/li&gt;
&lt;li&gt;At each step:
&lt;ol type="a"&gt;
&lt;li&gt;&lt;p&gt;Initialize a dynamic map (key-value store, like a python dict or Counter)
of points to integers. This map associates each point to the number of live
neighbors it has.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For each step, iterate over each of your “on” points, expand all of their
neighbors &lt;span class="math inline"&gt;\(n_i\)&lt;/span&gt; (&lt;span
class="math inline"&gt;\(O(3^d)\)&lt;/span&gt;), and increment the value associated with
&lt;span class="math inline"&gt;\(n_i\)&lt;/span&gt; in your dynamic map.&lt;/p&gt;
&lt;p&gt;For example, if the point &lt;code&gt;&amp;lt;2,3&amp;gt;&lt;/code&gt; is in your set of live
points, you would add increment the map’s values at keys
&lt;code&gt;&amp;lt;1,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;2,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;3,2&amp;gt;&lt;/code&gt;,
etc.: all 8 neighbors of &lt;code&gt;&amp;lt;2,3&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Collect your new set of “on” points: keep all of the keys in your dynamic
map corresponding to live points if their integers are 2 or 3, and keep all of
the keys in your dynamic map corresponding to dead points if their integers are
3.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;You have a new set! Loop again six times!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(I discuss this algorithm much more deeply with actual code in &lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day17.md"&gt;my
solutions write-up in my Advent of Code reflections journal&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;This method nets us a huge advantage because we now only have to loop over
the number of items that we know are alive, and any points away from our set of
alive points can be properly ignored. This narrows down our huge iteration
space, and the benefits compound with every dimension due to the blessing of
dimensionality.&lt;a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Both methods can be generalized to any dimension; in this second method, this
just means a different sized tuple/vector in your set of alive points
(&lt;code&gt;[x,y]&lt;/code&gt; vs. &lt;code&gt;[x,y,z]&lt;/code&gt;). One extra concern, though, is
that you need to think through generating all &lt;span
class="math inline"&gt;\(3^d-1\)&lt;/span&gt; neighbors: that’s going to come down to a
d-ary &lt;a href="https://observablehq.com/@d3/d3-cross"&gt;cartesian product&lt;/a&gt; of
&lt;code&gt;[-1,0,1]&lt;/code&gt; to itself.&lt;/p&gt;
&lt;p&gt;Here’s a python implementation of the set-based method, using a nice trick I
learned from &lt;a href="https://twitter.com/phaazon_"&gt;phaazon&lt;/a&gt; and &lt;a
href="https://github.com/glguy"&gt;glguy&lt;/a&gt; to get the right neighbors by doing a
cartesian product against &lt;code&gt;[0,-1,1]&lt;/code&gt; instead of
&lt;code&gt;[-1,0,1]&lt;/code&gt;, which leaves the first item as the
&lt;code&gt;&amp;lt;0,0&amp;gt;&lt;/code&gt; “original point” we want to exclude.&lt;a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb1-1"&gt;&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="im"&gt;from&lt;/span&gt; itertools &lt;span class="im"&gt;import&lt;/span&gt; islice, product&lt;/span&gt;
&lt;span id="cb1-2"&gt;&lt;a href="#cb1-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="im"&gt;from&lt;/span&gt; collections &lt;span class="im"&gt;import&lt;/span&gt; Counter&lt;/span&gt;
&lt;span id="cb1-3"&gt;&lt;a href="#cb1-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-4"&gt;&lt;a href="#cb1-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; mk_neighbs(point):&lt;/span&gt;
&lt;span id="cb1-5"&gt;&lt;a href="#cb1-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Return neighboring points, with the original point first&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-6"&gt;&lt;a href="#cb1-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-7"&gt;&lt;a href="#cb1-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    (1, 2)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-8"&gt;&lt;a href="#cb1-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    =&amp;gt; [(1, 2), (1, 1), (1, 3), (0, 2), (0, 1), (0, 3), (2, 2), (2, 1), (2, 3)]&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-9"&gt;&lt;a href="#cb1-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-10"&gt;&lt;a href="#cb1-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(product(&lt;span class="op"&gt;*&lt;/span&gt;[[x, x&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, x&lt;span class="op"&gt;+&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="cf"&gt;for&lt;/span&gt; x &lt;span class="kw"&gt;in&lt;/span&gt; point]))&lt;/span&gt;
&lt;span id="cb1-11"&gt;&lt;a href="#cb1-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-12"&gt;&lt;a href="#cb1-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; step_naive(pts):&lt;/span&gt;
&lt;span id="cb1-13"&gt;&lt;a href="#cb1-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Takes a set of points (tuples) and steps them in the simulation&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-14"&gt;&lt;a href="#cb1-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-15"&gt;&lt;a href="#cb1-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    neighbs &lt;span class="op"&gt;=&lt;/span&gt; Counter()&lt;/span&gt;
&lt;span id="cb1-16"&gt;&lt;a href="#cb1-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; point &lt;span class="kw"&gt;in&lt;/span&gt; pts:&lt;/span&gt;
&lt;span id="cb1-17"&gt;&lt;a href="#cb1-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# skip the first item, the original point&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-18"&gt;&lt;a href="#cb1-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        neighbs &lt;span class="op"&gt;+=&lt;/span&gt; Counter(mk_neighbs(point)[&lt;span class="dv"&gt;1&lt;/span&gt;:])&lt;/span&gt;
&lt;span id="cb1-19"&gt;&lt;a href="#cb1-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-20"&gt;&lt;a href="#cb1-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; validate(point, ncount):&lt;/span&gt;
&lt;span id="cb1-21"&gt;&lt;a href="#cb1-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; point &lt;span class="kw"&gt;in&lt;/span&gt; pts:&lt;/span&gt;
&lt;span id="cb1-22"&gt;&lt;a href="#cb1-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="kw"&gt;or&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-23"&gt;&lt;a href="#cb1-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb1-24"&gt;&lt;a href="#cb1-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-25"&gt;&lt;a href="#cb1-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb1-26"&gt;&lt;a href="#cb1-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;frozenset&lt;/span&gt;(p &lt;span class="cf"&gt;for&lt;/span&gt; p, n &lt;span class="kw"&gt;in&lt;/span&gt; neighbs.items() &lt;span class="cf"&gt;if&lt;/span&gt; validate(p, n))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="three-dimensions"&gt;Three Dimensions&lt;/h2&gt;
&lt;p&gt;Let’s see how this looks for the 3D case! To make things easier to see, we
can render things in “slices” in 3D space: each grid represents a slice at a
different z level (ie, the z=0 square represents all squares
&lt;code&gt;&amp;lt;x,y,0&amp;gt;&lt;/code&gt;, the z=1 square represents all squares
&lt;code&gt;&amp;lt;x,y,1&amp;gt;&lt;/code&gt;, etc.). Press “Play” to have the simulation cycle
through 6 time steps!&lt;/p&gt;
&lt;div id="gol3D" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 3:&lt;/strong&gt; 3D Game of Life&lt;/p&gt;
&lt;div id="gol3DCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(Some patterns I suggest trying out are the flowery &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=██▟█.▜███.███▙.█▛██"
class="loadpoints"&gt;spiral galaxy&lt;/a&gt; pattern and patterns with a single
reflection symmetry, like the &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=████.▄▗▖▄.▀▝▘▀.████"
class="loadpoints"&gt;broken bar code&lt;/a&gt;; double symmetry like &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=▛▀▀▜.▌▛▜▐.▌▙▟▐.▙▄▄▟"
class="loadpoints"&gt;bulls-eye&lt;/a&gt; look nice too!)&lt;/p&gt;
&lt;p&gt;In reality, each of those 13 slices above are stacked on top of each other in
3D space. You’ll see that your live cells spread out from the center z=0 slice,
which means they are actually spreading “up and down” the z axis.&lt;/p&gt;
&lt;p&gt;If you mouse over (or tap) any individual tiny &lt;code&gt;&amp;lt;x,y&amp;gt;&lt;/code&gt; cell,
you’ll see the all of the 26 (&lt;span class="math inline"&gt;\(3^d-1\)&lt;/span&gt;)
&lt;code&gt;&amp;lt;x,y,z&amp;gt;&lt;/code&gt; 3D neighbors of the point you’re hovering over
highlighted in blue — these 26 points form a 3D cube around your mouse through
the stacked slices. You can use this cube to help see how the simulation
progresses. If your mouse is hovering over a live cell, and there are 2 or 3
live cells highlighted in your cube, it’ll stay alive in the next time step. If
your mouse is hovering over a dead cell and there are exactly 3 live cells
highlighted in your cube, it will come alive in the next step.&lt;/p&gt;
&lt;h3 id="axis-reflection-symmetry"&gt;Axis Reflection Symmetry&lt;/h3&gt;
&lt;p&gt;Try playing around with different initial conditions to see how they evolve!
See any patterns?&lt;/p&gt;
&lt;p&gt;Freenode IRC user &lt;a href="https://github.com/sim642"&gt;sim642&lt;/a&gt; noticed
something late into the night of December 16th:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I wanted to ask this before but forgot: did anyone try to take advantage of
the symmetry, e.g. in z axis in part 1? Should halve the amount of calculations
you have to do.&lt;/p&gt;
&lt;p&gt;Only some extra work at the end to differentiate z=0 and z&amp;gt;0 positions to
know which to count twice And in part 2 I feel like you could also exploit the
symmetry in w axis simultaneously&lt;/p&gt;
&lt;p&gt;— sim642&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You might have seen this too: the entire thing has reflection symmetry across
z=0! z=1 is always the same as z=-1, z=2 is always the same as z=-2, etc.
Fundamentally, this is because our starting solution has a &lt;em&gt;z-axis
symmetry&lt;/em&gt;: the initial 2D slice is symmetric with reflections across z,
because z=0 for all of those points. This is the first “degeneracy” that this
blog post’s title is referring to: the negative and positive directions are
interchangeable! This is reflected in the yellow highlight on hover: when you
mouse-over a z square, its corresponding reflected twin is highlighted, and will
always be identical.&lt;/p&gt;
&lt;p&gt;This means that we actually only need to simulate &lt;em&gt;positive&lt;/em&gt; z’s…and
for our final answer we just “un-reflect” to get the total number.&lt;/p&gt;
&lt;p&gt;Let’s do this! Apparently, the picture is slightly more complicated than
simply halving the points; we also need to change how to distribute neighbors.
That’s because, once we commit to only keeping the positive z’s, some cells need
to be double-counted as neighbors. In particular, any &lt;code&gt;z=0&lt;/code&gt; cell
would previously had a neighbor at both &lt;code&gt;z=-1&lt;/code&gt; and
&lt;code&gt;z=1&lt;/code&gt;…but now if we only keep the positive z’s, it would have
&lt;code&gt;z=1&lt;/code&gt; as a neighbor &lt;em&gt;twice&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The following interactive element lets you explore what this looks like:&lt;/p&gt;
&lt;div id="golSyms3DForward" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 4a:&lt;/strong&gt; 3D Forward Neighbor Multiplicities&lt;/p&gt;
&lt;div id="golSyms3DForwardCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Each square represents an entire “slice” of z. When you mouse-over or tap a
z-cell, its z-neighbors are highlighted with how many times that neighbor has to
be counted, and the green bar tells you from what direction that neighborship
arose from. For example, mousing over z=3, you will see z=2 and z=4 get
highlighted with the values “1” because they are neighbors of 3, on the left and
right side (respectively). Note that one neat property for all squares (except
for z=6, which goes off the scale) is that the “total” higher-dimensional
neighbors is always 2 (&lt;span class="math inline"&gt;\(3^{d-2}-1\)&lt;/span&gt;) just like
before; it’s just that &lt;em&gt;where&lt;/em&gt; those neighbors fall is re-arranged
slightly.&lt;/p&gt;
&lt;p&gt;The tricky square is now z=0: if you mouse-over it, you’ll see that it has a
single neighbor z=1 that is counted &lt;em&gt;twice&lt;/em&gt;, as a neighbor from both the
left and right side.&lt;/p&gt;
&lt;p&gt;We can compute the above diagram by expanding any z to its neighbors (z-1,
and z+1), applying the absolute value function, and seeing how points double-up.
This gives us the &lt;strong&gt;forward neighbors&lt;/strong&gt;, and we can directly use it
for the original “keep the full array” GoL implementation method.&lt;/p&gt;
&lt;p&gt;However, for the “keep active points and expand their neighbors” GoL
implementation, we have to find the opposite of this. Remember that to build our
“neighbors map” (the map of points to how many active neighbors they have), we
have each cell “proactively” add its contributions to all of its neighbors.
&lt;code&gt;&amp;lt;1,2,3&amp;gt;&lt;/code&gt; is a neighbor to &lt;code&gt;&amp;lt;1,3,4&amp;gt;&lt;/code&gt; once, so
when we expand &lt;code&gt;&amp;lt;1,2,3&amp;gt;&lt;/code&gt; we would increment the value in the
map at &lt;code&gt;&amp;lt;1,3,4&amp;gt;&lt;/code&gt; by 1 because &lt;code&gt;&amp;lt;1,2,3&amp;gt;&lt;/code&gt; is a
neighbor of &lt;code&gt;&amp;lt;1,3,4&amp;gt;&lt;/code&gt; once.&lt;/p&gt;
&lt;p&gt;So the question becomes: how do we count &lt;code&gt;&amp;lt;1,3,1&amp;gt;&lt;/code&gt; expanding
into &lt;code&gt;&amp;lt;1,3,0&amp;gt;&lt;/code&gt;? Well, normally, &lt;code&gt;&amp;lt;1,3,1&amp;gt;&lt;/code&gt; is a
neighbor of &lt;code&gt;&amp;lt;1,3,0&amp;gt;&lt;/code&gt; once. However, if we only keep the
normalized z values, &lt;code&gt;&amp;lt;1,3,1&amp;gt;&lt;/code&gt; is a neighbor of
&lt;code&gt;&amp;lt;1,3,0&amp;gt;&lt;/code&gt;…twice! To compute the total neighbor count of
&lt;code&gt;&amp;lt;1,3,0&amp;gt;&lt;/code&gt;, we have to count the contribution from
&lt;code&gt;&amp;lt;1,3,1&amp;gt;&lt;/code&gt; twice (once for &lt;code&gt;&amp;lt;1,3,1&amp;gt;&lt;/code&gt; and once
for &lt;code&gt;&amp;lt;1,3,-1&amp;gt;&lt;/code&gt;, which also exists, but was normalized
away).&lt;/p&gt;
&lt;p&gt;That means we have to follow the original rules, but &lt;em&gt;backwards&lt;/em&gt;,
like:&lt;/p&gt;
&lt;div id="golSyms3DReverse" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 4b:&lt;/strong&gt; 3D Reverse Neighbor Multiplicities&lt;/p&gt;
&lt;div id="golSyms3DReverseCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;These are the &lt;strong&gt;reverse neighbors&lt;/strong&gt;: how many times a given
point counts as a neighbor for its surrounding points. Here, mousing over z=1
shows that it counts as a neighbor for z=0 twice, from both the left and the
right. It also counts as a neighbor for z=2 once (from the left side).&lt;/p&gt;
&lt;p&gt;We can account for this by hard-coding the rules into our step algorithm: if
our z goes from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;, increment its value twice in
the neighbor map. Otherwise, simply increment by 1 as normal.&lt;/p&gt;
&lt;p&gt;This rule is relatively straightforward to implement, and as a result we now
halved our total number of points we need to keep and check for 3D! There’s also
a nice way to generalize to arbitrary dimensions: for every
&lt;code&gt;1 -&amp;gt; 0&lt;/code&gt; transition in a higher dimension, multiply by two. That
means we reduce the number of 4D points we need to track by a factor of four,
the number of 5D points by a factor of eight, the number of 6D points by a
factor of 16… now our total points to check only grows as &lt;span
class="math inline"&gt;\(O(n^d / 2^{d-2})\)&lt;/span&gt; instead of &lt;span
class="math inline"&gt;\(O(n^d)\)&lt;/span&gt;!&lt;/p&gt;
&lt;p&gt;Here is a python implementation of this generalization:&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb2-1"&gt;&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; axis_weight(source,target):&lt;/span&gt;
&lt;span id="cb2-2"&gt;&lt;a href="#cb2-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Retuns how many times the given source-&amp;gt;target transition should be&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-3"&gt;&lt;a href="#cb2-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    counted in target&amp;#39;s neighbor count&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-4"&gt;&lt;a href="#cb2-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-5"&gt;&lt;a href="#cb2-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# ignore x,y&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-6"&gt;&lt;a href="#cb2-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    higher_source &lt;span class="op"&gt;=&lt;/span&gt; source[&lt;span class="dv"&gt;2&lt;/span&gt;:]&lt;/span&gt;
&lt;span id="cb2-7"&gt;&lt;a href="#cb2-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    higher_target &lt;span class="op"&gt;=&lt;/span&gt; target[&lt;span class="dv"&gt;2&lt;/span&gt;:]&lt;/span&gt;
&lt;span id="cb2-8"&gt;&lt;a href="#cb2-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="bu"&gt;sum&lt;/span&gt;([&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="cf"&gt;for&lt;/span&gt; i,j &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;zip&lt;/span&gt;(higher_source, higher_target)&lt;/span&gt;
&lt;span id="cb2-9"&gt;&lt;a href="#cb2-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                      &lt;span class="cf"&gt;if&lt;/span&gt; i &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;and&lt;/span&gt; j &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-10"&gt;&lt;a href="#cb2-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                  ])&lt;/span&gt;
&lt;span id="cb2-11"&gt;&lt;a href="#cb2-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-12"&gt;&lt;a href="#cb2-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; mk_positive_neighbs(point):&lt;/span&gt;
&lt;span id="cb2-13"&gt;&lt;a href="#cb2-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;mk_neighbs, but only with positive higher dimensional points&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-14"&gt;&lt;a href="#cb2-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-15"&gt;&lt;a href="#cb2-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# this is a very wasteful implementation, for demonstrative purposes&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-16"&gt;&lt;a href="#cb2-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; [ngb &lt;span class="cf"&gt;for&lt;/span&gt; ngb &lt;span class="kw"&gt;in&lt;/span&gt; mk_neighbs(point) &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;all&lt;/span&gt; (i &lt;span class="op"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; ngb[&lt;span class="dv"&gt;2&lt;/span&gt;:])]&lt;/span&gt;
&lt;span id="cb2-17"&gt;&lt;a href="#cb2-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-18"&gt;&lt;a href="#cb2-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; step_axis(pts):&lt;/span&gt;
&lt;span id="cb2-19"&gt;&lt;a href="#cb2-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Takes a set of points (tuples) and steps them in the simulation&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-20"&gt;&lt;a href="#cb2-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    according to axis-reflection symmetry.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-21"&gt;&lt;a href="#cb2-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-22"&gt;&lt;a href="#cb2-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    neighbs &lt;span class="op"&gt;=&lt;/span&gt; Counter()&lt;/span&gt;
&lt;span id="cb2-23"&gt;&lt;a href="#cb2-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; point &lt;span class="kw"&gt;in&lt;/span&gt; pts:&lt;/span&gt;
&lt;span id="cb2-24"&gt;&lt;a href="#cb2-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        neighbs &lt;span class="op"&gt;+=&lt;/span&gt; Counter({ ngb: axis_weight(point,ngb)&lt;/span&gt;
&lt;span id="cb2-25"&gt;&lt;a href="#cb2-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                               &lt;span class="cf"&gt;for&lt;/span&gt; ngb &lt;span class="kw"&gt;in&lt;/span&gt; mk_positive_neighbs(point)[&lt;span class="dv"&gt;1&lt;/span&gt;:]&lt;/span&gt;
&lt;span id="cb2-26"&gt;&lt;a href="#cb2-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                           })&lt;/span&gt;
&lt;span id="cb2-27"&gt;&lt;a href="#cb2-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-28"&gt;&lt;a href="#cb2-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; validate(point, ncount):&lt;/span&gt;
&lt;span id="cb2-29"&gt;&lt;a href="#cb2-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; point &lt;span class="kw"&gt;in&lt;/span&gt; pts:&lt;/span&gt;
&lt;span id="cb2-30"&gt;&lt;a href="#cb2-30" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="kw"&gt;or&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-31"&gt;&lt;a href="#cb2-31" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb2-32"&gt;&lt;a href="#cb2-32" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-33"&gt;&lt;a href="#cb2-33" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-34"&gt;&lt;a href="#cb2-34" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;frozenset&lt;/span&gt;(p &lt;span class="cf"&gt;for&lt;/span&gt; p, n &lt;span class="kw"&gt;in&lt;/span&gt; neighbs.items() &lt;span class="cf"&gt;if&lt;/span&gt; validate(p, n))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This discovery late in the Tuesday night of the 16th was what inspired us to
believe and dream that more breakthroughs might be possible to bring things down
even further.&lt;/p&gt;
&lt;p&gt;Those breakthroughs soon came!&lt;/p&gt;
&lt;h2 id="four-dimensions"&gt;Four Dimensions&lt;/h2&gt;
&lt;p&gt;Let’s look at how 4D game works! We can visualize this by taking “z-w” slices
at different x-y planes. The labels in the following boxes are the
&lt;code&gt;&amp;lt;z,w&amp;gt;&lt;/code&gt; of each slice. The very center is
&lt;code&gt;&amp;lt;z,w&amp;gt; = &amp;lt;0,0&amp;gt;&lt;/code&gt; the row in the middle from the top is
&lt;code&gt;w=0&lt;/code&gt;, and the column in the very middle from the left is
&lt;code&gt;z=0&lt;/code&gt;. It’s basically taking the 3D visualization above and expanding
it in an extra dimension. Press “Play” to run your initial conditions!&lt;/p&gt;
&lt;div id="gol4D" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 5:&lt;/strong&gt; 4D Game of Life&lt;/p&gt;
&lt;div id="gol4DCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(Some patterns I recommend trying are the patterns with double reflection
symmetry like &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=▛▀▀▜.▌▛▜▐.▌▙▟▐.▙▄▄▟"
class="loadpoints"&gt;bulls-eye&lt;/a&gt;, &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=████.████.████.████"
class="loadpoints"&gt;full block&lt;/a&gt; and the twinkly &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=____._▞▖_._▝__.____"
class="loadpoints"&gt;tub&lt;/a&gt;, rotational symmetry like &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=██▟█.▜███.███▙.█▛██"
class="loadpoints"&gt;spiral galaxy&lt;/a&gt;, and single-reflection symmetries like &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=████.▄▗▖▄.▀▝▘▀.████"
class="loadpoints"&gt;broken bar code&lt;/a&gt;, which seems to alternate between
different orientations).&lt;/p&gt;
&lt;p&gt;Most initial conditions will spread out from the center
&lt;code&gt;&amp;lt;z,w&amp;gt; = &amp;lt;0,0&amp;gt;&lt;/code&gt; slice radially, spreading outwards into
positive and negative z and w. Mouse-over or tap any individual tiny
&lt;code&gt;&amp;lt;x,y&amp;gt;&lt;/code&gt; cell and you’ll see each of its 80 (&lt;span
class="math inline"&gt;\(3^4-1\)&lt;/span&gt;) &lt;code&gt;&amp;lt;x,y,z,w&amp;gt;&lt;/code&gt; 4D neighbors
highlighted in blue, forming a little 3x3x3x3 “&lt;a
href="https://en.wikipedia.org/wiki/Cosmic_Cube"&gt;tesseract&lt;/a&gt;” (4D cube, or
hypercube). Like in the 3D case, you can use this little hypercube to track how
the simulation progresses: if your mouse if hovering over a live cell with 2 or
3 live cells in its hypercube, it’ll stay alive in the next step, if it’s
hovering over a dead cell with 3 live cells in its hypercube, it’ll come alive
in the next step.&lt;/p&gt;
&lt;h3 id="diagonal-reflection-symmetry"&gt;Diagonal Reflection Symmetry&lt;/h3&gt;
&lt;p&gt;Play around and explore how simulations evolve! You will notice that the axis
reflection symmetry is still preserved, as expected, but four ways (the slice at
&lt;code&gt;&amp;lt;z,w&amp;gt; = &amp;lt;3,4&amp;gt;&lt;/code&gt; is always going to be identical to the
slice at &lt;code&gt;&amp;lt;-3,4&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;3,-4&amp;gt;&lt;/code&gt;, and
&lt;code&gt;&amp;lt;-3,-4&amp;gt;&lt;/code&gt;). These are reflected in the “deep yellow” highlights
above when you mouse over a zw square. (Ignore the lighter yellow highlights for
now!)&lt;/p&gt;
&lt;p&gt;And now, for the next big breakthrough: this exact visualization was what
reddit user u/cetttbycett was looking at when &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfjhwh/year_2020_day_17_part_2_using_symmetry_in_4d_space/"&gt;they
made this post&lt;/a&gt; late Thursday the 17th/early Friday the 18th…and everything
changed forever.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I noticed that the expansion of active cubes for part 2 is symmetric with
respect to two hyperplanes in 4d space: These hyperplanes can be described by w
= 0 and w-z = 0.&lt;/p&gt;
&lt;p&gt;Using these symmetries could make the code nearly eight times as fast.I was
wondering if anyone tried that.&lt;/p&gt;
&lt;p&gt;— u/cetttbycettt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What u/cetttbycettt saw is what you can see now in the simulation above: it’s
all of the &lt;em&gt;light yellow&lt;/em&gt; highlighted squares when you mouse-over
(highlighting even &lt;em&gt;more&lt;/em&gt; identical slices to the one you are hovering
over). In addition to the z=0 and w=0 lines (the two lines down the middle,
up-down and left-right), we also have another line of symmetry: z=w and z=-w,
the diagonal lines!&lt;/p&gt;
&lt;p&gt;That’s right, a zw slice at &lt;code&gt;&amp;lt;z,w&amp;gt;=&amp;lt;3,4&amp;gt;&lt;/code&gt; is
&lt;em&gt;identical&lt;/em&gt; to the one at &lt;code&gt;&amp;lt;4,3&amp;gt;&lt;/code&gt;, and so also
&lt;code&gt;&amp;lt;-3,4&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;3,-4&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;-3,-4&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;-4,3&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;4,-3&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;-4,-3&amp;gt;&lt;/code&gt;! Each slice is
potentially repeated &lt;em&gt;eight&lt;/em&gt; times! The exceptions are the points on the
lines of symmetry themselves, which are each repeated only four times, and also
&lt;code&gt;&amp;lt;z,w&amp;gt;=&amp;lt;0,0&amp;gt;&lt;/code&gt;, which is in a class of its own.&lt;/p&gt;
&lt;p&gt;So, our first breakthrough meant that we only have to simulate
&lt;em&gt;positive&lt;/em&gt; coordinates (a single quadrant)…our next breakthrough means
that we only have to simulate coordinates on a single “wedge” half-quadrant…and
then duplicate those eight times at the end. (Arbitrarily, let’s say we only
simulate the north-by-northeast wedge, because it’s easy to normalize/compact
all points onto that wedge — you just need to absolute-value all the components
and sort them, and a point like &lt;code&gt;&amp;lt;4,-3&amp;gt;&lt;/code&gt; gets “normalized” to
&lt;code&gt;&amp;lt;3,4&amp;gt;&lt;/code&gt;))&lt;/p&gt;
&lt;p&gt;We found a new symmetry now, but we run into the same issue as before: How do
we propagate neighbors? To help us see what’s going on, let’s look at the map of
neighbors between different &lt;code&gt;&amp;lt;z,w&amp;gt;&lt;/code&gt; squares, for the single zw
wedge we are simulating.&lt;/p&gt;
&lt;div id="golSyms4DForward" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 6a:&lt;/strong&gt; 4D Forward Neighbor Multiplicities&lt;/p&gt;
&lt;div id="golSyms4DForwardCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;These are the &lt;em&gt;forward neighbors&lt;/em&gt;; we can compute them by expanding a
point to its neighbors, and then normalizing our points and seeing how they
double (or quadruple) up.&lt;/p&gt;
&lt;p&gt;For example, mouse over &lt;code&gt;&amp;lt;z,w&amp;gt;=&amp;lt;3,3&amp;gt;&lt;/code&gt; and see it has
eight total higher-dimensional neighbors (like all points should, though this
visualization leaves out points at w&amp;gt;6). It’s &lt;em&gt;supposed&lt;/em&gt; to have a
neighbor at &lt;code&gt;&amp;lt;4,3&amp;gt;&lt;/code&gt;, but that gets reflected back onto
&lt;code&gt;&amp;lt;3,4&amp;gt;&lt;/code&gt; during our normalization process, so you see that the
point &lt;code&gt;&amp;lt;3,3&amp;gt;&lt;/code&gt; has a neighbor at &lt;code&gt;&amp;lt;3,4&amp;gt;&lt;/code&gt;
“double-counted”. The green squares (in the north and west positions) at
&lt;code&gt;&amp;lt;3,4&amp;gt;&lt;/code&gt; when you hover over &lt;code&gt;&amp;lt;3,3&amp;gt;&lt;/code&gt; show that
&lt;code&gt;&amp;lt;3,4&amp;gt;&lt;/code&gt; is a neighbor of &lt;code&gt;&amp;lt;3,3&amp;gt;&lt;/code&gt; both to its
north and to its west.&lt;/p&gt;
&lt;p&gt;Also, we have something really odd show up for the first time. Mouse over a
point like &lt;code&gt;&amp;lt;z,w&amp;gt;=&amp;lt;2,3&amp;gt;&lt;/code&gt; and see that it has a neighbor
in…itself? What’s going on here? Well, it is &lt;em&gt;supposed&lt;/em&gt; to have a
neighbor at &lt;code&gt;&amp;lt;3,2&amp;gt;&lt;/code&gt; but that gets normalized/reflected back
onto &lt;code&gt;&amp;lt;2,3&amp;gt;&lt;/code&gt; — it reflects onto itself! The green square in the
Southeast means that &lt;code&gt;&amp;lt;2,3&amp;gt;&lt;/code&gt;’s southeast neighbor
is…itself!&lt;/p&gt;
&lt;p&gt;Here is a sample python implementation of the computation of forward neighbor
multiplicities for any dimension by propagating-then-normalizing:&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb3-1"&gt;&lt;a href="#cb3-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; normalize(point):&lt;/span&gt;
&lt;span id="cb3-2"&gt;&lt;a href="#cb3-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Normalize a point by sorting the absolute values&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-3"&gt;&lt;a href="#cb3-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-4"&gt;&lt;a href="#cb3-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    (2, -1)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-5"&gt;&lt;a href="#cb3-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    =&amp;gt; (1, 2)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-6"&gt;&lt;a href="#cb3-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-7"&gt;&lt;a href="#cb3-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(&lt;span class="bu"&gt;sorted&lt;/span&gt;([&lt;span class="bu"&gt;abs&lt;/span&gt;(x) &lt;span class="cf"&gt;for&lt;/span&gt; x &lt;span class="kw"&gt;in&lt;/span&gt; point]))&lt;/span&gt;
&lt;span id="cb3-8"&gt;&lt;a href="#cb3-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-9"&gt;&lt;a href="#cb3-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; forward_neighbs(point):&lt;/span&gt;
&lt;span id="cb3-10"&gt;&lt;a href="#cb3-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Generate the higher-dimensional forward neighbors of a point&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-11"&gt;&lt;a href="#cb3-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-12"&gt;&lt;a href="#cb3-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    (0, 1)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-13"&gt;&lt;a href="#cb3-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    =&amp;gt; {(0, 1): 2, (1, 2): 2, (1, 1): 2, (0, 0): 1, (0, 2): 1}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-14"&gt;&lt;a href="#cb3-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-15"&gt;&lt;a href="#cb3-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; Counter([normalize(neighb) &lt;span class="cf"&gt;for&lt;/span&gt; neighb &lt;span class="kw"&gt;in&lt;/span&gt; mk_neighbs(point)[&lt;span class="dv"&gt;1&lt;/span&gt;:]])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The forward neighbors are useful for understanding what’s going on, but to
actually run our simulation we again need to find the &lt;em&gt;reverse
neighbors&lt;/em&gt;: from a given point A, how many times is that point a neighbor of
another point B?&lt;/p&gt;
&lt;p&gt;We can compute this in brute-force using a cache: iterate over each point,
expand all its neighbors &lt;span class="math inline"&gt;\(a_i\)&lt;/span&gt;, normalize
that neighbor, and then set &lt;span class="math inline"&gt;\(a_i\)&lt;/span&gt; in the
cache to the multiplicity after normalization.&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb4-1"&gt;&lt;a href="#cb4-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; reverse_neighbs_table(t_max):&lt;/span&gt;
&lt;span id="cb4-2"&gt;&lt;a href="#cb4-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Tabulate the reverse neighbors of all zw slices reachable before t_max&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-3"&gt;&lt;a href="#cb4-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-4"&gt;&lt;a href="#cb4-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    weights &lt;span class="op"&gt;=&lt;/span&gt; {}&lt;/span&gt;
&lt;span id="cb4-5"&gt;&lt;a href="#cb4-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb4-6"&gt;&lt;a href="#cb4-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(t_max):&lt;/span&gt;
&lt;span id="cb4-7"&gt;&lt;a href="#cb4-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;for&lt;/span&gt; j &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(i, t_max):&lt;/span&gt;
&lt;span id="cb4-8"&gt;&lt;a href="#cb4-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;for&lt;/span&gt; neighb, ncount &lt;span class="kw"&gt;in&lt;/span&gt; forward_neighbs((i, j)).items():&lt;/span&gt;
&lt;span id="cb4-9"&gt;&lt;a href="#cb4-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                &lt;span class="cf"&gt;if&lt;/span&gt; neighb &lt;span class="kw"&gt;in&lt;/span&gt; weights:&lt;/span&gt;
&lt;span id="cb4-10"&gt;&lt;a href="#cb4-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    weights[neighb][(i, j)] &lt;span class="op"&gt;=&lt;/span&gt; ncount&lt;/span&gt;
&lt;span id="cb4-11"&gt;&lt;a href="#cb4-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb4-12"&gt;&lt;a href="#cb4-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    weights[neighb] &lt;span class="op"&gt;=&lt;/span&gt; {(i, j): ncount}&lt;/span&gt;
&lt;span id="cb4-13"&gt;&lt;a href="#cb4-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb4-14"&gt;&lt;a href="#cb4-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; weights&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This seems pretty expensive and wasteful, so we’d like to maybe find a
formula to be able to do this using mathematical operations. So, let’s
explore!&lt;/p&gt;
&lt;div id="golSyms4DReverse" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 6b:&lt;/strong&gt; 4D Reverse Neighbor Multiplicities&lt;/p&gt;
&lt;div id="golSyms4DReverseCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;These are the reverse neighbors, and it follows the same rules for the &lt;a
href="#golSyms3DReverse"&gt;3D Reverse Neighbors&lt;/a&gt;: mouse over a point and you’ll
see how many times it appears as a neighbor to its nearby points. The green
square represents the direction that it sees the hovered point as a neighbor.
It’s the flipped version of the &lt;a href="#golSyms4DForward"&gt;4D Forward
Neighbors&lt;/a&gt; above.&lt;/p&gt;
&lt;p&gt;After exploring this interactively, we can maybe think of some rules we can
apply.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;If we have a point &lt;code&gt;&amp;lt;z,z&amp;gt;&lt;/code&gt; directly on the z=w diagonal,
just use its five normal left/up neighbors with weight 1 each.&lt;/li&gt;
&lt;li&gt;If we have a point &lt;code&gt;&amp;lt;z,z+1&amp;gt;&lt;/code&gt; on the “inner-er” diagonal,
use its five normal left/up neighbors with weight 1, but its south and west
neighbors have weight 2, and the point reflects onto &lt;em&gt;itself&lt;/em&gt; with weight
1.&lt;/li&gt;
&lt;li&gt;If we’re on &lt;code&gt;z=1&lt;/code&gt; and we move into &lt;code&gt;z=0&lt;/code&gt;, double that
count (phew, the same rule as in the 3D case earlier)&lt;/li&gt;
&lt;li&gt;If we’re on w=1 and we move into w=0, double that count (same as
before)&lt;/li&gt;
&lt;li&gt;And…I guess &lt;code&gt;&amp;lt;0,1&amp;gt;&lt;/code&gt; reflects onto itself &lt;em&gt;twice&lt;/em&gt;? I
guess that technically falls under a combination of rule 2 and rule 4, but we
don’t directly observe the motion into w=0 before it gets reflected so it has to
be special-cased.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Okay, those rules are &lt;em&gt;sliiightly&lt;/em&gt; more complicated than our 3D rules
(“if we go from z=1 to z=0, double-count it”)…but they’re at least mechanical
enough to code in, even if not beautiful. You can probably foresee that it might
be tough to generalize, but…we’ll tackle that when we get there :)&lt;/p&gt;
&lt;p&gt;For now, we have a super-fast implementation of 4D GoL with our special
degeneracy! The runtime gets reduced by a factor of 8!&lt;/p&gt;
&lt;p&gt;For clarity, here’s an example implementation of how we can do this
higher-dimensional wrangling:&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb5-1"&gt;&lt;a href="#cb5-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; reverse_neighbs(point):&lt;/span&gt;
&lt;span id="cb5-2"&gt;&lt;a href="#cb5-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Return normalized higher-dimensional points, with their reverse&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-3"&gt;&lt;a href="#cb5-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    multiplicities&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-4"&gt;&lt;a href="#cb5-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-5"&gt;&lt;a href="#cb5-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    (0, 1)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-6"&gt;&lt;a href="#cb5-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    =&amp;gt; {(0, 0): 4, (0, 1): 2, (1, 1): 2, (0, 2): 1, (1, 2): 1}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-7"&gt;&lt;a href="#cb5-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-8"&gt;&lt;a href="#cb5-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# implementation elided&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-9"&gt;&lt;a href="#cb5-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;# one possibility is to lookup into reverse_neighbs_table(t_max)[point]&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-10"&gt;&lt;a href="#cb5-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; {}&lt;/span&gt;
&lt;span id="cb5-11"&gt;&lt;a href="#cb5-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-12"&gt;&lt;a href="#cb5-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; step_with_weights(pts):&lt;/span&gt;
&lt;span id="cb5-13"&gt;&lt;a href="#cb5-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    neighbs &lt;span class="op"&gt;=&lt;/span&gt; Counter()&lt;/span&gt;
&lt;span id="cb5-14"&gt;&lt;a href="#cb5-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; point &lt;span class="kw"&gt;in&lt;/span&gt; pts:&lt;/span&gt;
&lt;span id="cb5-15"&gt;&lt;a href="#cb5-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# 2d component, &amp;lt;x,y&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-16"&gt;&lt;a href="#cb5-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        pt_2d &lt;span class="op"&gt;=&lt;/span&gt; point[:&lt;span class="dv"&gt;2&lt;/span&gt;]&lt;/span&gt;
&lt;span id="cb5-17"&gt;&lt;a href="#cb5-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# higher-dimension components, &amp;lt;z,w,...&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-18"&gt;&lt;a href="#cb5-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        pt_nd &lt;span class="op"&gt;=&lt;/span&gt; point[&lt;span class="dv"&gt;2&lt;/span&gt;:]&lt;/span&gt;
&lt;span id="cb5-19"&gt;&lt;a href="#cb5-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-20"&gt;&lt;a href="#cb5-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# insert neighbors in the same 2d slice, not including itself&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-21"&gt;&lt;a href="#cb5-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        neighbs &lt;span class="op"&gt;+=&lt;/span&gt; Counter([ngb &lt;span class="op"&gt;+&lt;/span&gt; pt_nd &lt;span class="cf"&gt;for&lt;/span&gt; ngb &lt;span class="kw"&gt;in&lt;/span&gt; mk_neighbs(pt_2d)[&lt;span class="dv"&gt;1&lt;/span&gt;:]])&lt;/span&gt;
&lt;span id="cb5-22"&gt;&lt;a href="#cb5-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# insert neighbors in the neighboring 2d slices&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-23"&gt;&lt;a href="#cb5-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        neighbs &lt;span class="op"&gt;+=&lt;/span&gt; Counter({(ngb_2 &lt;span class="op"&gt;+&lt;/span&gt; ngb_n): wt&lt;/span&gt;
&lt;span id="cb5-24"&gt;&lt;a href="#cb5-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                                &lt;span class="cf"&gt;for&lt;/span&gt; ngb_n, wt &lt;span class="kw"&gt;in&lt;/span&gt; reverse_neighbs(pt_nd)&lt;/span&gt;
&lt;span id="cb5-25"&gt;&lt;a href="#cb5-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                                &lt;span class="cf"&gt;for&lt;/span&gt; ngb_2 &lt;span class="kw"&gt;in&lt;/span&gt; mk_neighbs(pt_2d)&lt;/span&gt;
&lt;span id="cb5-26"&gt;&lt;a href="#cb5-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                          })&lt;/span&gt;
&lt;span id="cb5-27"&gt;&lt;a href="#cb5-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-28"&gt;&lt;a href="#cb5-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; validate(point, ncount):&lt;/span&gt;
&lt;span id="cb5-29"&gt;&lt;a href="#cb5-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; point &lt;span class="kw"&gt;in&lt;/span&gt; pts:&lt;/span&gt;
&lt;span id="cb5-30"&gt;&lt;a href="#cb5-30" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="kw"&gt;or&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-31"&gt;&lt;a href="#cb5-31" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb5-32"&gt;&lt;a href="#cb5-32" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-33"&gt;&lt;a href="#cb5-33" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-34"&gt;&lt;a href="#cb5-34" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;frozenset&lt;/span&gt;(p &lt;span class="cf"&gt;for&lt;/span&gt; p, n &lt;span class="kw"&gt;in&lt;/span&gt; neighbs.items() &lt;span class="cf"&gt;if&lt;/span&gt; validate(p, n))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, onward to 5D!&lt;/p&gt;
&lt;h2 id="breaking-through"&gt;Breaking Through&lt;/h2&gt;
&lt;p&gt;By stepping into 5D, we’ve moved into a brand new territory — we’re now past
what the original question was asking about, and into simply exploring a
personal curiosity for fun. No longer are we “super-optimizing” the puzzle —
we’re now warping the original challenge to levels it was never designed to
handle.&lt;/p&gt;
&lt;p&gt;It’s difficult to visualize how things look in 5 dimensions, so this is where
it gets a little tricky to make any progress, mentally. The first thing we need
to figure out is how exactly we can generalize the “z=w” symmetry from 4D to be
able to take advantage of it in 5D…and hopefully in a way that can generalize to
arbitrary dimensions. Along the way we’d also like to get rid of our hacky 4D
neighbor multiplicity rules and get something a little cleaner.&lt;/p&gt;
&lt;p&gt;I struggled with for a while without making too much headway…but on the
morning of Friday, December 18th, arguably the biggest revelation of the entire
journey was dropped by Michal Marsalek on u/cetttbycettt’s reddit thread. It was
a big deal, because not only did it allow us to generalize our symmetries to
higher dimensions, but it also &lt;em&gt;proved&lt;/em&gt; a specific degeneracy that
allowed 10D simulation to be definitely 100% &lt;em&gt;solvable&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="permutation-symmetry"&gt;Permutation Symmetry&lt;/h3&gt;
&lt;p&gt;Here was Michal’s &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfjhwh/year_2020_day_17_part_2_using_symmetry_in_4d_space/gg9vr6m/"&gt;historic
post&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Yes, all the higher dimensions are interchangeable, there’s nothing that
distinquishes them. That is, if there’s an active cell at position (x,y,
a,b,c,d,e,f,g) then, there’s also one at (x,y, c,d,g,e,f,a) and at all other
permutations, of coordinates a-g). That is the number of cells that one need to
track can be reduced by factor of &lt;span class="math inline"&gt;\((d-2)! \times
2^{d-2}\)&lt;/span&gt; (at least if time goes to infinity).&lt;/p&gt;
&lt;p&gt;…we can use symmetries coming from permutations, to only track cells where
&lt;span class="math inline"&gt;\(0 \leq x_2 \leq x_3 \leq\,\ldots\, \leq x_{d-1} \leq
t\)&lt;/span&gt;. There’s &lt;span class="math inline"&gt;\(20^2 \times \sum_{k=0}^{t} {
{d-3+k} \choose {k} }\)&lt;/span&gt; such cells.&lt;/p&gt;
&lt;p&gt;— Michal Marsalek&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;(equations slightly modified)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;And boy was this exciting to read. First of all, it gave a way to generalize
the z=w symmetry: it’s just &lt;a
href="https://en.wikipedia.org/wiki/Permutation"&gt;permutation symmetry&lt;/a&gt; for
all higher-dimensional coordinates! But the big kicker here: See that last
formula? Let’s look at it more closely, using &lt;span
class="math inline"&gt;\(\hat{d}\)&lt;/span&gt; to represent &lt;span
class="math inline"&gt;\(d-2\)&lt;/span&gt;, the number of higher dimensions:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
20^2 \times \sum_{k=0}^{t} { {\hat{d}-1+k}\choose{k} }
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(That notation is the &lt;a
href="https://en.wikipedia.org/wiki/Binomial_coefficient"&gt;binomial
coefficient&lt;/a&gt;, if you aren’t familiar with it.) Note that the summation has a
&lt;em&gt;fixed number of terms&lt;/em&gt; (with respect to dimension); that means we only
ever have 6 terms to expand, no matter how high the dimensions are — at 10D and
even 100D! Furthermore, we can simplify the above using properties of binomial
coefficients to get&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[
20^2 \times { {\hat{d}+6}\choose{6} }
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This binomial coefficient is actually polynomial on &lt;span
class="math inline"&gt;\(\hat{d}\)&lt;/span&gt; — it’s &lt;span
class="math inline"&gt;\(\frac{1}{6!} \prod_{k=1}^6 (\hat{d}+k)\)&lt;/span&gt; — a sixth
degree polynomial (leading term &lt;span class="math inline"&gt;\(\frac{1}{6!}
\hat{d}^6\)&lt;/span&gt;), in fact. This means that we have turned the number of
points we potentially need to track from exponential (&lt;span
class="math inline"&gt;\(O(13^{\hat{d}})\)&lt;/span&gt;) to slightly smaller exponential
(&lt;span class="math inline"&gt;\(O(6^{\hat{d}})\)&lt;/span&gt;) to now &lt;em&gt;polynomial&lt;/em&gt;
(&lt;span class="math inline"&gt;\(O(\hat{d}^6)\)&lt;/span&gt;)!&lt;/p&gt;
&lt;p&gt;So, not only did we figure out a way to generalize/compute our symmetries, we
also now know that this method lets us keep our point set &lt;em&gt;polynomial&lt;/em&gt; on
the dimension, instead of exponential.&lt;/p&gt;
&lt;p&gt;To put a concrete number for context, for that dream of 10D, here are only
&lt;span class="math inline"&gt;\({ {8+6} \choose 6 }\)&lt;/span&gt;, or 3003 potential
unique &lt;code&gt;&amp;lt;z,w,...&amp;gt;&lt;/code&gt; points, once you factor out symmetries! The
number went down from &lt;span class="math inline"&gt;\(13^8\)&lt;/span&gt; (815,730,721)
potential unique &lt;code&gt;&amp;lt;z,w,...&amp;gt;&lt;/code&gt; points to &lt;span
class="math inline"&gt;\(6^8\)&lt;/span&gt; (1,679,616) potential unique points with
positive/negative symmetry to just 3003 with permutation symmetry.&lt;a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;
Furthermore, because of the blessing of dimensionality mentioned earlier, we can
expect more and more of those to be empty as we increase our dimensions.&lt;/p&gt;
&lt;p&gt;And in a flash, 10D didn’t feel like a dream anymore; it felt like an
inevitability. And now, it was just a race to see who could get there first.&lt;/p&gt;
&lt;h3 id="the-race-to-10d"&gt;The Race to 10D&lt;/h3&gt;
&lt;p&gt;Unfortunately, the exact record of who reached and posted 10D first is a bit
lost to history due to reddit’s editing records (not that “first” is necessarily
a meaningful title to hold; there’s no prize, and everyone is working at their
own pace). A few people maintained and updated their posts to prevent clutter,
but the record and time stamp of when they first posted 10D is lost. If any of
them happens to read this and can more accurately verify their times, I’d be
happy to update!&lt;/p&gt;
&lt;p&gt;For me, I’m sure I was not the first one, but in my chat logs I see that I
chimed into freenode’s &lt;code&gt;##adventofcode-spoilers&lt;/code&gt; channel in
excitement in the wee morning hours (PST) Saturday December 19th:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-12-19 02:32:42   jle`    | d=10 in 9m58s
2020-12-19 02:33:05   jle`    | hooray my goal :)
2020-12-19 02:33:08   jle`    | time to sleep now
2020-12-19 02:33:12   xerox_  | goodnight
2020-12-19 02:33:35   jle`    | xerox_: thanks :)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pure joy! :D&lt;/p&gt;
&lt;p&gt;&lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/ggaaqsy/"&gt;Peter
Tseng&lt;/a&gt; made a post on &lt;em&gt;Thursday&lt;/em&gt; night with times, but I can’t
remember if it incorporated all the symmetries or originally included 10D. &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/ggsx9e9/"&gt;Michal
Marsalek&lt;/a&gt; was able to implement the idea that he originally proposed by the
following Wednesday (December 23rd) in Nim to blow everyone’s time out of the
water: 3 seconds flat!&lt;/p&gt;
&lt;p&gt;At that point, it was pretty unbelievable to me that what started out as a
dream goal that we couldn’t have reasonably completed on a commercial PC had,
through successive revelations and insights building on each other one by one,
could now be done in 3 seconds.&lt;/p&gt;
&lt;p&gt;But hey, I promised 100ms in the introduction, and a way to reach 60D,
right?&lt;/p&gt;
&lt;p&gt;With our original goal completed, it was now time to dig in a little deeper
and see how far this baby could go.&lt;/p&gt;
&lt;h3 id="diving-deeper-terminology"&gt;Diving Deeper: Terminology&lt;/h3&gt;
&lt;p&gt;Before we go any further, let’s take a break to clarify and introduce some
terminology we’ll be using for the rest of this post.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I’ve been using the word &lt;strong&gt;slice&lt;/strong&gt; to talk about a 2D grid
representing a single higher-dimensional &lt;code&gt;&amp;lt;z,w...&amp;gt;&lt;/code&gt; coordinate
— they’re the 13 grids in &lt;a href="#gol3D"&gt;the 3D simulation&lt;/a&gt; and the 169
grids in &lt;a href="#gol4D"&gt;the 4D simulation&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’ve also been using &lt;strong&gt;cell&lt;/strong&gt; to refer to an exact specific
&lt;code&gt;&amp;lt;x,y,z,w,..&amp;gt;&lt;/code&gt; spot — they are the tiny squares inside each
grid in the simulations above.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’ll start using the word &lt;strong&gt;&lt;a
href="https://www.youtube.com/watch?v=Dp8sYTlLQRY"&gt;coset&lt;/a&gt;&lt;/strong&gt; to refer
the set of all of the duplicates of an &lt;code&gt;&amp;lt;x,y&amp;gt;&lt;/code&gt; across all
permutations and negations of &lt;code&gt;&amp;lt;z,w,q,..&amp;gt;&lt;/code&gt;, since they all
behave the same (they are either all on or all off together). So
&lt;code&gt;&amp;lt;x,y,1,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;x,y,2,1&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;x,y,-1,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;x,y,1,-2&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;x,y,-1,-2&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;x,y,-2,1&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;x,y,2,-1&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;x,y,-2,-1&amp;gt;&lt;/code&gt; are all a part
of the same coset, represented by the normalized form
&lt;code&gt;&amp;lt;x,y,1,2&amp;gt;&lt;/code&gt;. Now, during our simulation, we only need to
simulate one member from each coset, because every member is identically present
or not present. For the sake of implementation, we simulate the arbitrary
&lt;em&gt;normalized&lt;/em&gt; (positive and sorted) member only. Because of this, we’ll
sometimes refer to the normalized item and the coset it represents as the same
thing.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’ll also start using &lt;strong&gt;slice coset&lt;/strong&gt; to talk about the set
of all &lt;code&gt;&amp;lt;z,w,...&amp;gt;&lt;/code&gt; slices) across its permutations and
negations. The slices at z-w coordinates of &lt;code&gt;&amp;lt;1,2&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;2,1&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;-1,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;1,-2&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;-1,-2&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;-2,1&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;2,-1&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;-2,-1&amp;gt;&lt;/code&gt; are all a part of the
same slice coset, represented by the normalized form &lt;code&gt;&amp;lt;1,2&amp;gt;&lt;/code&gt;.
All of the slices at each of those zw coordinates will always be identical, so
we can talk the state of a single slice at &lt;code&gt;&amp;lt;1,2&amp;gt;&lt;/code&gt; as
representing the state of its entire coset.&lt;/p&gt;
&lt;p&gt;Slice cosets are what are being highlighted on mouseovers for the &lt;a
href="#gol3D"&gt;3D&lt;/a&gt; and &lt;a href="#gol4D"&gt;4D simulations&lt;/a&gt;. They are also what
the big squares represent for the &lt;a href="#golSyms3DForward"&gt;3D Forward
Neighbors&lt;/a&gt;, the &lt;a href="#golSyms3DReverse"&gt;3D Reverse Neighbors&lt;/a&gt;, the &lt;a
href="#golSyms4DForward"&gt;4D Reverse Neighbors&lt;/a&gt;, and the &lt;a
href="#golSyms4DReverse"&gt;4D Reverse neighbors&lt;/a&gt; elements: each slice stands in
for their entire slice coset, and we show the amount of times each normalized
slice coset element is a neighbor of the other.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tackling-the-neighbor-problem"&gt;Tackling the Neighbor Problem&lt;/h2&gt;
&lt;p&gt;My initial d=10 time clocked in at just under 10 minutes initially, but as
early as next Wednesday we knew that a sub-5 second time was possible. So where
was the gap?&lt;/p&gt;
&lt;p&gt;Well, I didn’t really know what to do about the neighbor multiplicity
problem. I was still brute-forcing by way of forward neighbors + normalizing (as
in the sample 4D python code snippet earlier). The naive brute-force method
requires computing &lt;em&gt;all&lt;/em&gt; &lt;span class="math inline"&gt;\(3^{ {\hat{d}} } -
1\)&lt;/span&gt; higher-dimensional neighbors. So, even though the number of points
I’d have to track grows polynomially, I still had that pesky exponential factor
in building my neighbor cache. At high dimensions, that exponential factor
dominates over everything.&lt;/p&gt;
&lt;p&gt;So put on your hard hats and working boots … we’re going to dive deep into
the world of hyper-dimensional symmetries!&lt;/p&gt;
&lt;h3 id="five-dimensions"&gt;Five Dimensions&lt;/h3&gt;
&lt;p&gt;First, let’s start visualizing how things look like in 5 dimensions, now that
we know what our slice coset/representative structure looks like. Partially to
help us gain an intuition for some of what’s going on, and also partially to
show that intuition at the individual component level can only get so far.&lt;/p&gt;
&lt;p&gt;It’s a bit difficult to duplicate the same &lt;a
href="#golSyms4DForward"&gt;forward neighbor&lt;/a&gt;/&lt;a
href="#golSyms4DReverse"&gt;reverse neighbor&lt;/a&gt; interactive elements as we had for
4D, so here’s a different representation. Here is an interactive element of all
of the &lt;code&gt;&amp;lt;z,w,q&amp;gt;&lt;/code&gt; slice cosets (the wedge of normalized points
we track for our implementation) and both their forward and reverse neighbor
weights of each other (computable using the method we used for 4D). The
&lt;code&gt;q&lt;/code&gt; axis is represented as stacked zw sections from left to
right.&lt;/p&gt;
&lt;div id="golSyms5D" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 7:&lt;/strong&gt; 5D Neighbor Multiplicities&lt;/p&gt;
&lt;div id="golSyms5DCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;As you mouse-over a slice coset representative (a single square), all of its
neighbors will be highlighted, including reflections. The red dot on the left is
the forward neighbor multiplicity (how many times that other slice is a neighbor
of the hovered slice) and the blue dot on the left is the reverse neighbor
multiplicity (how many times the hovered slice is a neighbor of the other
slice). For example, if you hover over &lt;code&gt;&amp;lt;z,w,q&amp;gt;=&amp;lt;1,3,4&amp;gt;&lt;/code&gt;,
you can see that &lt;code&gt;&amp;lt;0,3,4&amp;gt;&lt;/code&gt; is its neighbor twice, and
&lt;code&gt;&amp;lt;1,3,4&amp;gt;&lt;/code&gt; is &lt;code&gt;&amp;lt;0,3,4&amp;gt;&lt;/code&gt;’s neighbor four times.
These four times come from the normalized reflections of
&lt;code&gt;&amp;lt;1,3,4&amp;gt;&lt;/code&gt; at &lt;code&gt;&amp;lt;1,3,4&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;1,4,3&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;-1,3,4&amp;gt;&lt;/code&gt;, and
&lt;code&gt;&amp;lt;-1,4,3&amp;gt;&lt;/code&gt;. Some squares are also neighbors to themselves (like
&lt;code&gt;&amp;lt;1,4,5&amp;gt;&lt;/code&gt;, which reflects off of the top edge at
&lt;code&gt;&amp;lt;1,5,4&amp;gt;&lt;/code&gt;) and some are not (like &lt;code&gt;&amp;lt;1,3,5&amp;gt;&lt;/code&gt;).
&lt;a href="https://www.youtube.com/watch?v=rSfebOXSBOE"&gt;Mind bottling&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;At least one pattern we can see clearly is that if you are at a point where
each component is 4 or lower (so it doesn’t run off the edge of our table), the
sum of all its neighbors’ red dots (the forward neighbors) is &lt;span
class="math inline"&gt;\(3^3-1\)&lt;/span&gt; = 26, just like how the sum of forward
neighbors for interior points in 3D is &lt;span
class="math inline"&gt;\(3^2-1\)&lt;/span&gt; = 8, and for 2D is &lt;span
class="math inline"&gt;\(3^1-1\)&lt;/span&gt; = 2.&lt;/p&gt;
&lt;p&gt;Another very important pattern is that “is a neighbor” seems to be
reversible: the set of all &lt;em&gt;forward&lt;/em&gt; neighbors of a point is the same as
all &lt;em&gt;reverse&lt;/em&gt; neighbors of a point — the only difference is the
multiplicities. That is, wherever you see a red dot, you will also always see a
blue dot. No single-dot squares.&lt;/p&gt;
&lt;p&gt;Anyway, you can explore this a little bit and try to come up with a set of
ad-hoc rules like we did for 4D, but I think we’ve reached the limits of how far
that method can go. We can generate these values simply enough using the
expand-normalize-tabulate method we did for 4D, but it’s pretty inefficient, and
there should be a way to compute these weights &lt;em&gt;directly&lt;/em&gt; in a clean
fashion that doesn’t require hard-coding special cases and patterns. It’s clear
that we are limited until we can find this method.&lt;/p&gt;
&lt;h3 id="go-with-the-flow"&gt;Go with the Flow&lt;/h3&gt;
&lt;p&gt;What do all our valid normalized &lt;code&gt;&amp;lt;z,w,...&amp;gt;&lt;/code&gt; coordinates
look like? Well, they are always non-decreasing, and always are less than or
equal to the current timestep. Keeping t=6 as our goal still, this means that
valid coordinates in 10D are strings of eight numbers, like
&lt;code&gt;0,1,1,1,3,5,5,6&lt;/code&gt;, or &lt;code&gt;0,0,3,4,4,4,6,6&lt;/code&gt;, or
&lt;code&gt;1,1,2,3,3,4,5,5&lt;/code&gt;.&lt;a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We run into problems working with this format, though. For example, if we’re
computing a neighbor of &lt;code&gt;0,1,1,1,3,5,5,6&lt;/code&gt;, we can imagine that the
very first &lt;code&gt;1&lt;/code&gt; (the w coordinate) could move to be a &lt;code&gt;2&lt;/code&gt;,
resulting in &lt;code&gt;0,2,1,1,3,5,5,6&lt;/code&gt;. However, we’re now in
&lt;em&gt;un-normalized&lt;/em&gt; territory…we have to re-sort it to turn it into
&lt;code&gt;0,1,1,2,3,5,5,6&lt;/code&gt;. This encoding isn’t something we can directly
manipulate in a nice way.&lt;/p&gt;
&lt;p&gt;Because we don’t care about order, what if we instead encoded each
higher-dimensional coordinate as “count of each value seen?” For example, we can
encode &lt;code&gt;0,1,1,1,3,5,5,6&lt;/code&gt; as &lt;code&gt;1-3-0-1-0-2-1&lt;/code&gt;: the first
slot represents how many 0s we have, the second how many 1s, the next how many
2s, the next how many 3s, etc. We can encode &lt;code&gt;0,0,3,4,4,4,6,6&lt;/code&gt; as
&lt;code&gt;2-0-0-1-3-0-2&lt;/code&gt; and &lt;code&gt;1,1,2,3,3,4,5,5&lt;/code&gt; as
&lt;code&gt;0-2-1-2-1-2-0&lt;/code&gt;. The &lt;em&gt;sum&lt;/em&gt; of the components gives you the
total number of higher dimensions (ie, 10D vectors sum to 8)&lt;/p&gt;
&lt;p&gt;And now, a “valid transition” becomes easy to enforce: it’s an amount
“flowing” from one of those bins to another. For example, turning a
&lt;code&gt;1&lt;/code&gt; into a &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;1-3-0-1-0-2-1&lt;/code&gt; turns it into
&lt;code&gt;1-2-1-1-0-2-1&lt;/code&gt;. We took one of the three 1s and turned them into a
single 2. This “flowing” operation automatically gives us a valid coordinate
without any re-normalizing necessary!&lt;/p&gt;
&lt;p&gt;In this light, we now have an algorithm to compute neighbors without
requiring re-normalization: we can walk bin-to-bin, “flowing” components from
our origin vector to our new vector. We no longer have to try all &lt;span
class="math inline"&gt;\(3^d-1\)&lt;/span&gt; (exponential) candidates and re-normalize:
we can now only iterate through the ones we care about.&lt;/p&gt;
&lt;p&gt;The tricky math is now in computing the multiplicities. Interestingly enough,
in this case, the &lt;em&gt;reverse&lt;/em&gt; direction is actually easier to conceptualize
than the forward direction. Good for us, because that’s the direction we
actually need!&lt;/p&gt;
&lt;p&gt;Let’s imagine we start at &lt;code&gt;0-2-1-3-0&lt;/code&gt; (&lt;code&gt;1,1,2,3,3,3&lt;/code&gt;)
and “flow” to &lt;code&gt;0-0-5-0-0&lt;/code&gt; (&lt;code&gt;2,2,2,2,2&lt;/code&gt;) by dumping all our
bins into 2. How many ways could this flow happen? The answer happens to be the
&lt;a href="https://en.wikipedia.org/wiki/Multinomial_theorem"&gt;multinomial
coefficient&lt;/a&gt; &lt;span class="math inline"&gt;\(5 \choose
{2,1,3}\)&lt;/span&gt; (or &lt;span class="math inline"&gt;\(5! / (2!\,1!\,3!)\)&lt;/span&gt;):
there are 5! ways to end up with 5 in the bin, but that &lt;code&gt;5&lt;/code&gt; came from
contributions of &lt;code&gt;2+1+3&lt;/code&gt; from either side, and so we divide by the
ways we could pick from those contributing bins (2!, 1!, and 3!).&lt;/p&gt;
&lt;p&gt;Finally, we have to treat multiplicities for transitions from 0 to 1 slightly
differently, because they can arise either a 0 to 1 transition or a 0 to -1
transition. This comes out to a multiplication of &lt;span
class="math inline"&gt;\(2^n\)&lt;/span&gt; at the end (n being the amount of 0-to-1
flow). Because of this special care, it’s actually more convenient to fill in
bin-by-bin “backwards”, from the 6 slot to the 5 slot to the 4 slot, etc.,
because your options at the 0 component are already pre-determined for you by
the choices you have already made. It keeps the tree a more manageable
shape.&lt;/p&gt;
&lt;p&gt;Alright, enough words, let’s look at this in action! The following element
shows the &lt;em&gt;tree&lt;/em&gt; describing all the ways you can flow from bin to bin. As
an example, let’s look the 6D case of ways each point is a neighbor of
&lt;code&gt;0,2,2,3&lt;/code&gt; (&lt;code&gt;1-0-2-1&lt;/code&gt;), which you can pick from the
drop-down.&lt;/p&gt;
&lt;div id="golTree" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 8:&lt;/strong&gt; General Neighbor Multiplicity Algorithm&lt;/p&gt;
&lt;div id="golTreeCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;As you can see, each “branch” in the tree (reading from left to right) is a
different way to fill in a given bin, from right to left. At each node, the
displayed upper vector is the “source” vector, and the lower vector is the
“target” vector we build bin-by-bin. Bin-by-bin, we begin to move components
from our source vector into our target vector. The branches in the tree reflects
different ways we can commit a bin in our target vector. For example, at the
very first split, we can either pick our final vector to be
&lt;code&gt;?-?-?-?-0&lt;/code&gt; (leaving that 3 bin alone) or &lt;code&gt;?-?-?-?-1&lt;/code&gt;
(swiping a component from that 3 bin in the source vector). The operation shown
to the right of the node represents how we modify our weights according to the
choices we make according to the logic above. The nodes on the far right also
show the end products: the actual neighbors, along with their
multiplicities.&lt;/p&gt;
&lt;p&gt;If you mouse-over or tap a node, it’ll highlight the trace from the beginning
to the node you are highlighting, so you can see all of the choices made, as
well as all the operations applied to our running multiplicity counter at each
step. It’ll also show the contributions from the left, center, and right of the
current bin being picked (the &lt;span class="math inline"&gt;\(2+1+3\)&lt;/span&gt; in the
example above), and also the “regular” vector representation. For example,
&lt;code&gt;&amp;lt;[2,2],2,4&amp;gt;&lt;/code&gt; means that that node has already committed to
having &lt;code&gt;&amp;lt;?,?,2,4&amp;gt;&lt;/code&gt; in the target vector, but still has two 2s
in the source vector to pull in and distribute.&lt;/p&gt;
&lt;p&gt;One final thing we need to keep track of is to not count a point
transitioning to itself if it results from no actual internal changes (this is
the “minus one” in &lt;span class="math inline"&gt;\(3^d-1\)&lt;/span&gt;: we should not
include the single original point itself, but we &lt;em&gt;should&lt;/em&gt; count extra
occurrences of the original point if it arose from a reflection). This can be
done by checking if each of our bin choices involved exactly no inter-bin flows
(they were all of the form &lt;code&gt;0+x+0&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Phew! That’s a bit of a mathematical doozy, huh? But trust me when I say it’s
easier to understand if play around with the interactive element and follow
along the traces. After a few examples in different dimensions, it might start
to make sense. Try looking at the lower dimensions too to see if they match up
with what we figured out before.&lt;/p&gt;
&lt;p&gt;You can also flip the switch on the element to compute reverse and forward
neighbors. Luckily, as we noted before, if a point is a forward neighbor, it is
also a reverse neighbor. This means that the branching structure for forward and
reverse neighbor trees are exactly the same; the only difference is how the
multiplicities are calculated. In this case, the forward direction is just the
original calculation “reversed”! The diagram shows how the multiplicities are
accumulated; feel free to try to work out exactly how this works as a fun
exercise :)&lt;/p&gt;
&lt;p&gt;And with that, we have tackled the reverse neighbor weights problem with some
branching bin flows and combinatorics!&lt;/p&gt;
&lt;h2 id="stacks-on-stacks-visualizing-arbitrary-dimensions"&gt;Stacks On Stacks:
Visualizing Arbitrary Dimensions&lt;/h2&gt;
&lt;p&gt;You might have noticed that ever since our 4D simulation, we haven’t had a
new visualization of simulation, despite now having higher dimensions in our
grasp. Why not?&lt;/p&gt;
&lt;p&gt;Well, there’s the question of &lt;em&gt;how&lt;/em&gt; you might even visualize this. You
can “zoom out” and take higher-dimensional slices of our 4D visualization and
repeat this ad nauseam, but that doesn’t really add anything or give any insight
as to what’s really going on.&lt;/p&gt;
&lt;p&gt;I believe that this is one of the things that caused us to all collectively
get “stuck” together around 20 dimensions. The rush of the revelations one after
within a single week pushed us into trying many different things. I had a couple
of dead-end forays into pre-cacheing and had a lot of code (that I was ecstatic
to be able to later delete) working with an sqlite3 database.&lt;a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Another factor that probably contributed to the overall lull was that Advent
of Code was still running, and we all still enjoyed doing the new puzzles every
day. But soon, Christmas passed, the daily rush of doing new puzzles faded, and
we started to return back to tinkering on this hyper-dimensional game of life
puzzle. It wouldn’t be until January 1st, 2021 (just over two weeks after the
puzzle originally came out) that a new revelation arose that would pave the way
shoot far past 20D.&lt;/p&gt;
&lt;p&gt;It was &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/ghre3ce/"&gt;Michal
Marsalek’s coset counts post&lt;/a&gt; that set the stage. From the beginning, he had
always tracked the number of cell cosets at the end of the simulation (the
number of active “normalized” cells), and had been exploring the relationship
between dimension and coset counts. The discovery was that after a certain
“saturation point” (6D for Michal’s set, 9D for Peter’s set, 7D for my set), all
of the coset counts were &lt;em&gt;perfectly quadratic&lt;/em&gt;! For mine, it followed the
relationship &lt;span class="math inline"&gt;\(d^2 + 109d + 70\)&lt;/span&gt; exactly for 7D
and higher.&lt;/p&gt;
&lt;p&gt;My best guess as to why this was happening is that, at 7D and above, we enter
a domain of points where, before t=6, &lt;em&gt;every&lt;/em&gt; point is at some sort of
reflective boundary. Remember that even for 4D, we had really odd behavior at
the reflective boundaries/edge of the wedge. There wasn’t enough room for many
points to “stretch their wings” — every single one is at one reflective boundary
or another. Being a boundary point corresponds to having a “bins” encoding with
any bin greater than one or anything in the 0 bin (ie, &lt;code&gt;1-0-0-0&lt;/code&gt; and
&lt;code&gt;0-2-0&lt;/code&gt; are all points on a reflective boundary).&lt;/p&gt;
&lt;p&gt;Unfortunately, having a closed-form way to compute coset counts doesn’t
actually give us a way to compute the final state itself (that we know of, yet),
since it doesn’t tell us &lt;em&gt;which&lt;/em&gt; cosets are active, just how many.
However, this prompted me to investigate a little bit more about what was
causing this pattern and how these cosets were distributed. To do this, I tried
a new way to visualize things.&lt;/p&gt;
&lt;p&gt;In our simulation, x and y components are fundamentally different from the
others; we could actually talk about each point as a tuple
&lt;code&gt;(&amp;lt;x,y&amp;gt;, {higher dims})&lt;/code&gt;. Also, points are usually
&lt;em&gt;dense&lt;/em&gt; in &lt;code&gt;&amp;lt;x,y&amp;gt;&lt;/code&gt; (a significant fraction of the xy
space has at least one point), but &lt;em&gt;sparse&lt;/em&gt; in higher dimensions (a very
small fraction of the higher-dimensional space actually has a point in it).
Instead of keeping our active points as a set of cosets, we could treat it as a
map of &lt;code&gt;&amp;lt;x,y&amp;gt;&lt;/code&gt; points to the higher-dimension slice cosets that
live “under them”. That is, instead of keeping one giant set as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;lt;1,2,1,1,3&amp;gt;, &amp;lt;3,1,1,1,4&amp;gt;, &amp;lt;1,2,0,0,5&amp;gt;, &amp;lt;4,2,3,4,4&amp;gt;, &amp;lt;3,1,2,2,2&amp;gt;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we could instead keep a map of sets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;1,2&amp;gt;: { &amp;lt;1,1,3&amp;gt;, &amp;lt;0,0,5&amp;gt; }
&amp;lt;3,1&amp;gt;: { &amp;lt;1,1,4&amp;gt;, &amp;lt;2,2,2&amp;gt; }
&amp;lt;4,2&amp;gt;: { &amp;lt;3,3,4&amp;gt; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and propagate &lt;em&gt;that&lt;/em&gt; in our simulation. I like to call those sets
under each 2d point (ie, the &lt;code&gt;{&amp;lt;1,1,3&amp;gt;, &amp;lt;0,0,5&amp;gt;}&lt;/code&gt;) a
“coset stack”.&lt;/p&gt;
&lt;p&gt;I did this initially to investigate the nature of the cosets that were
showing up, but once I plotted it and animated things, I realized that in doing
this, we are reducing the entire hyper-dimensional problem &lt;em&gt;back to a variant
of 2D cellular automaton&lt;/em&gt;! This whole thing becomes reframed…instead of a
mind-bending hyper-dimensional deal, it’s now simply &lt;em&gt;multivalued 2D cellular
automaton&lt;/em&gt; with funky rules! It’s like a normal 2D game of life, but with
funky rules for 2D points spreading to each other.&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb9-1"&gt;&lt;a href="#cb9-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; step_with_stacks(stacks):&lt;/span&gt;
&lt;span id="cb9-2"&gt;&lt;a href="#cb9-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    neighbs &lt;span class="op"&gt;=&lt;/span&gt; {}&lt;/span&gt;
&lt;span id="cb9-3"&gt;&lt;a href="#cb9-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; pt_2d, pt_stack &lt;span class="kw"&gt;in&lt;/span&gt; stacks.items():&lt;/span&gt;
&lt;span id="cb9-4"&gt;&lt;a href="#cb9-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# higher-dimension components&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-5"&gt;&lt;a href="#cb9-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;for&lt;/span&gt; pt_nd &lt;span class="kw"&gt;in&lt;/span&gt; pt_stack:&lt;/span&gt;
&lt;span id="cb9-6"&gt;&lt;a href="#cb9-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            rev_neighbs &lt;span class="op"&gt;=&lt;/span&gt; Counter(reverse_neighbs(pt_nd))&lt;/span&gt;
&lt;span id="cb9-7"&gt;&lt;a href="#cb9-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            rev_neighbs_incl_self &lt;span class="op"&gt;=&lt;/span&gt; rev_neighbs &lt;span class="op"&gt;+&lt;/span&gt; Counter(pt_nd)&lt;/span&gt;
&lt;span id="cb9-8"&gt;&lt;a href="#cb9-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb9-9"&gt;&lt;a href="#cb9-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="co"&gt;# the actual propagation&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-10"&gt;&lt;a href="#cb9-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="co"&gt;# 1. add in the same stack; don&amp;#39;t include self&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-11"&gt;&lt;a href="#cb9-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;if&lt;/span&gt; pt_2d &lt;span class="kw"&gt;in&lt;/span&gt; neighbs:&lt;/span&gt;
&lt;span id="cb9-12"&gt;&lt;a href="#cb9-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                neighbs[pt_2d] &lt;span class="op"&gt;+=&lt;/span&gt; rev_neighbs&lt;/span&gt;
&lt;span id="cb9-13"&gt;&lt;a href="#cb9-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb9-14"&gt;&lt;a href="#cb9-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                neighbs[pt_2d] &lt;span class="op"&gt;=&lt;/span&gt; rev_neighbs&lt;/span&gt;
&lt;span id="cb9-15"&gt;&lt;a href="#cb9-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="co"&gt;# 2. add to nieghboring stacks; include self&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-16"&gt;&lt;a href="#cb9-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;for&lt;/span&gt; ngb_2 &lt;span class="kw"&gt;in&lt;/span&gt; mk_neighbs(pt_2d)[&lt;span class="dv"&gt;1&lt;/span&gt;:]:&lt;/span&gt;
&lt;span id="cb9-17"&gt;&lt;a href="#cb9-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                &lt;span class="cf"&gt;if&lt;/span&gt; ngb_2 &lt;span class="kw"&gt;in&lt;/span&gt; neighbs:&lt;/span&gt;
&lt;span id="cb9-18"&gt;&lt;a href="#cb9-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    neighbs[ngb_2] &lt;span class="op"&gt;+=&lt;/span&gt; rev_neighbs_incl_self&lt;/span&gt;
&lt;span id="cb9-19"&gt;&lt;a href="#cb9-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb9-20"&gt;&lt;a href="#cb9-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    neighbs[ngb_2] &lt;span class="op"&gt;=&lt;/span&gt; rev_neighbs_incl_self&lt;/span&gt;
&lt;span id="cb9-21"&gt;&lt;a href="#cb9-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb9-22"&gt;&lt;a href="#cb9-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; validate(pt_2d, pt_nd, ncount):&lt;/span&gt;
&lt;span id="cb9-23"&gt;&lt;a href="#cb9-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; pt_nd &lt;span class="kw"&gt;in&lt;/span&gt; stacks[pt_2d]:&lt;/span&gt;
&lt;span id="cb9-24"&gt;&lt;a href="#cb9-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="kw"&gt;or&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-25"&gt;&lt;a href="#cb9-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb9-26"&gt;&lt;a href="#cb9-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-27"&gt;&lt;a href="#cb9-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb9-28"&gt;&lt;a href="#cb9-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; {pt_2d: &lt;span class="bu"&gt;frozenset&lt;/span&gt;(&lt;/span&gt;
&lt;span id="cb9-29"&gt;&lt;a href="#cb9-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                       pt_nd &lt;span class="cf"&gt;for&lt;/span&gt; pt_nd, n &lt;span class="kw"&gt;in&lt;/span&gt; pt_counts.items()&lt;/span&gt;
&lt;span id="cb9-30"&gt;&lt;a href="#cb9-30" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                             &lt;span class="cf"&gt;if&lt;/span&gt; validate(pt_2d, pt_nd, n)&lt;/span&gt;
&lt;span id="cb9-31"&gt;&lt;a href="#cb9-31" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                   )&lt;/span&gt;
&lt;span id="cb9-32"&gt;&lt;a href="#cb9-32" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;              &lt;span class="cf"&gt;for&lt;/span&gt; pt_2d, pt_counts &lt;span class="kw"&gt;in&lt;/span&gt; neighbs&lt;/span&gt;
&lt;span id="cb9-33"&gt;&lt;a href="#cb9-33" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is the final animation: we plot a single 2D grid, and each cell is
colored according to the size of the coset stack under that point (how many
points exist with that &lt;code&gt;&amp;lt;x,y&amp;gt;&lt;/code&gt;). You can slide this one up all
the way to 10D to simulate it in your browser!&lt;/p&gt;
&lt;div id="golFlat" class="highlightbox"&gt;
&lt;p&gt;&lt;strong&gt;Element 9:&lt;/strong&gt; N-D Game of Life&lt;/p&gt;
&lt;div id="golFlatCont"&gt;
&lt;p&gt;Please enable Javascript&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(A lot of examples with symmetries look nice here, such as &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=██▟█.▜███.███▙.█▛██"
class="loadpoints"&gt;spiral galaxy&lt;/a&gt; up to 6D and &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=▛▀▀▜.▌▛▜▐.▌▙▟▐.▙▄▄▟"
class="loadpoints"&gt;bulls-eye&lt;/a&gt;; the alternating symmetries of &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=████.▄▗▖▄.▀▝▘▀.████"
class="loadpoints"&gt;broken bar code&lt;/a&gt; look nice too! But honestly, at
higher-dimensions, almost any input ends up generating appealing gradients, like
&lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=____._▝▖_._▀▘_.____"
class="loadpoints"&gt;glider&lt;/a&gt; and &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=▛▜▙▐.▜▚▗_.█▟▄▘.▟▌▟█"
class="loadpoints"&gt;my own assigned input&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Play around with it, it’s the big finale! :D You can move all the way up to
10D; some older devices may struggle, but on my lower-end cell phone it seems to
run in less than a second. If you mouse-over a cell, the text box will show all
of the slice cosets where that xy cell is alive in (the “coset stack”). If you
click on a cell, your selection will “lock” on that &lt;code&gt;&amp;lt;x,y&amp;gt;&lt;/code&gt;
coordinate as you change dimensions and time.&lt;/p&gt;
&lt;p&gt;Some interesting things you might notice:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;At t=6, it looks like 8D, 9D, 10D (and sometimes 6D,7D) all have the
&lt;em&gt;same&lt;/em&gt; exact 2D cells “on”. They’re identical except for slightly
different stacks above each of those cells.&lt;/p&gt;
&lt;p&gt;To see this clearly, set your time to t=6 and drag your dimension slider back
and forth to see all of the higher-dimensions look identical in shape.&lt;/p&gt;
&lt;p&gt;This probably has something to do with the saturation theory I mentioned
earlier, and is also why &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=██▟█.▜███.███▙.█▛██"
class="loadpoints"&gt;spiral galaxy&lt;/a&gt; &lt;em&gt;suddenly&lt;/em&gt; turns from rich and
beautiful at 6D to blocky and ugly at 7D.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At t=2, t=4, past 5D or so, the state is exactly the same for all
dimensions for any initial condition I have tried! We could easily find t=4 for
100D or even 200D: they’re identical!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A lot of xy cells share identical coset stacks…more on that
later!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Not only is it kinda pretty (in my humble opinion), it also demonstrates that
this whole ordeal is really “just a multivalued 2D cellular automaton”: it’s
like a “multi-valued” Game of Life, where instead of cells being on and off,
they are one of several discrete choices of values. Instead of a “binary” game
of life with a boolean at each cell, it’s an “integer” game of life with a
finite choice at each cell.&lt;/p&gt;
&lt;p&gt;Because there are &lt;span class="math inline"&gt;\({ {\hat{d}}+t} \choose
t\)&lt;/span&gt; slice cosets for a given dimension and time, it means that our game
is a &lt;span class="math inline"&gt;\(2^{ { \hat{d} + t} \choose t }\)&lt;/span&gt;-valued
game of life, where each cell can be one of that many options (each slice coset
and be present or not). That means at 2D (&lt;span class="math inline"&gt;\(\hat{d} =
0\)&lt;/span&gt;), we have a normal 2-valued game of life (&lt;span
class="math inline"&gt;\(2^1\)&lt;/span&gt;), at 3D we have &lt;span class="math inline"&gt;\(7
\choose 6\)&lt;/span&gt; or 7 possible points at t=6, so that’s a &lt;span
class="math inline"&gt;\(2^7\)&lt;/span&gt; or 128-valued game of life, at 4D we have
&lt;span class="math inline"&gt;\(8
\choose 6\)&lt;/span&gt; or 28 possible points at t=6, and so that’s a &lt;span
class="math inline"&gt;\(2^{28}\)&lt;/span&gt; or 268,435,456-valued game of life.&lt;/p&gt;
&lt;p&gt;You can see this demonstrated in the simulation above, as well. As you
progress, each 2D cell “spreads” to its neighbors according to some complex
rule; it’s like watching 2d cells interact with each other in complex ways,
without ever even having to think of higher dimensions.&lt;/p&gt;
&lt;p&gt;Implementing things this way (and taking advantage of the fact that coset
stacks are usually very sparse and have few members) gave a nice conceptual
shake-up. But there’s one final thing that this view would unlock that would
make the biggest difference.&lt;/p&gt;
&lt;h3 id="repeated-stacks"&gt;Repeated Stacks&lt;/h3&gt;
&lt;p&gt;You might have noticed in the final 10D simulation, if you mouse over an xy
cell, it’ll also highlight over all of the other xy cells that hold the same
coset stack. For most initial starting positions, you might notice something
maybe even more curious — a &lt;em&gt;lot&lt;/em&gt; of those stacks are duplicated over
many xy cells.&lt;/p&gt;
&lt;p&gt;In my &lt;a
href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html?points=▛▜▙▐.▜▚▗_.█▟▄▘.▟▌▟█"
class="loadpoints"&gt;personal puzzle input&lt;/a&gt; (click to load into the
simulation), &lt;em&gt;most&lt;/em&gt; of the stacks were duplicated many times across
different xy cells. If you highlight the cells in any arbitrary starting
condition through t=6, you’ll see too that many (if not most) xy cells have
multiple other xy cells that have identical stacks to them.&lt;/p&gt;
&lt;p&gt;This final insight yields the final optimization we have discovered, as of
time of writing. We can actually treat an &lt;em&gt;entire stack&lt;/em&gt; as an “action”
that is spread to the xy neighbors: The stack under
&lt;code&gt;&amp;lt;x,y&amp;gt;=&amp;lt;3,4&amp;gt;&lt;/code&gt; is spread to all its eight 2D neighbors
identically (and to itself, too, in a way that excludes the original stack
itself). That means if you have a stack, you can compute the contribution to a
neighbor (expensive) it has &lt;em&gt;one time&lt;/em&gt;, and then &lt;em&gt;repeat that same
contribution&lt;/em&gt; to every occurrence of a stack. So if a stack is repeated ten
times over ten different xy stacks, you only need to compute it once and
propagate it to all 9x10 neighbors of those stacks (nine neighbors, including
self, times each of the 10 repetitions), for a savings of x90! This can be done
by storing map of stacks to contributions as a cache.&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span id="cb10-1"&gt;&lt;a href="#cb10-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;def&lt;/span&gt; step_with_stack_cache(stacks):&lt;/span&gt;
&lt;span id="cb10-2"&gt;&lt;a href="#cb10-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    neighbs &lt;span class="op"&gt;=&lt;/span&gt; {}&lt;/span&gt;
&lt;span id="cb10-3"&gt;&lt;a href="#cb10-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    stack_cache &lt;span class="op"&gt;=&lt;/span&gt; {}&lt;/span&gt;
&lt;span id="cb10-4"&gt;&lt;a href="#cb10-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-5"&gt;&lt;a href="#cb10-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; pt_2d, pt_stack &lt;span class="kw"&gt;in&lt;/span&gt; stacks.items():&lt;/span&gt;
&lt;span id="cb10-6"&gt;&lt;a href="#cb10-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# get what to place in the same xy cell, and what to place in neighbor&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-7"&gt;&lt;a href="#cb10-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# xy cells&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-8"&gt;&lt;a href="#cb10-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; pt_stack &lt;span class="kw"&gt;in&lt;/span&gt; stack_cache:&lt;/span&gt;
&lt;span id="cb10-9"&gt;&lt;a href="#cb10-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="co"&gt;# get it from the cache if it exists&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-10"&gt;&lt;a href="#cb10-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            (rev_neighbs, rev_neighbs_incl_self) &lt;span class="op"&gt;=&lt;/span&gt; stack_cache[pt_stack]&lt;/span&gt;
&lt;span id="cb10-11"&gt;&lt;a href="#cb10-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb10-12"&gt;&lt;a href="#cb10-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="co"&gt;# otherwise, build it and store it in the cache&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-13"&gt;&lt;a href="#cb10-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            rev_neighbs &lt;span class="op"&gt;=&lt;/span&gt; Counter()&lt;/span&gt;
&lt;span id="cb10-14"&gt;&lt;a href="#cb10-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;for&lt;/span&gt; pt_nd &lt;span class="kw"&gt;in&lt;/span&gt; pt_stack:&lt;/span&gt;
&lt;span id="cb10-15"&gt;&lt;a href="#cb10-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                rev_neighbs &lt;span class="op"&gt;+=&lt;/span&gt; Counter(reverse_neighbs(pt_nd))&lt;/span&gt;
&lt;span id="cb10-16"&gt;&lt;a href="#cb10-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            rev_neighbs_incl_self &lt;span class="op"&gt;=&lt;/span&gt; rev_neighbs &lt;span class="op"&gt;+&lt;/span&gt; Counter(pt_stack)&lt;/span&gt;
&lt;span id="cb10-17"&gt;&lt;a href="#cb10-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            stack_cache[pt_stack] &lt;span class="op"&gt;=&lt;/span&gt; (rev_neighbs, rev_neighbs_incl_self)&lt;/span&gt;
&lt;span id="cb10-18"&gt;&lt;a href="#cb10-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-19"&gt;&lt;a href="#cb10-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# the actual propagation&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-20"&gt;&lt;a href="#cb10-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# 1. add in the same stack; don&amp;#39;t include self&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-21"&gt;&lt;a href="#cb10-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; pt_2d &lt;span class="kw"&gt;in&lt;/span&gt; neighbs:&lt;/span&gt;
&lt;span id="cb10-22"&gt;&lt;a href="#cb10-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            neighbs[pt_2d] &lt;span class="op"&gt;+=&lt;/span&gt; rev_neighbs&lt;/span&gt;
&lt;span id="cb10-23"&gt;&lt;a href="#cb10-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb10-24"&gt;&lt;a href="#cb10-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            neighbs[pt_2d] &lt;span class="op"&gt;=&lt;/span&gt; rev_neighbs&lt;/span&gt;
&lt;span id="cb10-25"&gt;&lt;a href="#cb10-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="co"&gt;# 2. add to nieghboring stacks; include self&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-26"&gt;&lt;a href="#cb10-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;for&lt;/span&gt; ngb_2 &lt;span class="kw"&gt;in&lt;/span&gt; mk_neighbs(pt_2d)[&lt;span class="dv"&gt;1&lt;/span&gt;:]:&lt;/span&gt;
&lt;span id="cb10-27"&gt;&lt;a href="#cb10-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;if&lt;/span&gt; ngb_2 &lt;span class="kw"&gt;in&lt;/span&gt; neighbs:&lt;/span&gt;
&lt;span id="cb10-28"&gt;&lt;a href="#cb10-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                neighbs[ngb_2] &lt;span class="op"&gt;+=&lt;/span&gt; rev_neighbs_incl_self&lt;/span&gt;
&lt;span id="cb10-29"&gt;&lt;a href="#cb10-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb10-30"&gt;&lt;a href="#cb10-30" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                neighbs[ngb_2] &lt;span class="op"&gt;=&lt;/span&gt; rev_neighbs_incl_self&lt;/span&gt;
&lt;span id="cb10-31"&gt;&lt;a href="#cb10-31" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-32"&gt;&lt;a href="#cb10-32" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; validate(pt_2d, pt_nd, ncount):&lt;/span&gt;
&lt;span id="cb10-33"&gt;&lt;a href="#cb10-33" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; pt_2d &lt;span class="kw"&gt;in&lt;/span&gt; stacks &lt;span class="kw"&gt;and&lt;/span&gt; pt_nd &lt;span class="kw"&gt;in&lt;/span&gt; stacks[pt_2d]:&lt;/span&gt;
&lt;span id="cb10-34"&gt;&lt;a href="#cb10-34" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="kw"&gt;or&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-35"&gt;&lt;a href="#cb10-35" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/span&gt;
&lt;span id="cb10-36"&gt;&lt;a href="#cb10-36" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; ncount &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-37"&gt;&lt;a href="#cb10-37" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-38"&gt;&lt;a href="#cb10-38" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; {pt_2d: &lt;span class="bu"&gt;frozenset&lt;/span&gt;(&lt;/span&gt;
&lt;span id="cb10-39"&gt;&lt;a href="#cb10-39" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                       pt_nd &lt;span class="cf"&gt;for&lt;/span&gt; pt_nd, n &lt;span class="kw"&gt;in&lt;/span&gt; pt_counts.items()&lt;/span&gt;
&lt;span id="cb10-40"&gt;&lt;a href="#cb10-40" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                             &lt;span class="cf"&gt;if&lt;/span&gt; validate(pt_2d, pt_nd, n)&lt;/span&gt;
&lt;span id="cb10-41"&gt;&lt;a href="#cb10-41" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                   )&lt;/span&gt;
&lt;span id="cb10-42"&gt;&lt;a href="#cb10-42" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;              &lt;span class="cf"&gt;for&lt;/span&gt; pt_2d, pt_counts &lt;span class="kw"&gt;in&lt;/span&gt; neighbs&lt;/span&gt;
&lt;span id="cb10-43"&gt;&lt;a href="#cb10-43" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this final piece of the puzzle, I was able to reach 18D &lt;em&gt;3
seconds&lt;/em&gt; in my Haskell solution, and 30D in 5 minutes! Michal Marsalek was
also able to build this into their fast Nim solver to &lt;a
href="https://www.reddit.com/user/MichalMarsalek/"&gt;reach 40D in 8 minutes, 50D
in 32 minutes, 60D in 120 minutes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And as far as I know, this seems to be where things stand today (Feburary
2021).&lt;/p&gt;
&lt;h2 id="conclusions"&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Hope you enjoyed this journey! My hope is that I was able to convey a
fraction of the excitement, wonder, and mystery I felt during the process. At
every point, we had no reason to believe something better would come around the
corner, but we held on to a hope and faith that kept on rewarding us.&lt;/p&gt;
&lt;p&gt;Visualization and different perspectives seem to drive almost every
revelation — from the visually striking symmetries of the 3D and 4D simulations,
the explorations of how neighbor relationships work, the insight that we could
treat the entire problem as a fancy multivalued 2D game of life…all of it came
about from being able to see the problem visually in different ways. At other
times it was a simple change in perspective to find a better way of encoding
variants or looking at how a specific number changed. I know for myself, the
next time I try to explore something like this, I will try to apply what I
learned to always reach for visualization sooner. Even dead-end visualizations
can sometimes provide a new depth to the puzzle that you might appreciate later
on.&lt;/p&gt;
&lt;p&gt;Another thing I hope was apparent was the power of community! I know I
definitely would not have had as much fun doing this if it wasn’t for the
vibrant Advent of Code “Ante-Pushing” community. What I’ve described is just
&lt;em&gt;one story&lt;/em&gt; (Day 17, 2020) out of so many that Advent of Code community
members routinely explore together (through 25 puzzles each year for five
years). Most of these discoveries were fun because we always had somebody to
share them with, or a way to encourage each other and strive for a common goal.
I’m definitely lucky to be standing on giants as a part of a talented and
passionately curious community that’s excited to explore things like this.
Michal Marsalek &lt;a
href="https://github.com/MichalMarsalek/Advent-of-code/blob/master/2020/misc/day17-highdims/ND_gol_with_low_dimensional_initial_state.pdf"&gt;has
his own writeup of the discoveres mentioned here&lt;/a&gt;, that you should check out
too if you have the time!&lt;/p&gt;
&lt;p&gt;Thank you to so many people — Michal Marsalek, Peter Tseng, leftylink,
sim642, ephemient, yitz, cyphase, phaazon, glguy, /u/cetttbycettt, /u/bsterc,
/u/flwyd, and so many others that I probably missed. An especially deep thanks
to &lt;a href="https://twitter.com/ericwastl"&gt;Eric Wastl&lt;/a&gt; for hosting a
wonderful event like Advent of Code every year. Finally, a profoundly deep
thanks to the late John Conway, who revealed to us how much joy can come from
the exploration of all things mathematical, a genius who was taken away from
this world much too soon.&lt;/p&gt;
&lt;p&gt;And of course, in making this post, I’m inviting you, the reader, to join us
along in this journey as well! It’s hardly over :) Now that you’re up to speed
with all of us, I’d be excited to hear about anything you might discover while
playing around with this too!&lt;/p&gt;
&lt;p&gt;Looking forward at least, there are a some open threads still.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Notice on the &lt;a href="#gol4D"&gt;4D simulation&lt;/a&gt;, very soon after
simulations start, the two diagonals become very empty, and especially the 3x3
region at the origin where they intersect. It turns out that reflection symmetry
boundaries are very inhospitable because they have &lt;em&gt;so many neighbors&lt;/em&gt;
after reflection, especially at higher dimensions (see the top-right slice at
each q level in &lt;a href="#golSyms5D"&gt;the 5D symmetries&lt;/a&gt;). Could these “dead
zones” be extended and exploited at higher dimensions?&lt;/li&gt;
&lt;li&gt;The most promising to me: for t=6, the exact same xy cells are always
inhabited for any dimension past 7D or so, and the stacks at each seem to only
change slightly from dimension to dimension. If we can analytically find how the
stacks at any given position change between 9D and 10D, 10D and 11D, etc., then
it will be easy to jump directly to t=6 at 100D without simulating anything.
Another way to say this is — can we simulate by fixing t and stepping d, instead
of fixing d and stepping t?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Who can tell how far we can go? &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/gia880d/"&gt;Michal&lt;/a&gt;
has a personal goal that I would also be very happy to reach:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I won’t be satisfied until I implement a solution that runs in polynomial
time in both t and d.&lt;/p&gt;
&lt;p&gt;— Michal Marsalek&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Will you, dear reader, be the one to take us there? :)&lt;/p&gt;
&lt;h2 id="special-thanks"&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it
possible for me to devote time to researching and writing these posts. Very
special thanks to my supporter at the “Amazing” level on &lt;a
href="https://www.patreon.com/justinle/overview"&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;And…there’s actually a neat optimization we can use (brought to
our attention by &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/ghmllf8"&gt;Peter
Tseng&lt;/a&gt;) to avoid the check of the original set in step 2c above: when you
iterate over each point, increment the eight neighbors’ map values by
&lt;em&gt;2&lt;/em&gt;, and then increment the point itself by 1. Then in the final integer
under each key, &lt;code&gt;n / 2&lt;/code&gt; or &lt;code&gt;n &amp;gt;&amp;gt; 1&lt;/code&gt; gives you the
number of neighbors and &lt;code&gt;n % 2&lt;/code&gt; (modulus) gives you whether or not
that cell was alive.&lt;a href="#fnref1" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;There’s another optimization too you could use that would allow
you to ignore this and just treat a cell as its own neighbor; you’d have to
tweak the live-or-dead rules slightly, but it does simplify a lot of the
propagation logic.&lt;a href="#fnref2" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;For dramatic effect, I’ve omitted the fact that while there are
only 3003 possible higher-dimensional points, there are &lt;span
class="math inline"&gt;\(20^2 \times 3003\)&lt;/span&gt; actual unique points possible
factoring in the 20x20 x-y grid. Still, it’s a pretty big improvement over the
original situation (&lt;span class="math inline"&gt;\(20^2 \times
815730721\)&lt;/span&gt;).&lt;a href="#fnref3" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;It’s also interesting to note that above 9D (where there are 7
higher-dimensional coordinates), there is always at least one duplicated number.
Although I don’t really know a way to explicitly exploit that fact even now, it
does mean that there’s a qualitative difference between 9D and below and 10D and
above: anything above 9D is…especially degenerate.&lt;a href="#fnref4"
class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;One useful lasting thing I did find (that I won’t spend too much
time on here) was a way to &lt;a
href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/gim68l0/"&gt;index
into an enumeration&lt;/a&gt; of all of the slice cosets (that is, all the normalized
higher-dimensional coordinates). I no longer store &lt;code&gt;&amp;lt;z,w,...&amp;gt;&lt;/code&gt;
points as vectors, but rather as a single integer representing their index in
that enumeration, which is easier to access and store. I also found a way to do
streaming decoding and encoding between that index and the components it
represents, allowing me to stream neighbor weights in constant time. This dense
index encoding was actually really useful in implementing the Javascript demos
on this page :)&lt;a href="#fnref5" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html</guid><pubDate>Thu, 11 Feb 2021 18:45:30 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2021-02-11</date></item><item><title>Advent of Code 2020: Haskell Solution Reflections for all 25 Days
</title><link>https://blog.jle.im/entry/advent-of-code-2020.html</link><description>&lt;p&gt;Merry Christmas and Happy New Years, to all!&lt;/p&gt;
&lt;p&gt;Once again, every year I like to participate in Eric Wastl’s &lt;em&gt;&lt;a
href="http://adventofcode.com/"&gt;Advent of Code&lt;/a&gt;&lt;/em&gt;! It’s a series of 25
Christmas-themed puzzles that release every day at midnight — there’s a cute
story motivating each one, usually revolving around saving Christmas. Every
night my friends and I (including the good people of freenode’s
&lt;code&gt;##advent-of-code&lt;/code&gt; channel) talk about the puzzle and creative ways
to solve it (and also see how my &lt;a
href="https://twitter.com/mstk/status/1343027484808380416"&gt;bingo card&lt;/a&gt; is
doing). The &lt;a href="https://www.reddit.com/r/adventofcode"&gt;subreddit
community&lt;/a&gt; is also pretty great as well! And an even nicer thing is that the
puzzles are open-ended enough that there are often many ways of approaching
them…including some approaches that can leverage math concepts in surprising
ways, like &lt;a href="https://blog.jle.im/entry/alchemical-groups.html"&gt;group
theory&lt;/a&gt;, &lt;a href="https://blog.jle.im/entry/shifting-the-stars.html"&gt;galilean
transformations and linear algebra&lt;/a&gt;, and &lt;a
href="https://blog.jle.im/entry/shuffling-things-up.html"&gt;more group theory&lt;/a&gt;.
Many of the puzzles are often simple data transformations that Haskell is
especially good at!&lt;/p&gt;
&lt;p&gt;Speaking of Haskell, I usually do a write-up for every day I can get around
to about unique insights that solving in Haskell can provide to each different
puzzle. I did them in &lt;a
href="https://github.com/mstksg/advent-of-code-2017/blob/master/reflections.md"&gt;2017&lt;/a&gt;,
&lt;a
href="https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md"&gt;2018&lt;/a&gt;,
and &lt;a
href="https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md"&gt;2019&lt;/a&gt;,
but I never finished every day. But 2020 being what it is, I was able to finish!
:D&lt;/p&gt;
&lt;p&gt;You can find &lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections.md"&gt;all
of them here&lt;/a&gt;, but here are links to each individual one. Hopefully you can
find them helpful. And if you haven’t yet, why not try &lt;a
href="http://adventofcode.com/"&gt;Advent of Code&lt;/a&gt; yourself? :) And drop by the
freenode &lt;code&gt;##advent-of-code&lt;/code&gt; channel, we’d love to say hi and chat, or
help out! Thanks all for reading, and also thanks to Eric for a great event this
year, as always!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day01.md"&gt;Day
1 - Report Repair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day02.md"&gt;Day
2 - Passport Philosophy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day03.md"&gt;Day
3 - Toboggan Trajectory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day04.md"&gt;Day
4 - Passport Processing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day05.md"&gt;Day
5 - Binary Boarding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day06.md"&gt;Day
6 - Custom Customs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day07.md"&gt;Day
7 - Handy Haversacks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day08.md"&gt;Day
8 - Handheld Halting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day09.md"&gt;Day
9 - Encoding Error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day10.md"&gt;Day
10 - Adapter Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day11.md"&gt;Day
11 - Seating System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day12.md"&gt;Day
12 - Rain Risk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day13.md"&gt;Day
13 - Shuttle Search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day14.md"&gt;Day
14 - Docking Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day15.md"&gt;Day
15 - Rambunctious Recitations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day16.md"&gt;Day
16 - Ticket Translation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day17.md"&gt;Day
17 - Conway Cubes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day18.md"&gt;Day
18 - Operation Order&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day19.md"&gt;Day
19 - Monster Messages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day20.md"&gt;Day
20 - Jurassic Jigsaw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day21.md"&gt;Day
21 - Allergen Assessment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day22.md"&gt;Day
22 - Crab Combat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day23.md"&gt;Day
23 - Crab Cups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day24.md"&gt;Day
24 - Lobby Layout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day25.md"&gt;Day
25 - Combo Breaker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/advent-of-code-2020.html</guid><pubDate>Thu, 31 Dec 2020 04:35:15 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-12-31</date></item><item><title>Roll your own Holly Jolly streaming combinators with Free
</title><link>https://blog.jle.im/entry/holly-jolly-streaming-combinators.html</link><description>&lt;p&gt;Hi! Welcome, if you’re joining us from the great &lt;a
href="https://adventofhaskell.com/"&gt;Advent of Haskell 2020&lt;/a&gt; event! Feel free
to grab a hot chocolate and sit back by the fireplace. I’m honored to be able to
be a part of the event this year; it’s a great initiative and harkens back to
the age-old Haskell tradition of bite-sized Functional Programming “advent
calendars”. I remember when I was first learning Haskell, &lt;a
href="https://ocharles.org.uk/pages/2012-12-01-24-days-of-hackage.html"&gt;Ollie
Charles’ 24 Days of Hackage series&lt;/a&gt; was one of my favorite series that helped
me really get into the exciting world of Haskell and the all the doors that
functional programming can open.&lt;/p&gt;
&lt;p&gt;All of the posts this year have been great — they range from insightful
reflections on the nature of Haskell and programming in Haskell, or also on
specific language features. This post is going to be one of the “project-based”
ones, where we walk through and introduce a solidly &lt;em&gt;intermediate&lt;/em&gt;
Haskell technique as it applies to building a useful general toolset. I’m going
to be exploring the “functor combinator style” where you identify the interface
you want, associate it with a common Haskell typeclass, pick your primitives,
and automatically get the ability to imbue your primitives with the structure
you need. I’ve talked about this previously with:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="https://blog.jle.im/entry/free-alternative-regexp.html"&gt;Applicative
regular expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.jle.im/entry/functor-combinatorpedia.html"&gt;The functor
combinatorpedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://blog.jle.im/entries/series/+enhancing-functor-structures.html"&gt;Bidirectional
serializers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href="https://blog.jle.im/entry/interpreters-a-la-carte-duet.html"&gt;Composable
interpreters&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;and I wanted to share a recent application I have been able to use apply it
with where just &lt;em&gt;thinking&lt;/em&gt; about the primitives gave me almost all the
functionality I needed for a type: composable streaming combinators. This
specific application is also very applicable to integrate into any &lt;a
href="https://www.stephendiehl.com/posts/decade.html#algebraic-effect-systems"&gt;composable
effects system&lt;/a&gt;, since it’s essentially a monadic interface.&lt;/p&gt;
&lt;p&gt;In a way, this post could also be seen as capturing the spirit of the
holidays by reminiscing about the days of yore — looking back at one of the more
exciting times in modern Haskell’s development, where competing composable
streaming libraries were at the forefront of practical innovation. The dust has
settled on that a bit, but it every time I think about composable streaming
combinators, I do get a bit nostalgic :)&lt;/p&gt;
&lt;p&gt;This post is written for an &lt;em&gt;intermediate&lt;/em&gt; Haskell audience, and will
assume you have a familiarity with monads and monadic interfaces, and also a
little bit of experience with monad transformers. Note — there are many ways to
arrive at the same result, but this post is more of a demonstration of a certain
style and approach that has benefited my greatly in the past.&lt;/p&gt;
&lt;p&gt;All of the code in this page &lt;a
href="https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs"&gt;can
be found online at github&lt;/a&gt;!&lt;/p&gt;
&lt;h2 id="dreaming-of-an-effectful-christmas"&gt;Dreaming of an Effectful
Christmas&lt;/h2&gt;
&lt;p&gt;The goal here is to make a system of composable pipes that are “pull-based”,
so we can process data as it is read in from IO only as we need it, and never do
more work than we need to do up-front or leak memory when we stop using it.&lt;/p&gt;
&lt;p&gt;So, the way I usually approach things like these is: “dress for the interface
you want, not the one you have.” It involves:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Thinking of the &lt;code&gt;m a&lt;/code&gt; you want and how you would want to combine
it/use it.&lt;/li&gt;
&lt;li&gt;Express the primitive actions of that thing&lt;/li&gt;
&lt;li&gt;Use some sort of free structure or effects system to enhance that primitive
with the interface you are looking for.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, let’s imagine our type!&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb1-1"&gt;&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where a &lt;code&gt;Pipe i o m a&lt;/code&gt; represents a pipe component where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;: the type of the input the pipe expects from upstream&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt;: the type of the output the pipe will be yielding
upstream&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;: the monad that the underlying actions live in&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: the overall result of the pipe once it has terminated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One nice thing about this setup is that by picking different values for the
type parameters, we can already get a nice classification for interesting
subtypes:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;If &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;()&lt;/code&gt; (or universally quantified&lt;a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;) — a &lt;code&gt;Pipe () o m a&lt;/code&gt; — it means
that the pipe doesn’t ever expect any sort of information upstream, and so can
be considered a “source” that keeps on churning out values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Void&lt;/code&gt; (or universally quantified) — a
&lt;code&gt;Pipe i Void m a&lt;/code&gt; — it means that the pipe will never yield anything
downstream, because &lt;code&gt;Void&lt;/code&gt; has no inhabitants that could possibly be
yielded.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb2-1"&gt;&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Void&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that it acts like a “sink” that will keep on eating &lt;code&gt;i&lt;/code&gt;
values without ever outputting anything downstream.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;()&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt; is
&lt;code&gt;Void&lt;/code&gt; (or they are both universally quantified), then the pipe
doesn’t expect any sort of information upstream, and also won’t ever yield
anything downstream… a &lt;code&gt;Pipe () Void m a&lt;/code&gt; is just an
&lt;code&gt;m     a&lt;/code&gt;! In the biz, we often call this an “effect”.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Void&lt;/code&gt; (or universally quantified) — a
&lt;code&gt;Pipe i o m Void&lt;/code&gt; — it means that the pipe will never terminate,
since &lt;code&gt;Void&lt;/code&gt; has no inhabitants that could it could possibly produce
upon termination.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To me, I think it embodies a lot of the nice principles about the “algebra”
of types that can be used to reason with inputs and outputs. Plus, it allows us
to unify sources, sinks, and non-terminating pipes all in one type!&lt;/p&gt;
&lt;p&gt;Now let’s think of the interface we want. We want to be able to:&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb3-1"&gt;&lt;a href="#cb3-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | Yield a value `o` downstream&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-2"&gt;&lt;a href="#cb3-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;yield ::&lt;/span&gt; o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m ()&lt;/span&gt;
&lt;span id="cb3-3"&gt;&lt;a href="#cb3-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-4"&gt;&lt;a href="#cb3-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | Await a value `i` upstream&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-5"&gt;&lt;a href="#cb3-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;await ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m (&lt;span class="dt"&gt;Maybe&lt;/span&gt; i)&lt;/span&gt;
&lt;span id="cb3-6"&gt;&lt;a href="#cb3-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-7"&gt;&lt;a href="#cb3-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | Terminate immediately with a result value&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-8"&gt;&lt;a href="#cb3-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="fu"&gt;return&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a&lt;/span&gt;
&lt;span id="cb3-9"&gt;&lt;a href="#cb3-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-10"&gt;&lt;a href="#cb3-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | Sequence pipes one-after-another:&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-11"&gt;&lt;a href="#cb3-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- &amp;quot;do this until it terminates, then that one next&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-12"&gt;&lt;a href="#cb3-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;(&amp;gt;&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b&lt;/span&gt;
&lt;span id="cb3-13"&gt;&lt;a href="#cb3-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-14"&gt;&lt;a href="#cb3-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | In fact let&amp;#39;s just make it a full fledged monad, why not?  We&amp;#39;re designing&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-15"&gt;&lt;a href="#cb3-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- our dream interface here.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-16"&gt;&lt;a href="#cb3-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;(&amp;gt;&amp;gt;=) ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b&lt;/span&gt;
&lt;span id="cb3-17"&gt;&lt;a href="#cb3-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-18"&gt;&lt;a href="#cb3-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | A pipe that simply does action in the underlying monad and terminates with&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-19"&gt;&lt;a href="#cb3-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- the result&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-20"&gt;&lt;a href="#cb3-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;lift ::&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a&lt;/span&gt;
&lt;span id="cb3-21"&gt;&lt;a href="#cb3-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-22"&gt;&lt;a href="#cb3-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | Compose pipes, linking the output of one to the input of the other&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-23"&gt;&lt;a href="#cb3-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;(.|) ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i j m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; j o m b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b&lt;/span&gt;
&lt;span id="cb3-24"&gt;&lt;a href="#cb3-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-25"&gt;&lt;a href="#cb3-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- | Finally: run it all on a pipe expecting no input and never yielding:&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-26"&gt;&lt;a href="#cb3-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runPipe ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; () &lt;span class="dt"&gt;Void&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This looks like a complicated list…but actually most of these come from
ubiquitous Haskell typeclasses like &lt;code&gt;Monad&lt;/code&gt; and
&lt;code&gt;Applicative&lt;/code&gt;. We’ll see how this comes into play later, when we
learn how to get these instances for our types for free. This makes the actual
“work” we have to do very small.&lt;/p&gt;
&lt;p&gt;So, these are going to be implementing “conduit-style” streaming combinators,
where streaming actions are monadic, and monadic sequencing represents “do this
after this one is done.” Because of this property, they work well as
&lt;em&gt;pull-based&lt;/em&gt; pipes: yields will block until a corresponding await can
accept what is yielded.&lt;/p&gt;
&lt;h3 id="put-on-those-christmas-sweaters"&gt;Put on those Christmas Sweaters&lt;/h3&gt;
&lt;p&gt;“Dress for the interface you want, not the one you have”. So let’s pretend we
already implemented this interface…what could we do with it?&lt;/p&gt;
&lt;p&gt;Well, can write simple sources like “yield the contents from a file
line-by-line”:&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb4-1"&gt;&lt;a href="#cb4-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L65-L72&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-2"&gt;&lt;a href="#cb4-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb4-3"&gt;&lt;a href="#cb4-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;sourceHandleIO ::&lt;/span&gt; &lt;span class="dt"&gt;Handle&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb4-4"&gt;&lt;a href="#cb4-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;sourceHandleIO handle &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-5"&gt;&lt;a href="#cb4-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    res &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="op"&gt;$&lt;/span&gt; tryJust (guard &lt;span class="op"&gt;.&lt;/span&gt; isEOFError) (hGetLine handle)&lt;/span&gt;
&lt;span id="cb4-6"&gt;&lt;a href="#cb4-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; res &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-7"&gt;&lt;a href="#cb4-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Left&lt;/span&gt;  _   &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;return&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb4-8"&gt;&lt;a href="#cb4-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Right&lt;/span&gt; out &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-9"&gt;&lt;a href="#cb4-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        yield out&lt;/span&gt;
&lt;span id="cb4-10"&gt;&lt;a href="#cb4-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        sourceHandle handle&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that because the &lt;code&gt;i&lt;/code&gt; is universally quantified, it means that
we know that &lt;code&gt;sourceFile&lt;/code&gt; never ever awaits or touches any input:
it’s purely a source.&lt;/p&gt;
&lt;p&gt;We can even write a simple sink, like “await and print the results to stdout
as they come”:&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb5-1"&gt;&lt;a href="#cb5-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L83-L90&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-2"&gt;&lt;a href="#cb5-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-3"&gt;&lt;a href="#cb5-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;sinkStdoutIO ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; o &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb5-4"&gt;&lt;a href="#cb5-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;sinkStdoutIO &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-5"&gt;&lt;a href="#cb5-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    inp &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/span&gt;
&lt;span id="cb5-6"&gt;&lt;a href="#cb5-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; inp &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-7"&gt;&lt;a href="#cb5-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb5-8"&gt;&lt;a href="#cb5-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Just&lt;/span&gt; x  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-9"&gt;&lt;a href="#cb5-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        lift &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb5-10"&gt;&lt;a href="#cb5-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        sinkStdout&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And maybe we can write a pipe that takes input strings and converts them to
all capital letters and re-yields them:&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb6-1"&gt;&lt;a href="#cb6-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L101-L108&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb6-2"&gt;&lt;a href="#cb6-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb6-3"&gt;&lt;a href="#cb6-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;toUpperPipe ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; m ()&lt;/span&gt;
&lt;span id="cb6-4"&gt;&lt;a href="#cb6-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;toUpperPipe &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb6-5"&gt;&lt;a href="#cb6-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    inp &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/span&gt;
&lt;span id="cb6-6"&gt;&lt;a href="#cb6-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; inp &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb6-7"&gt;&lt;a href="#cb6-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb6-8"&gt;&lt;a href="#cb6-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Just&lt;/span&gt; x  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb6-9"&gt;&lt;a href="#cb6-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        yield (&lt;span class="fu"&gt;map&lt;/span&gt; &lt;span class="fu"&gt;toUpper&lt;/span&gt; x)&lt;/span&gt;
&lt;span id="cb6-10"&gt;&lt;a href="#cb6-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        toUpperPipe&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can maybe write a pipe that stops as soon as it reads the line
&lt;code&gt;STOP&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb7-1"&gt;&lt;a href="#cb7-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L110-L119&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-2"&gt;&lt;a href="#cb7-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb7-3"&gt;&lt;a href="#cb7-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;untilSTOP ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; m ()&lt;/span&gt;
&lt;span id="cb7-4"&gt;&lt;a href="#cb7-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;untilSTOP &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-5"&gt;&lt;a href="#cb7-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    inp &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/span&gt;
&lt;span id="cb7-6"&gt;&lt;a href="#cb7-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; inp &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-7"&gt;&lt;a href="#cb7-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb7-8"&gt;&lt;a href="#cb7-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Just&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb7-9"&gt;&lt;a href="#cb7-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="op"&gt;|&lt;/span&gt; x &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;STOP&amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb7-10"&gt;&lt;a href="#cb7-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="fu"&gt;otherwise&lt;/span&gt;   &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-11"&gt;&lt;a href="#cb7-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            yield x&lt;/span&gt;
&lt;span id="cb7-12"&gt;&lt;a href="#cb7-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            untilSTOP&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;untilSTOP&lt;/code&gt; is really sort of the crux of what makes these
streaming systems useful: we only pull items from the file as we need it, and
&lt;code&gt;untilSTOP&lt;/code&gt; will stop pulling anything as soon as we hit
&lt;code&gt;STOP&lt;/code&gt;, so no IO will happen anymore if the upstream sink does
IO.&lt;/p&gt;
&lt;h3 id="our-ideal-program"&gt;Our Ideal Program&lt;/h3&gt;
&lt;p&gt;Now ideally, we’d want to write a program that lets us compose the above
pipes to read from a file and output its contents to stdout, until it sees a
STOP line:&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb8-1"&gt;&lt;a href="#cb8-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L121-L126&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-2"&gt;&lt;a href="#cb8-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb8-3"&gt;&lt;a href="#cb8-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;samplePipeIO ::&lt;/span&gt; &lt;span class="dt"&gt;Handle&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb8-4"&gt;&lt;a href="#cb8-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;samplePipeIO handle &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-5"&gt;&lt;a href="#cb8-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;       sourceHandleIO handle&lt;/span&gt;
&lt;span id="cb8-6"&gt;&lt;a href="#cb8-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; untilSTOP&lt;/span&gt;
&lt;span id="cb8-7"&gt;&lt;a href="#cb8-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; toUpperPipe&lt;/span&gt;
&lt;span id="cb8-8"&gt;&lt;a href="#cb8-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; sinkStdoutIO&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="setting-up-our-stockings"&gt;Setting up our Stockings&lt;/h2&gt;
&lt;p&gt;Step 2 of our plan was to identify the primitive actions we want. Looking at
our interface, it seems like the few things that let us “create” a
&lt;code&gt;Pipe&lt;/code&gt; from scratch (instead of combining existing ones) are:&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb9-1"&gt;&lt;a href="#cb9-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;yield  ::&lt;/span&gt; o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m ()&lt;/span&gt;
&lt;span id="cb9-2"&gt;&lt;a href="#cb9-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;await  ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m (&lt;span class="dt"&gt;Maybe&lt;/span&gt; i)&lt;/span&gt;
&lt;span id="cb9-3"&gt;&lt;a href="#cb9-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;lift   ::&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a&lt;/span&gt;
&lt;span id="cb9-4"&gt;&lt;a href="#cb9-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="fu"&gt;return&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; a   &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, we can note that &lt;code&gt;lift&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; can be
gained just from having a &lt;code&gt;Monad&lt;/code&gt; and &lt;code&gt;MonadTrans&lt;/code&gt;
instance. So let’s assume we have those instances.&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb10-1"&gt;&lt;a href="#cb10-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-2"&gt;&lt;a href="#cb10-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    return ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/span&gt;
&lt;span id="cb10-3"&gt;&lt;a href="#cb10-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-4"&gt;&lt;a href="#cb10-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;MonadTrans&lt;/span&gt; p &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-5"&gt;&lt;a href="#cb10-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    lift ::&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; p m a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The functor combinator plan is to identify your primitives, and let free
structures give you the instances (in our case, &lt;code&gt;Monad&lt;/code&gt; and
&lt;code&gt;MonadTrans&lt;/code&gt;) you need for them.&lt;/p&gt;
&lt;p&gt;So this means we only need two primitives: &lt;code&gt;yield&lt;/code&gt; and
&lt;code&gt;await&lt;/code&gt;. Then we just throw them into some machinery that gives us a
free &lt;code&gt;Monad&lt;/code&gt; and &lt;code&gt;MonadTrans&lt;/code&gt; structure, and we’re golden
:)&lt;/p&gt;
&lt;p&gt;In the style of the &lt;em&gt;&lt;a
href="https://hackage.haskell.org/package/free"&gt;free&lt;/a&gt;&lt;/em&gt; library, we’d
write base functions to get an ADT that describes the primitive actions:&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb11-1"&gt;&lt;a href="#cb11-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L22-L25&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-2"&gt;&lt;a href="#cb11-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb11-3"&gt;&lt;a href="#cb11-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i o a &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-4"&gt;&lt;a href="#cb11-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;YieldF&lt;/span&gt; o a&lt;/span&gt;
&lt;span id="cb11-5"&gt;&lt;a href="#cb11-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;AwaitF&lt;/span&gt; (&lt;span class="dt"&gt;Maybe&lt;/span&gt; i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;
&lt;span id="cb11-6"&gt;&lt;a href="#cb11-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The general structure of the base functor style is to represent each
primitive as a constructor: include any inputs, and then a continuation on what
to do if you had the result.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;For &lt;code&gt;YieldF&lt;/code&gt;, you need an &lt;code&gt;o&lt;/code&gt; to be able to yield. The
second field should really be the continuation &lt;code&gt;() -&amp;gt; a&lt;/code&gt;, since
the result is &lt;code&gt;()&lt;/code&gt;, but that’s equivalent to &lt;code&gt;a&lt;/code&gt; in
Haskell.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;AwaitF&lt;/code&gt;, you don’t need any parameters to await, but the
continuation is &lt;code&gt;Maybe i -&amp;gt; a&lt;/code&gt; since you need to specify how to
handle the &lt;code&gt;Maybe i&lt;/code&gt; result.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(This is specifically the structure that &lt;em&gt;&lt;a
href="https://hackage.haskell.org/package/free"&gt;free&lt;/a&gt;&lt;/em&gt; expects, but this
principle can be ported to any algebraic effects system.)&lt;/p&gt;
&lt;h3 id="a-christmas-surprise"&gt;A Christmas Surprise&lt;/h3&gt;
&lt;p&gt;And now for the last ingredient: we can use the &lt;code&gt;FreeT&lt;/code&gt; type from
&lt;em&gt;&lt;a
href="https://hackage.haskell.org/package/free/docs/Control-Monad-Trans-Free.html"&gt;Control.Monad.Trans.Free&lt;/a&gt;&lt;/em&gt;,
and now we have our pipe interface, with a &lt;code&gt;Monad&lt;/code&gt; and
&lt;code&gt;MonadTrans&lt;/code&gt; instance!&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb12-1"&gt;&lt;a href="#cb12-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; (&lt;span class="dt"&gt;PipeF&lt;/span&gt; i o)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This takes our base functor and imbues it with a full &lt;code&gt;Monad&lt;/code&gt; and
&lt;code&gt;MonadTrans&lt;/code&gt; instance:&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb13-1"&gt;&lt;a href="#cb13-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;lift ::&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; (&lt;span class="dt"&gt;PipeF&lt;/span&gt; i o) m a&lt;/span&gt;
&lt;span id="cb13-2"&gt;&lt;a href="#cb13-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;lift ::&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a&lt;/span&gt;
&lt;span id="cb13-3"&gt;&lt;a href="#cb13-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb13-4"&gt;&lt;a href="#cb13-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="fu"&gt;return&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; (&lt;span class="dt"&gt;PipeF&lt;/span&gt; i o) m a&lt;/span&gt;
&lt;span id="cb13-5"&gt;&lt;a href="#cb13-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="fu"&gt;return&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a&lt;/span&gt;
&lt;span id="cb13-6"&gt;&lt;a href="#cb13-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb13-7"&gt;&lt;a href="#cb13-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;(&amp;gt;&amp;gt;)  ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b&lt;/span&gt;
&lt;span id="cb13-8"&gt;&lt;a href="#cb13-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;(&amp;gt;&amp;gt;=) ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That’s the essence of the free structure: it &lt;em&gt;adds&lt;/em&gt; to our base
functor (&lt;code&gt;PipeF&lt;/code&gt;) exactly the structure it needs to be able to
implement the instances it is free on. And it’s all free as in beer! :D&lt;/p&gt;
&lt;p&gt;As a bonus gift, we also get a &lt;code&gt;MonadIO&lt;/code&gt; instance from
&lt;code&gt;FreeT&lt;/code&gt;, as well:&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb14-1"&gt;&lt;a href="#cb14-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;liftIO ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; (&lt;span class="dt"&gt;PipeF&lt;/span&gt; i o) m a&lt;/span&gt;
&lt;span id="cb14-2"&gt;&lt;a href="#cb14-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;liftIO ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we just need our functions to lift our primitives to &lt;code&gt;Pipe&lt;/code&gt;,
using &lt;code&gt;liftF :: f a -&amp;gt; FreeT f m a&lt;/code&gt;:&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb15-1"&gt;&lt;a href="#cb15-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L29-L33&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb15-2"&gt;&lt;a href="#cb15-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb15-3"&gt;&lt;a href="#cb15-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;yield ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m ()&lt;/span&gt;
&lt;span id="cb15-4"&gt;&lt;a href="#cb15-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;yield x &lt;span class="ot"&gt;=&lt;/span&gt; liftF &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;YieldF&lt;/span&gt; x ()&lt;/span&gt;
&lt;span id="cb15-5"&gt;&lt;a href="#cb15-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb15-6"&gt;&lt;a href="#cb15-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;await ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m (&lt;span class="dt"&gt;Maybe&lt;/span&gt; i)&lt;/span&gt;
&lt;span id="cb15-7"&gt;&lt;a href="#cb15-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;await &lt;span class="ot"&gt;=&lt;/span&gt; liftF &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;AwaitF&lt;/span&gt; &lt;span class="fu"&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(these things you can usually just fill in using type tetris, filling in
values with typed holes into they typecheck).&lt;/p&gt;
&lt;p&gt;Note that all of the individual pipes we had planned work as-is! And we can
even even make &lt;code&gt;sourceHandle&lt;/code&gt; and &lt;code&gt;sinkStdout&lt;/code&gt; work for
any &lt;code&gt;MonadIO m =&amp;gt; Pipe i o m a&lt;/code&gt;, because of the unexpected
surprise Christmas gift we got (the &lt;code&gt;MonadIO&lt;/code&gt; instance and
&lt;code&gt;liftIO :: MonadIO m =&amp;gt; IO a -&amp;gt; Pipe i o u m a&lt;/code&gt;). Remember,
&lt;code&gt;MonadIO m&lt;/code&gt; is basically any &lt;code&gt;m&lt;/code&gt; that supports doing
IO.&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb16-1"&gt;&lt;a href="#cb16-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L74-L119&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-2"&gt;&lt;a href="#cb16-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb16-3"&gt;&lt;a href="#cb16-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;sourceHandle ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Handle&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i &lt;span class="dt"&gt;String&lt;/span&gt; m ()&lt;/span&gt;
&lt;span id="cb16-4"&gt;&lt;a href="#cb16-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;sourceHandle handle &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-5"&gt;&lt;a href="#cb16-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    res &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; liftIO &lt;span class="op"&gt;$&lt;/span&gt; tryJust (guard &lt;span class="op"&gt;.&lt;/span&gt; isEOFError) (hGetLine handle)&lt;/span&gt;
&lt;span id="cb16-6"&gt;&lt;a href="#cb16-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; res &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-7"&gt;&lt;a href="#cb16-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Left&lt;/span&gt;  _   &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;return&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb16-8"&gt;&lt;a href="#cb16-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Right&lt;/span&gt; out &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-9"&gt;&lt;a href="#cb16-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        yield out&lt;/span&gt;
&lt;span id="cb16-10"&gt;&lt;a href="#cb16-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        sourceHandle handle&lt;/span&gt;
&lt;span id="cb16-11"&gt;&lt;a href="#cb16-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb16-12"&gt;&lt;a href="#cb16-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;sinkStdout ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; o m ()&lt;/span&gt;
&lt;span id="cb16-13"&gt;&lt;a href="#cb16-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;sinkStdout &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-14"&gt;&lt;a href="#cb16-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    inp &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/span&gt;
&lt;span id="cb16-15"&gt;&lt;a href="#cb16-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; inp &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-16"&gt;&lt;a href="#cb16-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb16-17"&gt;&lt;a href="#cb16-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Just&lt;/span&gt; x  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-18"&gt;&lt;a href="#cb16-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        liftIO &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb16-19"&gt;&lt;a href="#cb16-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        sinkStdout&lt;/span&gt;
&lt;span id="cb16-20"&gt;&lt;a href="#cb16-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb16-21"&gt;&lt;a href="#cb16-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;toUpperPipe ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; m ()&lt;/span&gt;
&lt;span id="cb16-22"&gt;&lt;a href="#cb16-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;toUpperPipe &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-23"&gt;&lt;a href="#cb16-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    inp &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/span&gt;
&lt;span id="cb16-24"&gt;&lt;a href="#cb16-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; inp &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-25"&gt;&lt;a href="#cb16-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb16-26"&gt;&lt;a href="#cb16-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Just&lt;/span&gt; x  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-27"&gt;&lt;a href="#cb16-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        yield (&lt;span class="fu"&gt;map&lt;/span&gt; &lt;span class="fu"&gt;toUpper&lt;/span&gt; x)&lt;/span&gt;
&lt;span id="cb16-28"&gt;&lt;a href="#cb16-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        toUpperPipe&lt;/span&gt;
&lt;span id="cb16-29"&gt;&lt;a href="#cb16-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb16-30"&gt;&lt;a href="#cb16-30" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;untilSTOP ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; m ()&lt;/span&gt;
&lt;span id="cb16-31"&gt;&lt;a href="#cb16-31" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;untilSTOP &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-32"&gt;&lt;a href="#cb16-32" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    inp &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/span&gt;
&lt;span id="cb16-33"&gt;&lt;a href="#cb16-33" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; inp &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-34"&gt;&lt;a href="#cb16-34" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb16-35"&gt;&lt;a href="#cb16-35" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Just&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb16-36"&gt;&lt;a href="#cb16-36" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="op"&gt;|&lt;/span&gt; x &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;STOP&amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb16-37"&gt;&lt;a href="#cb16-37" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="fu"&gt;otherwise&lt;/span&gt;   &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-38"&gt;&lt;a href="#cb16-38" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            yield x&lt;/span&gt;
&lt;span id="cb16-39"&gt;&lt;a href="#cb16-39" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            untilSTOP&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That’s because using &lt;code&gt;FreeT&lt;/code&gt;, we imbue the structure required to
do monadic chaining (do notation) and MonadTrans (&lt;code&gt;lift&lt;/code&gt;) and MonadIO
(&lt;code&gt;liftIO&lt;/code&gt;) for free!&lt;/p&gt;
&lt;p&gt;To “run” our pipes, we can use &lt;code&gt;FreeT&lt;/code&gt;’s “interpreter” function.
This follows the same pattern as for many free structures: specify how to handle
each individual base functor constructor, and it then gives you a handler to
handle the entire thing.&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb17-1"&gt;&lt;a href="#cb17-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;iterT&lt;/span&gt;
&lt;span id="cb17-2"&gt;&lt;a href="#cb17-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    ::&lt;/span&gt; (&lt;span class="dt"&gt;PipeF&lt;/span&gt; i o (m a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a)  &lt;span class="co"&gt;-- ^ given a way to handle each base functor constructor ...&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-3"&gt;&lt;a href="#cb17-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a       &lt;span class="co"&gt;-- ^ here&amp;#39;s a way to handle the whole thing&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So let’s write our base functor handler. Remember that we established earlier
we can only “run” a &lt;code&gt;Pipe () Void m a&lt;/code&gt;: that is, pipes where
&lt;code&gt;await&lt;/code&gt; can always be fed with no information (&lt;code&gt;()&lt;/code&gt;) and
no &lt;code&gt;yield&lt;/code&gt; is ever called (because you cannot yield with
&lt;code&gt;Void&lt;/code&gt;, a type with no inhabitants). We can directly translate this
to how we handle each constructor:&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb18-1"&gt;&lt;a href="#cb18-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L57-L60&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-2"&gt;&lt;a href="#cb18-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb18-3"&gt;&lt;a href="#cb18-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;handlePipeF ::&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; () &lt;span class="dt"&gt;Void&lt;/span&gt; (m a) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/span&gt;
&lt;span id="cb18-4"&gt;&lt;a href="#cb18-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;handlePipeF &lt;span class="ot"&gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-5"&gt;&lt;a href="#cb18-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;YieldF&lt;/span&gt; o _ &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; absurd o&lt;/span&gt;
&lt;span id="cb18-6"&gt;&lt;a href="#cb18-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;AwaitF&lt;/span&gt; f   &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class="dt"&gt;Just&lt;/span&gt; ())&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And so we get our full &lt;code&gt;runPipe&lt;/code&gt;:&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb19-1"&gt;&lt;a href="#cb19-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L62-L63&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb19-2"&gt;&lt;a href="#cb19-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb19-3"&gt;&lt;a href="#cb19-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runPipe ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; () &lt;span class="dt"&gt;Void&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/span&gt;
&lt;span id="cb19-4"&gt;&lt;a href="#cb19-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runPipe &lt;span class="ot"&gt;=&lt;/span&gt; iterT handlePipeF&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I think this process exemplifies most of the major beats when working with
free structures:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Define the base functor&lt;/li&gt;
&lt;li&gt;Allow the free structure to imbue the proper structure over your base
functor&lt;/li&gt;
&lt;li&gt;Write your interpreter to interpret the constructors of your base functor,
and the free structure will give you a way to interpret the entire
structure.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="the-final-ornament"&gt;The Final Ornament&lt;/h3&gt;
&lt;p&gt;If you look at the list of all the things we wanted, we’re still missing one
thing: pipe composition/input-output chaining. That’s because it isn’t a
primitive operation (like yield or await), and it wasn’t given to us for free by
our free structure (&lt;code&gt;FreeT&lt;/code&gt;, which gave us monadic composition and
monad transformer ability). So with how we have currently written it, there
isn’t any way of getting around writing &lt;code&gt;(.|)&lt;/code&gt; manually. So let’s
roll up our sleeves and do the (admittedly minimal amount of) dirty work.&lt;/p&gt;
&lt;p&gt;Let’s think about the semantics of our pipe chaining. We want to never do
more work than we need to do, so we’ll be “pull-based”: for &lt;code&gt;f .| g&lt;/code&gt;,
try running &lt;code&gt;g&lt;/code&gt; as much as possible until it awaits anything from
&lt;code&gt;f&lt;/code&gt;. Only then do we try doing &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To implement this, we’re going to have to dig in a little bit to the
implementation/structure of &lt;code&gt;FreeT&lt;/code&gt;:&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb20-1"&gt;&lt;a href="#cb20-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; f m a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-2"&gt;&lt;a href="#cb20-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    {&lt;span class="ot"&gt; runFreeT ::&lt;/span&gt; m (&lt;span class="dt"&gt;FreeF&lt;/span&gt; f a (&lt;span class="dt"&gt;FreeT&lt;/span&gt; f m a)) }&lt;/span&gt;
&lt;span id="cb20-3"&gt;&lt;a href="#cb20-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb20-4"&gt;&lt;a href="#cb20-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;FreeF&lt;/span&gt; f a b&lt;/span&gt;
&lt;span id="cb20-5"&gt;&lt;a href="#cb20-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Pure&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb20-6"&gt;&lt;a href="#cb20-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Free&lt;/span&gt; (f b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This does look a little complicated, and on the face of it, it can be a bit
intimidating. And why is there a second internal data type?&lt;/p&gt;
&lt;p&gt;Well, you can think of &lt;code&gt;FreeF f a b&lt;/code&gt; as being a fancy version of
&lt;code&gt;Either a (f b)&lt;/code&gt;. And the implementation of &lt;code&gt;FreeT&lt;/code&gt; is
saying that &lt;code&gt;FreeT f m a&lt;/code&gt; is &lt;em&gt;an m-action&lt;/em&gt; that produces
&lt;code&gt;Either a (FreeT f m a)&lt;/code&gt;. So for example, &lt;code&gt;FreeT f IO a&lt;/code&gt;
is an IO action that produces &lt;em&gt;either&lt;/em&gt; the &lt;code&gt;a&lt;/code&gt; (we’re done,
end here!) or a &lt;code&gt;f (FreeT f m a))&lt;/code&gt; (we have to handle an
&lt;code&gt;f&lt;/code&gt; here!)&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb21-1"&gt;&lt;a href="#cb21-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; f m a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb21-2"&gt;&lt;a href="#cb21-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    {&lt;span class="ot"&gt; runFreeT ::&lt;/span&gt; m (&lt;span class="dt"&gt;Either&lt;/span&gt; a (f (&lt;span class="dt"&gt;FreeT&lt;/span&gt; f m a))) }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At the top level, &lt;code&gt;FreeT&lt;/code&gt; is an action in the underlying monad
(just like &lt;code&gt;MaybeT&lt;/code&gt;, &lt;code&gt;ExceptT&lt;/code&gt;, &lt;code&gt;StateT&lt;/code&gt;,
etc.). Let’s take that into account and write our implementation (with a hefty
bit of help from the typechecker and typed holes)! Remember our plan: for
&lt;code&gt;f .| g&lt;/code&gt;, &lt;em&gt;start unrolling &lt;code&gt;g&lt;/code&gt;&lt;/em&gt; until it needs
anything, and then ask &lt;code&gt;f&lt;/code&gt; when it does.&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb22-1"&gt;&lt;a href="#cb22-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;(&lt;span class="op"&gt;.|&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb22-2"&gt;&lt;a href="#cb22-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m&lt;/span&gt;
&lt;span id="cb22-3"&gt;&lt;a href="#cb22-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; a b m x         &lt;span class="co"&gt;-- ^ pipe from a -&amp;gt; b&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-4"&gt;&lt;a href="#cb22-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; b c m y         &lt;span class="co"&gt;-- ^ pipe from b -&amp;gt; c&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-5"&gt;&lt;a href="#cb22-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; a c m y         &lt;span class="co"&gt;-- ^ pipe from a -&amp;gt; c&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-6"&gt;&lt;a href="#cb22-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pf &lt;span class="op"&gt;.|&lt;/span&gt; pg &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-7"&gt;&lt;a href="#cb22-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    gRes &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="op"&gt;$&lt;/span&gt; runFreeT pg          &lt;span class="co"&gt;-- 1&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-8"&gt;&lt;a href="#cb22-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; gRes &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-9"&gt;&lt;a href="#cb22-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Pure&lt;/span&gt; x            &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; x       &lt;span class="co"&gt;-- 2&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-10"&gt;&lt;a href="#cb22-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Free&lt;/span&gt; (&lt;span class="dt"&gt;YieldF&lt;/span&gt; o x) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;           &lt;span class="co"&gt;-- 3&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-11"&gt;&lt;a href="#cb22-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        yield o&lt;/span&gt;
&lt;span id="cb22-12"&gt;&lt;a href="#cb22-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        pf &lt;span class="op"&gt;.|&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb22-13"&gt;&lt;a href="#cb22-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;      &lt;span class="dt"&gt;Free&lt;/span&gt; (&lt;span class="dt"&gt;AwaitF&lt;/span&gt; g  ) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;           &lt;span class="co"&gt;-- 4&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-14"&gt;&lt;a href="#cb22-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        fRes &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="op"&gt;$&lt;/span&gt; runFreeT pf&lt;/span&gt;
&lt;span id="cb22-15"&gt;&lt;a href="#cb22-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="kw"&gt;case&lt;/span&gt; fRes &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-16"&gt;&lt;a href="#cb22-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          &lt;span class="dt"&gt;Pure&lt;/span&gt; _            &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; () &lt;span class="op"&gt;.|&lt;/span&gt; g &lt;span class="dt"&gt;Nothing&lt;/span&gt;     &lt;span class="co"&gt;-- 5&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-17"&gt;&lt;a href="#cb22-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          &lt;span class="dt"&gt;Free&lt;/span&gt; (&lt;span class="dt"&gt;YieldF&lt;/span&gt; o y) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; y       &lt;span class="op"&gt;.|&lt;/span&gt; g (&lt;span class="dt"&gt;Just&lt;/span&gt; o)    &lt;span class="co"&gt;-- 6&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-18"&gt;&lt;a href="#cb22-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;          &lt;span class="dt"&gt;Free&lt;/span&gt; (&lt;span class="dt"&gt;AwaitF&lt;/span&gt; f  ) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;                       &lt;span class="co"&gt;-- 7&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-19"&gt;&lt;a href="#cb22-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            i &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; await&lt;/span&gt;
&lt;span id="cb22-20"&gt;&lt;a href="#cb22-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            f i &lt;span class="op"&gt;.|&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; (&lt;span class="fu"&gt;pure&lt;/span&gt; gRes)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here are some numbered notes and comments:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Start unrolling the downstream pipe &lt;code&gt;pg&lt;/code&gt;, in the underlying monad
&lt;code&gt;m&lt;/code&gt;!&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;pg&lt;/code&gt; produced &lt;code&gt;Pure x&lt;/code&gt;, it means we’re done pulling
anything. The entire pipe has terminated, since we will never need anything
again. So just quit out with &lt;code&gt;pure x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;pg&lt;/code&gt; produced &lt;code&gt;Free (YieldF o x)&lt;/code&gt;, it means it’s
yielding an &lt;code&gt;o&lt;/code&gt; and continuing on with &lt;code&gt;x&lt;/code&gt;. So let’s just
yield that &lt;code&gt;o&lt;/code&gt; and move on to the composition of &lt;code&gt;pf&lt;/code&gt; with
the next pipe &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;pg&lt;/code&gt; produced &lt;code&gt;Free (AwaitF g)&lt;/code&gt;, now things get
interesting. We need to unroll &lt;code&gt;pf&lt;/code&gt; until it yields some
&lt;code&gt;Maybe b&lt;/code&gt;, and feed that to
&lt;code&gt;g :: Maybe b     -&amp;gt; Pipe b c m y&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;pf&lt;/code&gt; produced &lt;code&gt;Pure y&lt;/code&gt;, that means it was done! The
upstream terminated, so the downstream will have to terminate as well. So
&lt;code&gt;g&lt;/code&gt; gets a &lt;code&gt;Nothing&lt;/code&gt;, and we move from there. Note we have
to compose with a dummy pipe &lt;code&gt;pure ()&lt;/code&gt; to make the types match up
properly.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;pf&lt;/code&gt; produced &lt;code&gt;YieldF o y&lt;/code&gt;, then we have found our
match! So give &lt;code&gt;g     (Just o)&lt;/code&gt;, and now we recursively compose the
next pipe (&lt;code&gt;y&lt;/code&gt;) with the that &lt;code&gt;g&lt;/code&gt; gave us.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;pf&lt;/code&gt; produced &lt;code&gt;AwaitF f&lt;/code&gt;, then we’re in a bind,
aren’t we? We now have two layers waiting for something further upstream. So, we
await from &lt;em&gt;even further&lt;/em&gt; upstream; when we get it, we feed it to
&lt;code&gt;f&lt;/code&gt; and then compose &lt;code&gt;f i     :: Pipe a b m x&lt;/code&gt; with
&lt;code&gt;pg&lt;/code&gt;’s result (wrapping up &lt;code&gt;gRes&lt;/code&gt; back into a
&lt;code&gt;FreeT&lt;/code&gt;/&lt;code&gt;Pipe&lt;/code&gt; so the types match up).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Admittedly (!) this is the “ugly” part of this derivation: sometimes we just
can’t get everything for free. But getting the Monad, Applicative, Functor,
MonadTrans, etc. instances is probably nice enough to justify this inconvenience
:) And who knows, there might be a free structure that I don’t know about that
gives us all of these &lt;em&gt;plus&lt;/em&gt; piping for free.&lt;/p&gt;
&lt;h3 id="christmas-miracle"&gt;Christmas Miracle&lt;/h3&gt;
&lt;p&gt;It runs!&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb23-1"&gt;&lt;a href="#cb23-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L128-L133&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb23-2"&gt;&lt;a href="#cb23-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb23-3"&gt;&lt;a href="#cb23-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;samplePipe ::&lt;/span&gt; &lt;span class="dt"&gt;Handle&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb23-4"&gt;&lt;a href="#cb23-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;samplePipe handle &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb23-5"&gt;&lt;a href="#cb23-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;       sourceHandle handle&lt;/span&gt;
&lt;span id="cb23-6"&gt;&lt;a href="#cb23-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; untilSTOP&lt;/span&gt;
&lt;span id="cb23-7"&gt;&lt;a href="#cb23-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; toUpperPipe&lt;/span&gt;
&lt;span id="cb23-8"&gt;&lt;a href="#cb23-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; sinkStdout&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;$ cat testpipefile.txt
hello
world
STOP
okay
goodbye&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb25-1"&gt;&lt;a href="#cb25-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;ghci&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; withFile &lt;span class="st"&gt;&amp;quot;testpipefile.txt&amp;quot;&lt;/span&gt; &lt;span class="dt"&gt;ReadMode&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; \handle &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb25-2"&gt;&lt;a href="#cb25-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        runPipe (samplePipe handle)&lt;/span&gt;
&lt;span id="cb25-3"&gt;&lt;a href="#cb25-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- HELLO&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb25-4"&gt;&lt;a href="#cb25-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- WORLD&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Smooth as silk :D&lt;/p&gt;
&lt;h2 id="takeways-for-a-happy-new-year"&gt;Takeways for a Happy New Year&lt;/h2&gt;
&lt;p&gt;Most of this post was thought up when I needed&lt;a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; a tool that
was &lt;em&gt;sort of&lt;/em&gt; like conduit, &lt;em&gt;sort of&lt;/em&gt; like pipes, &lt;em&gt;sort of&lt;/em&gt;
like the other libraries…and I thought I had to read up on the theory of pipes
and iteratees and trampolines and fancy pants math stuff to be able to make
anything useful in this space. I remember being very discouraged when I read
about this stuff as a wee new Haskeller, because the techniques seemed so
foreign and out of the range of my normal Haskell experience.&lt;/p&gt;
&lt;p&gt;However, I found a way to maintain a level head somehow, and just thought —
“ok, I just need a monad (trans) with two primitive actions: await, and yield.
Why don’t I just make an await and yield and get automatic &lt;code&gt;Monad&lt;/code&gt;
and &lt;code&gt;MonadTrans&lt;/code&gt; instances with the appropriate free structure?”&lt;/p&gt;
&lt;p&gt;As we can see…this works just fine! We only needed to implement one extra
thing (&lt;code&gt;.|&lt;/code&gt;) to get the interface of our dreams. Of course, for a
real industrial-strength streaming combinator library, we might need to be a bit
more careful. But for my learning experience and use case, it worked
perfectly.&lt;/p&gt;
&lt;p&gt;The next time you need to make some monad that might seem exotic, try this
out and see if it works for you :)&lt;/p&gt;
&lt;p&gt;Happy holidays, and merry Christmas!&lt;/p&gt;
&lt;h2 id="exercises"&gt;Exercises&lt;/h2&gt;
&lt;p&gt;Click on the links in the corner of the text boxes for solutions! (or just
check out &lt;a
href="https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs"&gt;the
source file&lt;/a&gt;)&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;An &lt;code&gt;Pipe i o m a&lt;/code&gt; “takes” &lt;code&gt;i&lt;/code&gt; and “produces”
&lt;code&gt;o&lt;/code&gt;, so it should make sense to make pre-map and post-map
functions:&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb26-1"&gt;&lt;a href="#cb26-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L148-L151&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-2"&gt;&lt;a href="#cb26-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb26-3"&gt;&lt;a href="#cb26-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;postMap ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; o&amp;#39;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o&amp;#39; m a&lt;/span&gt;
&lt;span id="cb26-4"&gt;&lt;a href="#cb26-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb26-5"&gt;&lt;a href="#cb26-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;preMap ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (i&amp;#39; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; i) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i&amp;#39; o m a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That pre-maps all inputs the pipe would receive, and post-maps all of the
values it yields.&lt;/p&gt;
&lt;p&gt;Hint: This actually is made a lot simpler to write with the handy
&lt;code&gt;transFreeT&lt;/code&gt; combinator, which lets you swap out/change the base
functor:&lt;/p&gt;
&lt;div class="sourceCode" id="cb27"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb27-1"&gt;&lt;a href="#cb27-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;transFreeT&lt;/span&gt;
&lt;span id="cb27-2"&gt;&lt;a href="#cb27-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    ::&lt;/span&gt; (&lt;span class="kw"&gt;forall&lt;/span&gt; a&lt;span class="op"&gt;.&lt;/span&gt; f a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; g a)     &lt;span class="co"&gt;-- ^ polymorphic function to edit the base functor&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-3"&gt;&lt;a href="#cb27-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; f m b&lt;/span&gt;
&lt;span id="cb27-4"&gt;&lt;a href="#cb27-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; g m b&lt;/span&gt;
&lt;span id="cb27-5"&gt;&lt;a href="#cb27-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb27-6"&gt;&lt;a href="#cb27-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;transFreeT&lt;/span&gt;
&lt;span id="cb27-7"&gt;&lt;a href="#cb27-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    ::&lt;/span&gt; (&lt;span class="kw"&gt;forall&lt;/span&gt; a&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i o a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i&amp;#39; o&amp;#39; a)  &lt;span class="co"&gt;-- ^ polymorphic function to edit the base functor&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-8"&gt;&lt;a href="#cb27-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i  o  m a&lt;/span&gt;
&lt;span id="cb27-9"&gt;&lt;a href="#cb27-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i&amp;#39; o&amp;#39; m a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could then write pre-map and post-map function on &lt;code&gt;PipeF&lt;/code&gt; and
translate them to &lt;code&gt;Pipe&lt;/code&gt; using &lt;code&gt;transFreeT&lt;/code&gt;:&lt;/p&gt;
&lt;div class="sourceCode" id="cb28"&gt;&lt;pre
class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb28-1"&gt;&lt;a href="#cb28-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L140-L152&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb28-2"&gt;&lt;a href="#cb28-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb28-3"&gt;&lt;a href="#cb28-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;postMapF ::&lt;/span&gt; (o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; o&amp;#39;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i o a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i o&amp;#39; a&lt;/span&gt;
&lt;span id="cb28-4"&gt;&lt;a href="#cb28-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb28-5"&gt;&lt;a href="#cb28-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;preMapF ::&lt;/span&gt; (i&amp;#39; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; i) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i o a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i&amp;#39; o a&lt;/span&gt;
&lt;span id="cb28-6"&gt;&lt;a href="#cb28-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb28-7"&gt;&lt;a href="#cb28-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;postMap ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; o&amp;#39;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o&amp;#39; m a&lt;/span&gt;
&lt;span id="cb28-8"&gt;&lt;a href="#cb28-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;postMap f &lt;span class="ot"&gt;=&lt;/span&gt; transFreeT (postMapF f)&lt;/span&gt;
&lt;span id="cb28-9"&gt;&lt;a href="#cb28-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb28-10"&gt;&lt;a href="#cb28-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;preMap ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (i&amp;#39; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; i) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i&amp;#39; o m a&lt;/span&gt;
&lt;span id="cb28-11"&gt;&lt;a href="#cb28-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;preMap f &lt;span class="ot"&gt;=&lt;/span&gt; transFreeT (preMapF f)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One staple of a streaming combinator system is giving you a disciplined
way to handle resources allocations like file handlers and properly close them
on completion. Our streaming combinator system has no inherent way of doing this
within its structure, but we can take advantage of the &lt;em&gt;&lt;a
href="https://hackage.haskell.org/package/resourcet"&gt;resourcet&lt;/a&gt;&lt;/em&gt; package
to handle it for us.&lt;/p&gt;
&lt;p&gt;Basically, if we run our pipes over &lt;code&gt;ResourceT IO&lt;/code&gt; instead of
normal &lt;code&gt;IO&lt;/code&gt;, we get an extra action &lt;code&gt;allocate&lt;/code&gt;:&lt;/p&gt;
&lt;div class="sourceCode" id="cb29"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb29-1"&gt;&lt;a href="#cb29-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;allocate&lt;/span&gt;
&lt;span id="cb29-2"&gt;&lt;a href="#cb29-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; a             &lt;span class="co"&gt;-- ^ get a handler&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb29-3"&gt;&lt;a href="#cb29-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ())     &lt;span class="co"&gt;-- ^ close a handler&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb29-4"&gt;&lt;a href="#cb29-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ResourceT&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;ResourceKey&lt;/span&gt;, a)&lt;/span&gt;
&lt;span id="cb29-5"&gt;&lt;a href="#cb29-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb29-6"&gt;&lt;a href="#cb29-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- example&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb29-7"&gt;&lt;a href="#cb29-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;allocate (openFile fp &lt;span class="dt"&gt;ReadMode&lt;/span&gt;) hClose&lt;/span&gt;
&lt;span id="cb29-8"&gt;&lt;a href="#cb29-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    ::&lt;/span&gt; &lt;span class="dt"&gt;ResourceT&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;ResourceKey&lt;/span&gt;, &lt;span class="dt"&gt;Handler&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use this in our pipe to open a handler from a filename, and rest
assured that the file handler will be closed when we eventually
&lt;code&gt;runResourceT :: ResourceT IO a -&amp;gt; IO a&lt;/code&gt; our pipe.&lt;/p&gt;
&lt;div class="sourceCode" id="cb30"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb30-1"&gt;&lt;a href="#cb30-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L155-L165&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb30-2"&gt;&lt;a href="#cb30-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-3"&gt;&lt;a href="#cb30-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;sourceFile ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i &lt;span class="dt"&gt;String&lt;/span&gt; (&lt;span class="dt"&gt;ResourceT&lt;/span&gt; m) ()&lt;/span&gt;
&lt;span id="cb30-4"&gt;&lt;a href="#cb30-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-5"&gt;&lt;a href="#cb30-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;samplePipe2 ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o (&lt;span class="dt"&gt;ResourceT&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;) ()&lt;/span&gt;
&lt;span id="cb30-6"&gt;&lt;a href="#cb30-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;samplePipe2 fp &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb30-7"&gt;&lt;a href="#cb30-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;       sourceFile fp&lt;/span&gt;
&lt;span id="cb30-8"&gt;&lt;a href="#cb30-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; untilSTOP&lt;/span&gt;
&lt;span id="cb30-9"&gt;&lt;a href="#cb30-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; toUpperPipe&lt;/span&gt;
&lt;span id="cb30-10"&gt;&lt;a href="#cb30-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;.|&lt;/span&gt; hoistFreeT lift sinkStdout&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb31"&gt;&lt;pre
class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb31-1"&gt;&lt;a href="#cb31-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;ghci&lt;span class="op"&gt;&amp;gt;&lt;/span&gt; runResourceT &lt;span class="op"&gt;.&lt;/span&gt; runPipe &lt;span class="op"&gt;$&lt;/span&gt; samplePipe2 &lt;span class="st"&gt;&amp;quot;testpipefile.txt&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb31-2"&gt;&lt;a href="#cb31-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- HELLO&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb31-3"&gt;&lt;a href="#cb31-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- WORLD&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let’s say we modified our &lt;code&gt;PipeF&lt;/code&gt; slightly to take another
parameter &lt;code&gt;u&lt;/code&gt;, the result type of the upstream pipe.&lt;/p&gt;
&lt;div class="sourceCode" id="cb32"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb32-1"&gt;&lt;a href="#cb32-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;PipeF&lt;/span&gt; i o u a &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb32-2"&gt;&lt;a href="#cb32-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;YieldF&lt;/span&gt; o a&lt;/span&gt;
&lt;span id="cb32-3"&gt;&lt;a href="#cb32-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;AwaitF&lt;/span&gt; (&lt;span class="dt"&gt;Either&lt;/span&gt; u i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;
&lt;span id="cb32-4"&gt;&lt;a href="#cb32-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb32-5"&gt;&lt;a href="#cb32-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o u &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FreeT&lt;/span&gt; (&lt;span class="dt"&gt;PipeF&lt;/span&gt; i o u)&lt;/span&gt;
&lt;span id="cb32-6"&gt;&lt;a href="#cb32-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb32-7"&gt;&lt;a href="#cb32-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;await ::&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m (&lt;span class="dt"&gt;Either&lt;/span&gt; u i)&lt;/span&gt;
&lt;span id="cb32-8"&gt;&lt;a href="#cb32-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;await &lt;span class="ot"&gt;=&lt;/span&gt; liftF &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;AwaitF&lt;/span&gt; &lt;span class="fu"&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So now &lt;code&gt;await&lt;/code&gt; would be fed &lt;code&gt;i&lt;/code&gt; things yielded from
upstream, but sometimes you’d get a &lt;code&gt;Left&lt;/code&gt; indicating that the
upstream pipe has terminated.&lt;/p&gt;
&lt;p&gt;What would be the implications if &lt;code&gt;u&lt;/code&gt; is &lt;code&gt;Void&lt;/code&gt;?&lt;/p&gt;
&lt;div class="sourceCode" id="cb33"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb33-1"&gt;&lt;a href="#cb33-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CertainPipe&lt;/span&gt; i o &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o &lt;span class="dt"&gt;Void&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What could you do in a &lt;code&gt;CertainPipe i o m a&lt;/code&gt; that you couldn’t
normally do with our &lt;code&gt;Pipe i o m a&lt;/code&gt;?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We mentioned earlier that a “source” could have type&lt;/p&gt;
&lt;div class="sourceCode" id="cb34"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb34-1"&gt;&lt;a href="#cb34-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Source&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; ()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a &lt;code&gt;Source o m a&lt;/code&gt; would be something that keeps on pumping out
&lt;code&gt;o&lt;/code&gt;s as much as we need, without requiring any upstream input.&lt;/p&gt;
&lt;p&gt;This is actually the essential behavior of the (true) list monad transformer,
as esposed by the &lt;em&gt;&lt;a
href="https://hackage.haskell.org/package/list-transformer"&gt;list-transformer&lt;/a&gt;&lt;/em&gt;
package.&lt;/p&gt;
&lt;p&gt;In that package, &lt;code&gt;ListT&lt;/code&gt; is defined as:&lt;/p&gt;
&lt;div class="sourceCode" id="cb35"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb35-1"&gt;&lt;a href="#cb35-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;ListT&lt;/span&gt; m a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ListT&lt;/span&gt; {&lt;span class="ot"&gt; next ::&lt;/span&gt; m (&lt;span class="dt"&gt;Step&lt;/span&gt; m a) }&lt;/span&gt;
&lt;span id="cb35-2"&gt;&lt;a href="#cb35-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb35-3"&gt;&lt;a href="#cb35-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Step&lt;/span&gt; m a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; a (&lt;span class="dt"&gt;ListT&lt;/span&gt; m a) &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And it’s a type that can yield out new &lt;code&gt;a&lt;/code&gt;s on-demand, until
exhausted.&lt;/p&gt;
&lt;p&gt;In fact, &lt;code&gt;Source o m ()&lt;/code&gt; is equivalent to &lt;code&gt;ListT m o&lt;/code&gt;.
Write the functions to convert between them! :D&lt;/p&gt;
&lt;div class="sourceCode" id="cb36"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb36-1"&gt;&lt;a href="#cb36-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L171-L179&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb36-2"&gt;&lt;a href="#cb36-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb36-3"&gt;&lt;a href="#cb36-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;toListT ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; () o m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;L.ListT&lt;/span&gt; m o&lt;/span&gt;
&lt;span id="cb36-4"&gt;&lt;a href="#cb36-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb36-5"&gt;&lt;a href="#cb36-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;fromListT ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;L.ListT&lt;/span&gt; m o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i o m ()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately we cannot use &lt;code&gt;iterT&lt;/code&gt; because the last type
parameter of each is different. But manual pattern matching (like how we wrote
&lt;code&gt;(.|)&lt;/code&gt;) isn’t too bad!&lt;/p&gt;
&lt;p&gt;The semantics of &lt;code&gt;ListT&lt;/code&gt; api is that &lt;code&gt;x &amp;lt;|&amp;gt; y&lt;/code&gt;
will “do” (and emit the result) &lt;code&gt;x&lt;/code&gt; before moving on to what
&lt;code&gt;y&lt;/code&gt; would emit. And &lt;code&gt;empty&lt;/code&gt; is the &lt;code&gt;ListT&lt;/code&gt; that
signals it is done producing. &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; and &lt;code&gt;pure&lt;/code&gt; and
&lt;code&gt;empty&lt;/code&gt; for &lt;code&gt;ListT&lt;/code&gt; are roughly analogous to
&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; for
&lt;code&gt;Source&lt;/code&gt;, respectively.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="special-thanks"&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it
possible for me to devote time to researching and writing these posts. Very
special thanks to my supporter at the “Amazing” level on &lt;a
href="https://www.patreon.com/justinle/overview"&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;“Universally quantified” here means that the pipe’s type is left
fully polymorphic (with no constraints) over &lt;code&gt;i&lt;/code&gt;, the input.&lt;a
href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;This came about when I was developing my numerical &lt;em&gt;&lt;a
href="https://hackage.haskell.org/package/emd"&gt;emd&lt;/a&gt;&lt;/em&gt; library.&lt;a
href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/holly-jolly-streaming-combinators.html</guid><pubDate>Sun, 13 Dec 2020 00:00:00 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-12-13</date></item><language>en</language><copyright>Copyright 2020 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Fri, 26 Jul 2024 19:06:27 UTC</lastBuildDate><generator>feed-1.0.0.0 (Sigbjorn Finne)</generator><image><url>https://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>https://blog.jle.im/</link></image><creator>Justin Le</creator><language>en</language><rights>Copyright 2020 Justin Le</rights><date>2024-07-26</date><description>Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
</description></channel></rss>