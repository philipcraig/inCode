\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Blog Rewrite with Hakyll and Purescript},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Blog Rewrite with Hakyll and Purescript}

\begin{document}
\maketitle

\% Justin Le \% March 25, 2016

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html}{in
Code}}.}

It's been almost a year since my last post! Things have been a bit hectic with
research and related things, and with the unrelenting academia publishing cycle,
any time I can get to write or explore has been a nice escape.

Admittedly, I've also run into some friction updating my blog because it was a
compiled web server with some delicate dependencies and required environment
configuration to build/deploy. It was written/built at a time when a lot of the
infrastructure we have now in the Haskell ecosystem either wasn't there, or
wasn't mature. We didn't have easy \href{https://haskellonheroku.com/}{Heroku
deployment}, and we didn't have great tools like
\href{http://haskellstack.org/}{stack} to let us create reproducible builds. One
of my
\href{http://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku.html}{first
posts} in 2013 was actually about hoops to jump through \emph{just} to get a
simple Heroku deployment. I've had to maintain a virtual machine just to compile
and push changes!

My blog was one of my first Haskell projects ever, and if I had started it now,
in 2016, things would definitely be a bit different. By this point, it's been
long enough and the slight inconveniences have been building up enough that I
thought it'd be time to sit down and finally migrate my ``first large-ish
Haskell project'' and bring it into modern times, by using
\href{https://jaspervdj.be/hakyll/}{hakyll} and
\href{http://www.purescript.org/}{purescript}. Here are my thoughts and
observations on how the migration went, with insight on Haskell migrations in
general!

My blog engine is open-source, and the
\href{https://github.com/mstksg/inCode}{source for this specific instance} is up
on github, for those interested in checking it out!

\section{Hakyll}\label{hakyll}

To be honest, there was little actual practical reasons why my site wasn't
static to begin with. The main reason, feature-wise, was for me to be able to
schedule blog posts and updates without requiring me to actually re-render and
re-push every time I wanted to make a post. The real underlying reason, however,
was that this blog was my first major Haskell project, and I wanted to take the
opportunity to be able to learn how to interface with databases in Haskell.

Now that that learning impetus is behind me, I felt free to throw it all out the
window and rewrite things to be a completely 100\% static site!

\href{https://jaspervdj.be/hakyll/}{Hakyll} was great; it's basically like a
very specialized \emph{make}-like tool for building sites. It takes a bit of
time to get used to ``thinking in Hakyll'' --- generating standalone pages
instead of just ones based off of files, getting used to the identifier/snapshot
system --- but once you do, things go pretty smoothly. I started thinking about
snapshots as customized ``object files'' that you can leave behind in the
process of creating pages that other pages can use. Hakyll manages all the
dependencies for you, so pages that depend on the things left from other pages
will be sequenced properly, and rebuilding your website only requires rebuilding
pages that depend on files you changed. Neat!

Before, I had gotten the impression that Hakyll was mostly for generating
``simple'', pre-built blog layouts, but I was able to use Hakyll (without much
friction, at all) to generate the complex, intricate, and arbitrary site map
that I had designed for my
\href{http://hackage.haskell.org/package/scotty}{scotty}-based blog. I
definitely recommend it for any static site generating needs, blogs or not.

An unexpected consequence of the static-site-hosted-by-github-pages approach,
however, is that I don't have any control over MIME types anymore (or 301
redirects), so I had to do some migrations to move pages over to ``.html'' and
set up redirects and stuff (and get redirects to work with google analytics),
but those were made super simple with Hakyll.

\section{Refactoring Haskell Code}\label{refactoring-haskell-code}

One thing that did not disappoint me was how \emph{easy} and \emph{painless} it
is to refactor Haskell code. This is something I always trumpet/brag about
Haskell, and getting the opportunity to actually refactor a major-ish codebase.

And, yes, I was not disappointed! For the most part, I already had my html
templates, CSS, static javascript, etc. in place. All of the mechanisms were
extremely modular and very easy to port. The type system made sure everything
fit together well at the boundaries. They also instantly told me what did what,
and ensured that sweeping changes in my code were safe. The ``if it compiles, it
works'' mantra served me greatly here. I can't even begin to imagine migrating
one of my old ruby projects in the same way. With this, I was confident that my
compiled code was correct and did what I wanted. The types were a guide and also
a avenue of insight into my 3-years-removed past self.

Thanks to the types, I was able to pick up something I hadn't touched in 3
years, figure out how all things fit together, and completely gut everything
apart and use them for a new build system \ldots{} with compile-time assurances
that I didn't do anything incorrectly!

It's hard for me to really explain how amazing the feeling of refactoring
Haskell code is. I used to dread refactors and migrations, but now I look
forward to them and find any opportunity to do one! :D It's something that's
difficult to convey the sublime joy of until you actually try it, so I recommend
trying it some day :)

\section{Purescript}\label{purescript}

\subsection{on Fay}\label{on-fay}

With my
\href{http://blog.jle.im/entry/blog-engine-updates-markdown-preprocessor-fay-scripts.html\#fay}{last
major blog update}, I ported all of my one-off javascript scripts to fay. This
time around, I figured I'd move away from
\href{https://github.com/faylang/fay/wiki}{fay}, because it was slightly clunky
to build/get working/integrate in the way that GHCJS spoiled me to be accustomed
to. In the future, I might return \ldots{} but at this point in time, Fay seems
a bit awkward in the ecosystem. GHCJS lets you use the full power of Haskell
(including all of \emph{base}'s concurrency mechanisms and almost every library
on hackage), at the expense of creating large and unreadable javascript blobs.

Fay seemed like just a \emph{weaker} GHCJS to me, but in all the ways that
mattered. It doesn't have all of the awesome GHC things that make modern Haskell
what it is (not just the lack of base's identical API, but also \ldots{} no
typeclasses? Lens abstractions? Hackage libraries?), so almost all of my normal
Haskell programming flow is thrown out the window. It's a subset of Haskell, but
lacks most of the tools people use to write \emph{actual} Haskell like they'd
write everyday. The generated javascript blobs are still decently opaque.

So, if you're going to be spending your time writing something that is like
Haskell, but forces you to write it in a way that is nothing like any actual
Haskell code you'd normally write\ldots{} why even bother keeping up with
Haskell semantics and Haskell compatibility? Why not break out and try something
new and fresh, unbound by Haskell and compatibility
issues?\footnote{I definitely don't mean to bash on \emph{fay} here! It
  definitely has its role and place in the ecosystem. It's for my specific
  application that I was looking for an alternative with.}\footnote{There's
  another thing here that I skipped over slightly --
  \href{http://haste-lang.org/}{Haste}. I haven't had much experience with it
  myself, but for this purpose, I decided to jump into something not-Haskell and
  try out something new!}

\subsection{on Purescript}\label{on-purescript}

With that mindset, I looked at
\emph{\href{http://www.purescript.org/}{purescript}}, which is a language that's
inspired by Haskell, with a lot of Haskell features we use every day, and throws
in things we all wish we had in Haskell, like extensible records!

(Note --- I \emph{did} rewrite all of my fay in GHCJS at first. This resulted in
a javascript blob that was \emph{1.4 MB} in size for just a bunch of small DOM
manipulation scripts. Definitely not practical, unfortunately!)

I liked that purescript was able to throw away a lot of warts in the Haskell
ecosystem, with a cleaner typeclass hierarchy and just a lot of design decisions
``done right'', that we'd all change in Haskell if we could. And extensible
records being built into the language is quite refreshing; not having to deal
with fancy GADT's in Haskell was a nice step back from the craziness that is
type-level programming in Haskell. Alongside all of that, I was also able to
rely and seamlessly use a lot of Haskell idioms that we all know and love, like
lenses and traversals and compositions.

At many moments, I felt like writing in Purescript felt like writing in
\emph{the language that Haskell should have been}.

But one of my favorite aspects about purescript ended up being the sheer beauty
and conciseness of the generated javascript. Look at how\footnote{Unfortunately,
  \emph{\href{https://github.com/jgm/highlighting-kate}{highlighting-kate}}
  doesn't yet support purescript syntax highlighting?}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{appendTopLinks doc }\OtherTok{=} \KeywordTok{do}
\NormalTok{    hs }\OtherTok{\textless{}{-}}\NormalTok{ querySelectorAll headers (documentToParentNode doc)}
    \FunctionTok{flip}\NormalTok{ traverseNodeList\_ hs \textbackslash{}h }\OtherTok{{-}\textgreater{}} \KeywordTok{do}
\NormalTok{      topLink }\OtherTok{\textless{}{-}}\NormalTok{ createElement }\StringTok{"a"}\NormalTok{ doc}
      \KeywordTok{let}\NormalTok{ topLinkNode }\OtherTok{=}\NormalTok{ elementToNode topLink}
\NormalTok{      setAttribute }\StringTok{"href"} \StringTok{"\#title"}\NormalTok{ topLink}
\NormalTok{      setClassName }\StringTok{"top{-}link"}\NormalTok{ topLink}
\NormalTok{      setTextContent }\StringTok{"top"}\NormalTok{ topLinkNode}
\NormalTok{      appendChild topLinkNode (elementToNode h)}
      \FunctionTok{return}\NormalTok{ unit}
\end{Highlighting}
\end{Shaded}

gets translated to:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{ appendTopLinks }\OperatorTok{=} \KeywordTok{function}\NormalTok{ (doc) \{}
    \ControlFlowTok{return} \KeywordTok{function} \FunctionTok{\_\_do}\NormalTok{() \{}
        \KeywordTok{var}\NormalTok{ v }\OperatorTok{=} \FunctionTok{querySelectorAll}\NormalTok{(headers)(}\FunctionTok{documentToParentNode}\NormalTok{(doc))()}\OperatorTok{;}
        \ControlFlowTok{return} \FunctionTok{flip}\NormalTok{(}\FunctionTok{traverseNodeList\_}\NormalTok{(monadEffEff))(v)(}\KeywordTok{function}\NormalTok{ (h) \{}
            \ControlFlowTok{return} \KeywordTok{function} \FunctionTok{\_\_do}\NormalTok{() \{}
                \KeywordTok{var}\NormalTok{ v1 }\OperatorTok{=} \FunctionTok{createElement}\NormalTok{(}\StringTok{"a"}\NormalTok{)(doc)()}\OperatorTok{;}
                \KeywordTok{var}\NormalTok{ topLinkNode }\OperatorTok{=} \FunctionTok{elementToNode}\NormalTok{(v1)}\OperatorTok{;}
                \FunctionTok{setAttribute}\NormalTok{(}\StringTok{"href"}\NormalTok{)(}\StringTok{"\#title"}\NormalTok{)(v1)()}\OperatorTok{;}
                \FunctionTok{setClassName}\NormalTok{(}\StringTok{"top{-}link"}\NormalTok{)(v1)()}\OperatorTok{;}
                \FunctionTok{setTextContent}\NormalTok{(}\StringTok{"top"}\NormalTok{)(topLinkNode)()}\OperatorTok{;}
                \FunctionTok{appendChild}\NormalTok{(topLinkNode)(}\FunctionTok{elementToNode}\NormalTok{(h))()}\OperatorTok{;}
                \ControlFlowTok{return}\NormalTok{ unit}\OperatorTok{;}
\NormalTok{            \}}\OperatorTok{;}
\NormalTok{        \})()}\OperatorTok{;}
\NormalTok{    \}}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

And it's not just the IO-based imperative code that looks nice, either.
Everything gets compiled to clean, readable javascript that you'd be happy to
import in your node/normal javascript project.

The total exported javascript blob is only \emph{88 kB}, even smaller than fay's
\emph{100 kB} output (but not significantly so), and much smaller than GHCJS's
\emph{1.4 MB}\footnote{A previous version of this post claimed that the
  javascript bundle was \emph{140 MB}, instead of \emph{1.4 MB}. My bad!} output
(which, to be fair, has to also contain the entire Haskell runtime, implementing
Haskell semantics, as well).

Interestingly enough, the \emph{original} raw javacript I wrote in 2013 came out
to about the same size, about \emph{80 kB}. (Well, it is about \emph{2 kB} of
actual script, but it utilized all of \emph{jquery}, which implements a lot of
the functionality.) Getting comparable filesizes to jquery bundles is something
that's pretty impressive to me!

I'd recommend purescript to anyone who has to write simple javascript
\emph{scripts} and wants to do it in a sane, beautiful language. I still use
\emph{ghcjs} for actual \emph{applications}, for now, because I still love
Haskell and its ecosystem, along with the free data type sharing and code
re-usage. But for small scripts like these, purescript might just be the ideal
and perfect solution!

You can check out
\href{https://github.com/mstksg/inCode/blob/28f6a5da4c83356c4be87067ab88171879c68784/app-purescript/Entry.purs}{the
actual purescript script} on github!

\section{Conclusions}\label{conclusions}

My main takeways ---

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  I will never be able to never work on a Haskell project/application without
  \emph{stack} again (how did we even survive before \emph{stack}?)
\item
  Hakyll is a fun little library that is a great specialized \emph{make} for
  building static websites
\item
  Refactoring Haskell is an amazing experience; I would recommend it to anyone
  to try it out at least once in their lives
\item
  \emph{Purescript} is an amazing and beautiful technology that I had the
  pleasure of learning during this process, and generates elegant, readable
  javascript scripts.
\end{enumerate}

This reflection post has been to help me organize my thoughts, but I hope they
can be useful for those of you looking for new technologies to learn and ways to
implement/approach your stack or next programming project, as well!

\section{Signoff}\label{signoff}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
