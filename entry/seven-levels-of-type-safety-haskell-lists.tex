\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Seven Levels of Type Safety in Haskell: Lists},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Seven Levels of Type Safety in Haskell: Lists}

\begin{document}
\maketitle

\% Justin Le

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/seven-levels-of-type-safety-haskell-lists.html}{in
Code}}.}

One thing I always appreciate about Haskell is that you can often choose the
level of type-safety you want to work at. Haskell offers tools to be able to
work at \emph{both} extremes (which are often undesirable except in
extraordinary circumstances), whereas most languages only offer some limited
part of the spectrum. No promises about the ergonomics of either extreme, though
--- just that they are possible! Of course, often times Haskellers get a
reputation of always dialing it up to extreme safety just because they can, and
not because it's a good idea :) To be fair, I'm not going to claim that I'm
immune to this effect; something that has helped me, though, is being
consciously aware of the different levels of type safety that are available, and
the benefits/drawbacks/unique advantages to each.

So, here is a rundown of seven ``levels'' of type safety that you can operate at
when working with the ubiquitous \emph{strict} linked list data type, and how to
use them! I genuinely believe all of these are useful (or useless) in their own
different circumstances. When possible, we'll prefer ``structural type safety''
(that is, enforced by the structure of the type itself) as opposed to
\href{https://hackage.haskell.org/package/refined}{restricted constructors}
(just to allow us to make more interesting comparisons and contrasts) and also
more flexible/parameterized options for type safety instead of hard-coded
restrictions.

One interesting thing you might notice is the ``bowl-shaped''
difficulty/ergonomics curve. At the unsafe extreme, usage can be a bit of a
hassle due to the nature of the language, at the safest extremes\ldots well,
you'll see soon enough!

This post is written for a late beginner or intermediate Haskeller, who is
already familiar with ADTs and defining their own custom list type like
\texttt{data\ List\ a\ =\ Nil\ \textbar{}\ Cons\ a\ (List\ a)}.

\section{Level 0: Could be anything}\label{level-0-could-be-anything}

Let's start off with a baseline type that demonstrates a little bit of the
quirks of working at the unsafe extremes in Haskell.

A reasonable idea might be to just make a ``black hole'' data type that could be
anything:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Any}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
  \DataTypeTok{MkAny}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Any}
\end{Highlighting}
\end{Shaded}

(This data type declaration written using
\href{https://typeclasses.com/ghc/gadt-syntax}{GADT Syntax}, and the name was
chosen because it resembles
\href{https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html\#t:Any}{the
Any type in base})

So you can have values \texttt{MkAny\ 8\ ::\ Any},
\texttt{MkAny\ True\ ::\ Any}, \texttt{MkAny\ {[}1,2,3{]}\ ::\ Any}, etc. A
value of any type can be given to \texttt{MkAny}, and the resulting type will
have type \texttt{Any}.

However, this type is a black hole; you can't really do anything with the values
inside it because of parametric polymorphism: you must treat any value inside it
in a way that is compatible with a value of \emph{any} type. But there aren't
\emph{too} many useful things you can do with something in a way that is
compatible with a value of any type (things like,
\texttt{id\ ::\ a\ -\textgreater{}\ a},
\texttt{const\ 3\ ::\ a\ -\textgreater{}\ Int}). In the end, it's essentially
isomorphic to unit \texttt{()}.

So we can actually modify this slightly to match the typical dynamically typed
language picture of ``could be anything'': we should at least be able to query
the type for things we can do with it.

To get there, we can instead allow some sort of witness on the type of the
value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Sigma}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSigma}\OtherTok{ ::}\NormalTok{ p a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma}\NormalTok{ p}
\end{Highlighting}
\end{Shaded}

And the most classic witness is
\href{https://hackage.haskell.org/package/base-4.14.1.0/docs/Type-Reflection.html\#t:TypeRep}{\texttt{TypeRep}}
from \emph{base}, which is a witness that lets you ``match'' on the type.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{showIfBool ::} \DataTypeTok{Sigma} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\NormalTok{showIfBool (}\DataTypeTok{Sigma}\NormalTok{ tr x) }\OtherTok{=} \KeywordTok{case}\NormalTok{ testEquality tr (typeRep }\OperatorTok{@}\DataTypeTok{Bool}\NormalTok{) }\KeywordTok{of}
    \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ x }\KeywordTok{of}      \CommentTok{{-}{-} in this branch, we know x is a Bool}
      \DataTypeTok{False} \OtherTok{{-}\textgreater{}} \StringTok{"False"}
      \DataTypeTok{True}  \OtherTok{{-}\textgreater{}} \StringTok{"True"}
    \DataTypeTok{Nothing} \OtherTok{{-}\textgreater{}} \StringTok{"Not a Bool"}
\end{Highlighting}
\end{Shaded}

Here we can use \texttt{TypeRep}'s interface to ``match'' (using
\texttt{testEquality}) on if the value inside is a \texttt{Bool}. If the match
works (and we get \texttt{Just\ Refl}) then we can treat \texttt{x} as a
\texttt{Bool} in that case. If it doesn't (and we get \texttt{Nothing}), then we
do what we would want to do otherwise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ x }\OtherTok{=} \DataTypeTok{Sigma}\NormalTok{ typeRep }\DataTypeTok{True}
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ y }\OtherTok{=} \DataTypeTok{Sigma}\NormalTok{ typeRep }\DecValTok{4}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showIfBool x}
\StringTok{"True"}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showIfBool y}
\StringTok{"Not a Bool"}
\end{Highlighting}
\end{Shaded}

This pattern is common enough that there's the
\emph{\href{https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Dynamic.html}{Data.Dynamic}}
module in base that is \texttt{Sigma\ TypeRep}, and wraps our
\texttt{testEquality} dance above in a function called \texttt{fromDynamic}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{showIfBool ::} \DataTypeTok{Dynamic} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\NormalTok{showIfBool dyn }\OtherTok{=} \KeywordTok{case}\NormalTok{ fromDynamic dyn }\KeywordTok{of}
    \DataTypeTok{Just}\NormalTok{ x }\OtherTok{{-}\textgreater{}} \KeywordTok{case}\NormalTok{ x }\KeywordTok{of}      \CommentTok{{-}{-} in this branch, we know x is a Bool}
      \DataTypeTok{False} \OtherTok{{-}\textgreater{}} \StringTok{"False"}
      \DataTypeTok{True}  \OtherTok{{-}\textgreater{}} \StringTok{"True"}
    \DataTypeTok{Nothing} \OtherTok{{-}\textgreater{}} \StringTok{"Not a Bool"}
\end{Highlighting}
\end{Shaded}

For make our life easier in the future, let's write a version of
\texttt{fromDynamic} for our \texttt{Sigma\ TypeRep}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} Typeable constraint is necessary to use typeRep @a}
\OtherTok{castSigma ::} \KeywordTok{forall}\NormalTok{ a}\OperatorTok{.} \DataTypeTok{Typeable}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Sigma} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{castSigma (}\DataTypeTok{Sigma}\NormalTok{ tr x) }\OtherTok{=} \KeywordTok{case}\NormalTok{ testEquality tr (typeRep }\OperatorTok{@}\NormalTok{a) }\KeywordTok{of}
    \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{{-}\textgreater{}} \DataTypeTok{Just}\NormalTok{ x}
    \DataTypeTok{Nothing}   \OtherTok{{-}\textgreater{}} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

But the reason why I'm presenting the more generic \texttt{Sigma} instead of the
specific \texttt{type\ Dynamic\ =\ Sigma\ TypeRep} is that you can swap out
\texttt{TypeRep} to get other interesting types. For example, if you had a
witness of showability:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Showable}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{WitShowable}\OtherTok{ ::} \DataTypeTok{Show}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Showable}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

(This type is related to \texttt{Dict\ Show} from the
\href{https://hackage.haskell.org/package/constraints-0.13/docs/Data-Constraint.html\#t:Dict}{constraints}
library; it's technically \texttt{Compose\ Dict\ Show})

And now we have a type \texttt{Sigma\ Showable} that's a bit of a black hole,
but we can at least use \texttt{show} on it:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{showSigma ::} \DataTypeTok{Sigma} \DataTypeTok{Showable} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\NormalTok{showSigma (}\DataTypeTok{Sigma} \DataTypeTok{WitShowable}\NormalTok{ x) }\OtherTok{=} \FunctionTok{show}\NormalTok{ x       }\CommentTok{{-}{-} here, we know x is Show}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ x }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DataTypeTok{True}
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ y }\OtherTok{=} \DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DecValTok{4}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showSigma x}
\StringTok{"True"}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showSigma y}
\StringTok{"4"}
\end{Highlighting}
\end{Shaded}

This is the
``\href{https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/}{existential
typeclass antipattern}'', but since we are talking about different ways we can
tease the type system, it's probably worth mentioning! Note that \texttt{Show}
is a bit silly of a typeclass to use in this context because a
\texttt{Sigma\ Showable} is equivalent to just a \texttt{String}: once you match
on the constructor to get the value, the only thing you can do with the value is
\texttt{show} it anyway.

One fun thing we can do is provide a ``useless witness'', like \texttt{Proxy}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Proxy}
\end{Highlighting}
\end{Shaded}

So a value like \texttt{MkSigma\ Proxy\ True\ ::\ Sigma\ Proxy} is truly a
useless data type, since we know that \texttt{MkSigma} contrains \emph{some}
value of \emph{some} type, but there's no witness to give us any clue on how we
can use it. A \texttt{Sigma\ Proxy} is isomorphic to \texttt{()}.

On the other extreme, we can use a witness to constrain the value to only be a
specific type, like \texttt{IsBool}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{IsBool}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{ItsABool}\OtherTok{ ::} \DataTypeTok{IsBool} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

So you can have a value of type
\texttt{MkSigma\ ItsABool\ True\ ::\ Sigma\ IsBool}, or
\texttt{MkSigma\ ItsABool\ False}, but \texttt{MkSigma\ ItsABool\ 2} will not
typecheck --- remember, to make a \texttt{Sigma}, you need a \texttt{p\ a} and
an \texttt{a}. \texttt{ItsABool\ ::\ IsBool\ Bool}, so the \texttt{a} you put in
must be \texttt{Bool} to match. \texttt{Sigma\ IsBool} is isomorphic to
\texttt{Bool}.

There's a general version of this too, \texttt{(:\textasciitilde{}:)\ a} (from
\emph{\href{https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Type-Equality.html\#t::-126-:}{Data.Type.Equality}}
in base). \texttt{(:\textasciitilde{}:)\ Bool} is our \texttt{IsBool} earlier.
\texttt{Sigma\ ((:\textasciitilde{}:)\ a)} is essentially exactly
\texttt{a}\ldots basically bringing us incidentally back to complete type
safety? Weird. Anyway.

I think one interesting thing to see here is that being ``type-unsafe'' in
Haskell can be much less convenient than doing something similar in a
dynamically typed language like python --- that's why I don't fancy those
memes/jokes about how dynamically typed languages are just ``static types with a
single type''. The actual way you use those types lend themselves to different
ergonomics, and the reductionist take doesn't quite capture that nuance.

\section{Level 1: Heterogeneous List}\label{level-1-heterogeneous-list}

The lowest level of safety in which a list might be useful is the heterogeneous
list. This is the level where lists (or ``arrays'') live in most dynamic
languages.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Sigma}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSigma}\OtherTok{ ::}\NormalTok{ p a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma}\NormalTok{ p}

\CommentTok{{-}{-} we can define this in terms of Haskell\textquotesingle{}s built{-}in list}
\KeywordTok{type} \DataTypeTok{HList}\NormalTok{ p }\OtherTok{=}\NormalTok{ [}\DataTypeTok{Sigma}\NormalTok{ p]}
\end{Highlighting}
\end{Shaded}

We tag values with a witness \texttt{p} for the same reason as before: if we
don't provide \emph{some} type of witness, our type is useless.

The ``heterogeneous list of values of any type'' is \texttt{HList\ TypeRep}.
This is usable in the implicit multiple-argument nature of functions in
languages like javascript. For example, here's a function that connects to a
host (\texttt{String}), optionally taking a port (\texttt{Int}) and a method
(\texttt{Method}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Method} \OtherTok{=} \DataTypeTok{HTTP} \OperatorTok{|} \DataTypeTok{HTTPS}

\OtherTok{indexMaybe ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{HList}\NormalTok{ p }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Sigma}\NormalTok{ p)}
\NormalTok{indexMaybe }\DecValTok{0}\NormalTok{ []     }\OtherTok{=} \DataTypeTok{Nothing}
\NormalTok{indexMaybe }\DecValTok{0}\NormalTok{ (x}\OperatorTok{:}\NormalTok{\_ ) }\OtherTok{=} \DataTypeTok{Just}\NormalTok{ x}
\NormalTok{indexMaybe n (\_}\OperatorTok{:}\NormalTok{xs) }\OtherTok{=}\NormalTok{ indexMaybe (n}\OperatorTok{{-}}\DecValTok{1}\NormalTok{) xs}

\CommentTok{{-}{-} | Expects a String, an Int, then a Method.}
\OtherTok{mkConnection ::} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{mkConnection args }\OtherTok{=} \OperatorTok{...}
  \KeywordTok{where}
\OtherTok{    host ::} \DataTypeTok{Maybe} \DataTypeTok{String}
\NormalTok{    host }\OtherTok{=}\NormalTok{ castSigma }\OperatorTok{=\textless{}\textless{}}\NormalTok{ indexHList }\DecValTok{0}\NormalTok{ args}
\OtherTok{    port ::} \DataTypeTok{Maybe} \DataTypeTok{Int}
\NormalTok{    port }\OtherTok{=}\NormalTok{ castSigma }\OperatorTok{=\textless{}\textless{}}\NormalTok{ indexHList }\DecValTok{1}\NormalTok{ args}
\OtherTok{    method ::} \DataTypeTok{Maybe} \DataTypeTok{Method}
\NormalTok{    method }\OtherTok{=}\NormalTok{ castSigma }\OperatorTok{=\textless{}\textless{}}\NormalTok{ indexHList }\DecValTok{2}\NormalTok{ args}
\end{Highlighting}
\end{Shaded}

Of course, this would \emph{probably} be better expressed in Haskell as a
function of type
\texttt{Maybe\ String\ -\textgreater{}\ Maybe\ Int\ -\textgreater{}\ Maybe\ Method\ -\textgreater{}\ IO\ ()}.
But maybe this could be useful in a situation where you would want to offer the
ability to take arguments in any order? We could ``find'' the first value of a
given type:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{findValueOfType ::} \DataTypeTok{Typeable}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{findValueOfType []     }\OtherTok{=} \DataTypeTok{Nothing}
\NormalTok{findValueOfType (x}\OperatorTok{:}\NormalTok{xs) }\OtherTok{=}\NormalTok{ castSigma x }\OperatorTok{\textless{}|\textgreater{}}\NormalTok{ findValueOfType xs}
\end{Highlighting}
\end{Shaded}

Then we could write:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | Expects a String, an Int, then a Method, in any order.}
\OtherTok{mkConnection ::} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{mkConnection args }\OtherTok{=} \OperatorTok{...}
  \KeywordTok{where}
\OtherTok{    host ::} \DataTypeTok{Maybe} \DataTypeTok{String}
\NormalTok{    host }\OtherTok{=}\NormalTok{ findValueOfType args}
\OtherTok{    port ::} \DataTypeTok{Maybe} \DataTypeTok{Int}
\NormalTok{    port }\OtherTok{=}\NormalTok{ findValueOfType args}
\OtherTok{    method ::} \DataTypeTok{Maybe} \DataTypeTok{Method}
\NormalTok{    method }\OtherTok{=}\NormalTok{ findValueOfType args}
\end{Highlighting}
\end{Shaded}

But is this a good idea? Probably not.

One very common usage of this type is for ``extensible'' systems that let you
store components of different types in a container, as long as they all support
some common interface (ie, the widgets system from the
\href{https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/}{Luke
Palmer} post).

For example, we could have a list of any item as long as the item is an instance
of \texttt{Show}: that's \texttt{HList\ Showable}!

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{showAll ::} \DataTypeTok{HList} \DataTypeTok{Showable} \OtherTok{{-}\textgreater{}}\NormalTok{ [}\DataTypeTok{String}\NormalTok{]}
\NormalTok{showAll }\OtherTok{=} \FunctionTok{map}\NormalTok{ showSigma}
  \KeywordTok{where}
\NormalTok{    showSigma (}\DataTypeTok{MkSigma} \DataTypeTok{WitShowable}\NormalTok{ x) }\OtherTok{=} \FunctionTok{show}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ xs }\OtherTok{=}\NormalTok{ [}\DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DecValTok{1}\NormalTok{, }\DataTypeTok{MkSigma} \DataTypeTok{WitShowable} \DataTypeTok{True}\NormalTok{]}
\NormalTok{ghci}\OperatorTok{\textgreater{}}\NormalTok{ showAll xs}
\NormalTok{[}\StringTok{"1"}\NormalTok{, }\StringTok{"True"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

For \texttt{Show}, this is a rather silly thing to do because of the reasons
mentioned in the Palmer post --- namely, that you could always just have a
\texttt{{[}String{]}} directly instead of an \texttt{HList\ Showable}, since the
only thing you can do with a \texttt{Sigma\ Showable} is \texttt{show} it.

For fun, let's imagine some other things we could fill in for \texttt{p}. If we
use \texttt{HList\ Proxy}, then we basically don't have any witness at all. We
can't use the values in the list in any meaningful way; \texttt{HList\ Proxy} is
essentially the same as \texttt{Natural}, since the only information is the
length.

If we use \texttt{HList\ IsBool}, we basically have \texttt{{[}Bool{]}}, since
every item must be a \texttt{Bool}! In general,
\texttt{HList\ ((:\textasciitilde{}:)\ a)} is the same as \texttt{{[}a{]}}.

\section{Level 2: Homogeneous Dynamic
List}\label{level-2-homogeneous-dynamic-list}

A next level of type safety we can add is to ensure that all elements in the
list are of the same type. This adds a layer of usefulness because there are a
lot of things we might want to do with the elements of a list that are only
possible if they are all of the same type --- for example, we might want to take
a (polymorphic) sum of a list, but we can't do that with \texttt{HList} because
it might mix values of different types.

To do this, we can flip the witness to \emph{outside} the list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeList}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeList}\OtherTok{ ::}\NormalTok{ p a }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}} \DataTypeTok{SomeList}\NormalTok{ p}
\end{Highlighting}
\end{Shaded}

We can write some meaningful predicates on this list --- for example, we can
check if it is monotonic (the items increase in order)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | An Ord counterpart for Showable}
\KeywordTok{data} \DataTypeTok{Comparable}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{WitOrd}\OtherTok{ ::} \DataTypeTok{Ord}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Comparable}\NormalTok{ a}

\OtherTok{monotonic ::} \DataTypeTok{SomeList} \DataTypeTok{Comparable} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{monotonic (}\DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ [])       }\OtherTok{=} \DataTypeTok{True}
\NormalTok{monotonic (}\DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ [x])      }\OtherTok{=} \DataTypeTok{True}
\NormalTok{monotonic (}\DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ (x}\OperatorTok{:}\NormalTok{y}\OperatorTok{:}\NormalTok{xs)) }\OtherTok{=}
\NormalTok{    (x }\OperatorTok{\textless{}=}\NormalTok{ y) }\OperatorTok{\&\&}\NormalTok{ monotonic (}\DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ (y}\OperatorTok{:}\NormalTok{xs))}
\end{Highlighting}
\end{Shaded}

However, if we take a step back, we can see that this is a little silly because
we could just as easily write \texttt{monotonic} as a polymorphic function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{monotonic\textquotesingle{} ::} \DataTypeTok{Ord}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{monotonic\textquotesingle{} []       }\OtherTok{=} \DataTypeTok{True}
\NormalTok{monotonic\textquotesingle{} [x]      }\OtherTok{=} \DataTypeTok{True}
\NormalTok{monotonic\textquotesingle{} (x}\OperatorTok{:}\NormalTok{y}\OperatorTok{:}\NormalTok{xs) }\OtherTok{=}\NormalTok{ (x }\OperatorTok{\textless{}=}\NormalTok{ y) }\OperatorTok{\&\&}\NormalTok{ monotonic\textquotesingle{} (y}\OperatorTok{:}\NormalTok{xs)}
\end{Highlighting}
\end{Shaded}

Instead, the we could maybe have a function return \emph{any} type of
\texttt{Ord}-instance list, depending on what it was given.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{getItems ::} \DataTypeTok{IO}\NormalTok{ (}\DataTypeTok{SomeList} \DataTypeTok{Comparable}\NormalTok{)}
\NormalTok{getItems }\OtherTok{=} \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

This is a ``dependently typed'' function, in that it could go into a database
(or query the user) for a list of items of a type that will not be known until
runtime --- the only guarantee we have is that it has an \texttt{Ord} instance.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{analyzeGottenItems ::} \DataTypeTok{IO} \DataTypeTok{Bool}
\NormalTok{analyzeGottenItems }\OtherTok{=} \KeywordTok{do}
\NormalTok{    items}\OperatorTok{@}\NormalTok{(}\DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ xs) }\OtherTok{\textless{}{-}}\NormalTok{ getItems}
    \FunctionTok{putStrLn} \OperatorTok{$} \StringTok{"Got "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ (}\FunctionTok{length}\NormalTok{ xs) }\OperatorTok{++} \StringTok{" items."}
    \KeywordTok{let}\NormalTok{ isMono    }\OtherTok{=}\NormalTok{ monotonic items}
\NormalTok{        isRevMono }\OtherTok{=}\NormalTok{ monotnoic (}\DataTypeTok{MkSomeList} \DataTypeTok{WitOrd}\NormalTok{ (}\FunctionTok{reverse}\NormalTok{ xs))}
\NormalTok{    when isMono }\OperatorTok{$}
      \FunctionTok{putStrLn} \StringTok{"The items are monotonic."}
\NormalTok{    when (isMono }\OperatorTok{\&\&}\NormalTok{ isRevMono) }\OperatorTok{$} \KeywordTok{do}
      \FunctionTok{putStrLn} \StringTok{"The items are monotonic both directions."}
      \FunctionTok{putStrLn} \StringTok{"This means the items are all identical."}
\end{Highlighting}
\end{Shaded}

This could also be useful if you have a few ``valid'' options for your list
types, and want to branch depending on which one you get. This can be useful for
just using \texttt{Either} if you expect your list of valid types to be ``open''
and constantly expanding, and so your documentation is your main way of
indicating to the user what they can give. I'm just kidding, this is not useful,
please use a real closed ADT if you ever want to do this.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | Behavior depends on what is given.}
\CommentTok{{-}{-}}
\CommentTok{{-}{-} * If it\textquotesingle{}s a list of Bools, returns if they are all True}
\CommentTok{{-}{-} * If it\textquotesingle{}s a list of Ints, returns if their sum is greater than 50}
\CommentTok{{-}{-} * If it\textquotesingle{}s a list of Doubles, returns if their sum is greater than 5.0}
\CommentTok{{-}{-} * If it\textquotesingle{}s a list of Strings, returns if it contains an \textquotesingle{}e\textquotesingle{}}
\OtherTok{processList ::} \DataTypeTok{MkSomeList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{processList (}\DataTypeTok{MkSomeList}\NormalTok{ tr xs)}
    \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (typeRep }\OperatorTok{@}\DataTypeTok{Bool}\NormalTok{)   }\OtherTok{=} \FunctionTok{and}\NormalTok{ xs}
    \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (}\DataTypeTok{TypeRep} \OperatorTok{@}\DataTypeTok{Int}\NormalTok{)    }\OtherTok{=} \FunctionTok{sum}\NormalTok{ xs }\OperatorTok{\textgreater{}} \DecValTok{50}
    \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (}\DataTypeTok{TypeRep} \OperatorTok{@}\DataTypeTok{Double}\NormalTok{) }\OtherTok{=} \FunctionTok{sum}\NormalTok{ xs }\OperatorTok{\textgreater{}} \FloatTok{5.0}
    \OperatorTok{|} \DataTypeTok{Just} \DataTypeTok{Refl} \OtherTok{\textless{}{-}}\NormalTok{ testEquality tr (}\DataTypeTok{TypeRep} \OperatorTok{@}\DataTypeTok{String}\NormalTok{) }\OtherTok{=} \CharTok{\textquotesingle{}e\textquotesingle{}} \OtherTok{\textasciigrave{}elem\textasciigrave{}}\NormalTok{ xs}
\end{Highlighting}
\end{Shaded}

This pattern is overall similar to how lists are often used in dynamic
languages: just \emph{some} list of the same type of each element is expected,
but what is \emph{in} those lists is dynamically determined. Ultimately I think
Level 1 more closely matches lists in dynamic languages than Level 2, if only
because the idea of a list of all elements of the same type is such a
half-hearted sort of type safety that neither dynamic languages nor statically
typed languages would ever embrace it --- it's a ``worst of both worlds'' in
many ways.

For all of these levels, we'll take a moment to describe how to ``ascend to''
the new level, and how to ``descend from'' the new level.

Moving from Level 1 to Level 2 is actually impossible in the general case; we
can only do for \texttt{HList\ TypeRep} and \texttt{SomeList\ TypeRep}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{hlistToSomeList ::} \DataTypeTok{HList} \DataTypeTok{TypeRep} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{SomeList} \DataTypeTok{TypeRep}\NormalTok{)}
\NormalTok{hlistToSomeList (}\DataTypeTok{HList}\NormalTok{ [])     }\OtherTok{=} \DataTypeTok{Just} \OperatorTok{$} \DataTypeTok{MkSomeList}\NormalTok{ (typeRep }\OperatorTok{@}\NormalTok{()) []  }\CommentTok{{-}{-} this could be anything}
\NormalTok{hlistToSomeList (}\DataTypeTok{HList}\NormalTok{ (x}\OperatorTok{:}\NormalTok{xs)) }\OtherTok{=} 
\end{Highlighting}
\end{Shaded}

\section{Level 3: Homogeneous Typed List}\label{level-3-homogeneous-typed-list}

At the halfway point, we've reached Haskell's ubiquitous list type! It is
essentially:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{List}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{Nil}\OtherTok{  ::} \DataTypeTok{List}\NormalTok{ a}
    \DataTypeTok{Cons}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{List}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{List}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

I don't have too much to say here, other than to acknowledge that this is truly
a ``sweet spot'' in terms of safety vs.~unsafety and usability. This simple
\texttt{List\ a} / \texttt{{[}a{]}} type has so many benefits from type-safety:

\begin{itemize}
\tightlist
\item
  It lets us write functions that can meaningfully say that the input and result
  types are the same, like
  \texttt{take\ ::\ Int\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}}
\item
  It lets us write functions that can meaningfully link lists and the items in
  the list, like \texttt{head\ ::\ {[}a{]}\ -\textgreater{}\ a} and
  \texttt{replicate\ ::\ Int\ -\textgreater{}\ a\ -\textgreater{}\ {[}a{]}}.
\item
  It lets us write functions that can meaningfully state relationships between
  input and results, like
  \texttt{map\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}b{]}}
\item
  We can require two input lists to have the same type of items, like
  \texttt{(++)\ \ \ \ \ ::\ {[}a{]}\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}}
\item
  We can express complex relationships between inputs and outputs, like
  \texttt{zipWith\ ::\ (a\ -\textgreater{}\ b\ -\textgreater{}\ c)\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}b{]}\ -\textgreater{}\ {[}c{]}}.
\end{itemize}

The property of being able to state and express relationships between the values
of input lists and output lists and the items in those lists is extremely
powerful, and also extremely ergonomic to use in Haskell. It can be argued that
Haskell, as a language, was tuned explicitly to be used with the least friction
at this exact level of type safety.

\section{Signoff}\label{signoff}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
