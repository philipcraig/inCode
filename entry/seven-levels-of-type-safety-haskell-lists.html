<!DOCTYPE HTML>
<html><head><title>Seven Levels of Type Safety in Haskell: Lists
 · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="One thing I always appreciate about Haskell is that you can often choose the level of type-safety you want to work at. Haskell offers tools to be able to work at both extremes (which are often undesirable except in extraordinary circumstances), whereas most languages only offer some limited part of the spectrum. No promises about the ergonomics of either extreme, though — just that they are possible! Of course, often times Haskellers get a reputation of always dialing it up to extreme safety just because they can, and not because it’s a good idea :) To be fair, I’m not going to claim that I’m immune to this effect; something that has helped me, though, is being consciously aware of the different levels of type safety that are available, and the benefits/drawbacks/unique advantages to each. So, here is a rundown of seven “levels” of type safety that you can operate at when working with the ubiquitous strict linked list data type, and how to use them! I genuinely believe all of these are useful (or useless) in their own different circumstances. When possible, we’ll prefer “structural type safety” (that is, enforced by the structure of the type itself) as opposed to restricted constructors (just to allow us to make more interesting comparisons and contrasts) and also more flexible/parameterized options for type safety instead of hard-coded restrictions. One interesting thing you might notice is the “bowl-shaped” difficulty/ergonomics curve. At the unsafe extreme, usage can be a bit of a hassle due to the nature of the language, at the safest extremes…well, you’ll see soon enough! This post is written for a late beginner or intermediate Haskeller, who is already familiar with ADTs and defining their own custom list type like data List a = Nil | Cons a (List a)."><meta property="og:type" content="article"><meta property="og:title" content="Seven Levels of Type Safety in Haskell: Lists
"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/seven-levels-of-type-safety-haskell-lists.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/seven-levels-of-type-safety-haskell-lists.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Seven Levels of Type Safety in Haskell: Lists
</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/type-levels.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/seven-levels-of-type-safety-haskell-lists.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/seven-levels-of-type-safety-haskell-lists.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.
">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>One thing I always appreciate about Haskell is that you can often choose the level of type-safety you want to work at. Haskell offers tools to be able to work at <em>both</em> extremes (which are often undesirable except in extraordinary circumstances), whereas most languages only offer some limited part of the spectrum. No promises about the ergonomics of either extreme, though — just that they are possible! Of course, often times Haskellers get a reputation of always dialing it up to extreme safety just because they can, and not because it’s a good idea :) To be fair, I’m not going to claim that I’m immune to this effect; something that has helped me, though, is being consciously aware of the different levels of type safety that are available, and the benefits/drawbacks/unique advantages to each.</p>
<p>So, here is a rundown of seven “levels” of type safety that you can operate at when working with the ubiquitous <em>strict</em> linked list data type, and how to use them! I genuinely believe all of these are useful (or useless) in their own different circumstances. When possible, we’ll prefer “structural type safety” (that is, enforced by the structure of the type itself) as opposed to <a href="https://hackage.haskell.org/package/refined">restricted constructors</a> (just to allow us to make more interesting comparisons and contrasts) and also more flexible/parameterized options for type safety instead of hard-coded restrictions.</p>
<p>One interesting thing you might notice is the “bowl-shaped” difficulty/ergonomics curve. At the unsafe extreme, usage can be a bit of a hassle due to the nature of the language, at the safest extremes…well, you’ll see soon enough!</p>
<p>This post is written for a late beginner or intermediate Haskeller, who is already familiar with ADTs and defining their own custom list type like <code>data List a = Nil | Cons a (List a)</code>.</p>
<h2 id="level-0-could-be-anything">Level 0: Could be anything</h2>
<p>Let’s start off with a baseline type that demonstrates a little bit of the quirks of working at the unsafe extremes in Haskell.</p>
<p>A reasonable idea might be to just make a “black hole” data type that could be anything:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Any</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkAny</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span></span></code></pre></div>
<p>(This data type declaration written using <a href="https://typeclasses.com/ghc/gadt-syntax">GADT Syntax</a>, and the name was chosen because it resembles <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Any">the Any type in base</a>)</p>
<p>So you can have values <code>MkAny 8 :: Any</code>, <code>MkAny True :: Any</code>, <code>MkAny [1,2,3] :: Any</code>, etc. A value of any type can be given to <code>MkAny</code>, and the resulting type will have type <code>Any</code>.</p>
<p>However, this type is a black hole; you can’t really do anything with the values inside it because of parametric polymorphism: you must treat any value inside it in a way that is compatible with a value of <em>any</em> type. But there aren’t <em>too</em> many useful things you can do with something in a way that is compatible with a value of any type (things like, <code>id :: a -&gt; a</code>, <code>const 3 :: a -&gt; Int</code>). In the end, it’s essentially isomorphic to unit <code>()</code>.</p>
<p>So we can actually modify this slightly to match the typical dynamically typed language picture of “could be anything”: we should at least be able to query the type for things we can do with it.</p>
<p>To get there, we can instead allow some sort of witness on the type of the value:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sigma</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSigma</span><span class="ot"> ::</span> p a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Sigma</span> p</span></code></pre></div>
<p>And the most classic witness is <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Type-Reflection.html#t:TypeRep"><code>TypeRep</code></a> from <em>base</em>, which is a witness that lets you “match” on the type.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showIfBool ::</span> <span class="dt">Sigma</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>showIfBool (<span class="dt">Sigma</span> tr x) <span class="ot">=</span> <span class="kw">case</span> testEquality tr (typeRep <span class="op">@</span><span class="dt">Bool</span>) <span class="kw">of</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span>      <span class="co">-- in this branch, we know x is a Bool</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="st">&quot;False&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="st">&quot;True&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;Not a Bool&quot;</span></span></code></pre></div>
<p>Here we can use <code>TypeRep</code>’s interface to “match” (using <code>testEquality</code>) on if the value inside is a <code>Bool</code>. If the match works (and we get <code>Just Refl</code>) then we can treat <code>x</code> as a <code>Bool</code> in that case. If it doesn’t (and we get <code>Nothing</code>), then we do what we would want to do otherwise.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dt">Sigma</span> typeRep <span class="dt">True</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> y <span class="ot">=</span> <span class="dt">Sigma</span> typeRep <span class="dv">4</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showIfBool x</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;True&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showIfBool y</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Not a Bool&quot;</span></span></code></pre></div>
<p>This pattern is common enough that there’s the <em><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Dynamic.html">Data.Dynamic</a></em> module in base that is <code>Sigma TypeRep</code>, and wraps our <code>testEquality</code> dance above in a function called <code>fromDynamic</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showIfBool ::</span> <span class="dt">Dynamic</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>showIfBool dyn <span class="ot">=</span> <span class="kw">case</span> fromDynamic dyn <span class="kw">of</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span>      <span class="co">-- in this branch, we know x is a Bool</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="st">&quot;False&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="st">&quot;True&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;Not a Bool&quot;</span></span></code></pre></div>
<p>For make our life easier in the future, let’s write a version of <code>fromDynamic</code> for our <code>Sigma TypeRep</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Typeable constraint is necessary to use typeRep @a</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">castSigma ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Sigma</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>castSigma (<span class="dt">Sigma</span> tr x) <span class="ot">=</span> <span class="kw">case</span> testEquality tr (typeRep <span class="op">@</span>a) <span class="kw">of</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>But the reason why I’m presenting the more generic <code>Sigma</code> instead of the specific <code>type Dynamic = Sigma TypeRep</code> is that you can swap out <code>TypeRep</code> to get other interesting types. For example, if you had a witness of showability:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Showable</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">WitShowable</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Showable</span> a</span></code></pre></div>
<p>(This type is related to <code>Dict Show</code> from the <a href="https://hackage.haskell.org/package/constraints-0.13/docs/Data-Constraint.html#t:Dict">constraints</a> library; it’s technically <code>Compose Dict Show</code>)</p>
<p>And now we have a type <code>Sigma Showable</code> that’s a bit of a black hole, but we can at least use <code>show</code> on it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showSigma ::</span> <span class="dt">Sigma</span> <span class="dt">Showable</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>showSigma (<span class="dt">Sigma</span> <span class="dt">WitShowable</span> x) <span class="ot">=</span> <span class="fu">show</span> x       <span class="co">-- here, we know x is Show</span></span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dt">True</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> y <span class="ot">=</span> <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dv">4</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showSigma x</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;True&quot;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showSigma y</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;4&quot;</span></span></code></pre></div>
<p>This is the “<a href="https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/">existential typeclass antipattern</a>”, but since we are talking about different ways we can tease the type system, it’s probably worth mentioning! Note that <code>Show</code> is a bit silly of a typeclass to use in this context because a <code>Sigma Showable</code> is equivalent to just a <code>String</code>: once you match on the constructor to get the value, the only thing you can do with the value is <code>show</code> it anyway.</p>
<p>One fun thing we can do is provide a “useless witness”, like <code>Proxy</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>So a value like <code>MkSigma Proxy True :: Sigma Proxy</code> is truly a useless data type, since we know that <code>MkSigma</code> contrains <em>some</em> value of <em>some</em> type, but there’s no witness to give us any clue on how we can use it. A <code>Sigma Proxy</code> is isomorphic to <code>()</code>.</p>
<p>On the other extreme, we can use a witness to constrain the value to only be a specific type, like <code>IsBool</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IsBool</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ItsABool</span><span class="ot"> ::</span> <span class="dt">IsBool</span> <span class="dt">Bool</span></span></code></pre></div>
<p>So you can have a value of type <code>MkSigma ItsABool True :: Sigma IsBool</code>, or <code>MkSigma ItsABool False</code>, but <code>MkSigma ItsABool 2</code> will not typecheck — remember, to make a <code>Sigma</code>, you need a <code>p a</code> and an <code>a</code>. <code>ItsABool :: IsBool Bool</code>, so the <code>a</code> you put in must be <code>Bool</code> to match. <code>Sigma IsBool</code> is isomorphic to <code>Bool</code>.</p>
<p>There’s a general version of this too, <code>(:~:) a</code> (from <em><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Type-Equality.html#t::-126-:">Data.Type.Equality</a></em> in base). <code>(:~:) Bool</code> is our <code>IsBool</code> earlier. <code>Sigma ((:~:) a)</code> is essentially exactly <code>a</code>…basically bringing us incidentally back to complete type safety? Weird. Anyway.</p>
<p>I think one interesting thing to see here is that being “type-unsafe” in Haskell can be much less convenient than doing something similar in a dynamically typed language like python — that’s why I don’t fancy those memes/jokes about how dynamically typed languages are just “static types with a single type”. The actual way you use those types lend themselves to different ergonomics, and the reductionist take doesn’t quite capture that nuance.</p>
<h2 id="level-1-heterogeneous-list">Level 1: Heterogeneous List</h2>
<p>The lowest level of safety in which a list might be useful is the heterogeneous list. This is the level where lists (or “arrays”) live in most dynamic languages.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sigma</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSigma</span><span class="ot"> ::</span> p a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Sigma</span> p</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- we can define this in terms of Haskell&#39;s built-in list</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">HList</span> p <span class="ot">=</span> [<span class="dt">Sigma</span> p]</span></code></pre></div>
<p>We tag values with a witness <code>p</code> for the same reason as before: if we don’t provide <em>some</em> type of witness, our type is useless.</p>
<p>The “heterogeneous list of values of any type” is <code>HList TypeRep</code>. This is usable in the implicit multiple-argument nature of functions in languages like javascript. For example, here’s a function that connects to a host (<code>String</code>), optionally taking a port (<code>Int</code>) and a method (<code>Method</code>).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Method</span> <span class="ot">=</span> <span class="dt">HTTP</span> <span class="op">|</span> <span class="dt">HTTPS</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">indexMaybe ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HList</span> p <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Sigma</span> p)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>indexMaybe <span class="dv">0</span> []     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>indexMaybe <span class="dv">0</span> (x<span class="op">:</span>_ ) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>indexMaybe n (_<span class="op">:</span>xs) <span class="ot">=</span> indexMaybe (n<span class="op">-</span><span class="dv">1</span>) xs</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Expects a String, an Int, then a Method.</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">mkConnection ::</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>mkConnection args <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    host ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    host <span class="ot">=</span> castSigma <span class="op">=&lt;&lt;</span> indexHList <span class="dv">0</span> args</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    port ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    port <span class="ot">=</span> castSigma <span class="op">=&lt;&lt;</span> indexHList <span class="dv">1</span> args</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    method ::</span> <span class="dt">Maybe</span> <span class="dt">Method</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    method <span class="ot">=</span> castSigma <span class="op">=&lt;&lt;</span> indexHList <span class="dv">2</span> args</span></code></pre></div>
<p>Of course, this would <em>probably</em> be better expressed in Haskell as a function of type <code>Maybe String -&gt; Maybe Int -&gt; Maybe Method -&gt; IO ()</code>. But maybe this could be useful in a situation where you would want to offer the ability to take arguments in any order? We could “find” the first value of a given type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findValueOfType ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>findValueOfType []     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>findValueOfType (x<span class="op">:</span>xs) <span class="ot">=</span> castSigma x <span class="op">&lt;|&gt;</span> findValueOfType xs</span></code></pre></div>
<p>Then we could write:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Expects a String, an Int, then a Method, in any order.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">mkConnection ::</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>mkConnection args <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    host ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    host <span class="ot">=</span> findValueOfType args</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    port ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    port <span class="ot">=</span> findValueOfType args</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    method ::</span> <span class="dt">Maybe</span> <span class="dt">Method</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    method <span class="ot">=</span> findValueOfType args</span></code></pre></div>
<p>But is this a good idea? Probably not.</p>
<p>One very common usage of this type is for “extensible” systems that let you store components of different types in a container, as long as they all support some common interface (ie, the widgets system from the <a href="https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/">Luke Palmer</a> post).</p>
<p>For example, we could have a list of any item as long as the item is an instance of <code>Show</code>: that’s <code>HList Showable</code>!</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showAll ::</span> <span class="dt">HList</span> <span class="dt">Showable</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>showAll <span class="ot">=</span> <span class="fu">map</span> showSigma</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    showSigma (<span class="dt">MkSigma</span> <span class="dt">WitShowable</span> x) <span class="ot">=</span> <span class="fu">show</span> x</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> xs <span class="ot">=</span> [<span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dv">1</span>, <span class="dt">MkSigma</span> <span class="dt">WitShowable</span> <span class="dt">True</span>]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> showAll xs</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;1&quot;</span>, <span class="st">&quot;True&quot;</span>]</span></code></pre></div>
<p>For <code>Show</code>, this is a rather silly thing to do because of the reasons mentioned in the Palmer post — namely, that you could always just have a <code>[String]</code> directly instead of an <code>HList Showable</code>, since the only thing you can do with a <code>Sigma Showable</code> is <code>show</code> it.</p>
<p>For fun, let’s imagine some other things we could fill in for <code>p</code>. If we use <code>HList Proxy</code>, then we basically don’t have any witness at all. We can’t use the values in the list in any meaningful way; <code>HList Proxy</code> is essentially the same as <code>Natural</code>, since the only information is the length.</p>
<p>If we use <code>HList IsBool</code>, we basically have <code>[Bool]</code>, since every item must be a <code>Bool</code>! In general, <code>HList ((:~:) a)</code> is the same as <code>[a]</code>.</p>
<h2 id="level-2-homogeneous-dynamic-list">Level 2: Homogeneous Dynamic List</h2>
<p>A next level of type safety we can add is to ensure that all elements in the list are of the same type. This adds a layer of usefulness because there are a lot of things we might want to do with the elements of a list that are only possible if they are all of the same type — for example, we might want to take a (polymorphic) sum of a list, but we can’t do that with <code>HList</code> because it might mix values of different types.</p>
<p>To do this, we can flip the witness to <em>outside</em> the list:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeList</span><span class="ot"> ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkSomeList</span><span class="ot"> ::</span> p a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">SomeList</span> p</span></code></pre></div>
<p>We can write some meaningful predicates on this list — for example, we can check if it is monotonic (the items increase in order)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | An Ord counterpart for Showable</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Comparable</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">WitOrd</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Comparable</span> a</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">monotonic ::</span> <span class="dt">SomeList</span> <span class="dt">Comparable</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>monotonic (<span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> [])       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>monotonic (<span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> [x])      <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>monotonic (<span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> (x<span class="op">:</span>y<span class="op">:</span>xs)) <span class="ot">=</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    (x <span class="op">&lt;=</span> y) <span class="op">&amp;&amp;</span> monotonic (<span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> (y<span class="op">:</span>xs))</span></code></pre></div>
<p>However, if we take a step back, we can see that this is a little silly because we could just as easily write <code>monotonic</code> as a polymorphic function:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">monotonic&#39; ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>monotonic&#39; []       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>monotonic&#39; [x]      <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>monotonic&#39; (x<span class="op">:</span>y<span class="op">:</span>xs) <span class="ot">=</span> (x <span class="op">&lt;=</span> y) <span class="op">&amp;&amp;</span> monotonic&#39; (y<span class="op">:</span>xs)</span></code></pre></div>
<p>Instead, the we could maybe have a function return <em>any</em> type of <code>Ord</code>-instance list, depending on what it was given.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getItems ::</span> <span class="dt">IO</span> (<span class="dt">SomeList</span> <span class="dt">Comparable</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>getItems <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>This is a “dependently typed” function, in that it could go into a database (or query the user) for a list of items of a type that will not be known until runtime — the only guarantee we have is that it has an <code>Ord</code> instance.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">analyzeGottenItems ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>analyzeGottenItems <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    items<span class="op">@</span>(<span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> xs) <span class="ot">&lt;-</span> getItems</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Got &quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="fu">length</span> xs) <span class="op">++</span> <span class="st">&quot; items.&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> isMono    <span class="ot">=</span> monotonic items</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        isRevMono <span class="ot">=</span> monotnoic (<span class="dt">MkSomeList</span> <span class="dt">WitOrd</span> (<span class="fu">reverse</span> xs))</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    when isMono <span class="op">$</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;The items are monotonic.&quot;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    when (isMono <span class="op">&amp;&amp;</span> isRevMono) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;The items are monotonic both directions.&quot;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;This means the items are all identical.&quot;</span></span></code></pre></div>
<p>This could also be useful if you have a few “valid” options for your list types, and want to branch depending on which one you get. This can be useful for just using <code>Either</code> if you expect your list of valid types to be “open” and constantly expanding, and so your documentation is your main way of indicating to the user what they can give. I’m just kidding, this is not useful, please use a real closed ADT if you ever want to do this.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Behavior depends on what is given.</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- * If it&#39;s a list of Bools, returns if they are all True</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- * If it&#39;s a list of Ints, returns if their sum is greater than 50</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- * If it&#39;s a list of Doubles, returns if their sum is greater than 5.0</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- * If it&#39;s a list of Strings, returns if it contains an &#39;e&#39;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="ot">processList ::</span> <span class="dt">MkSomeList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>processList (<span class="dt">MkSomeList</span> tr xs)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (typeRep <span class="op">@</span><span class="dt">Bool</span>)   <span class="ot">=</span> <span class="fu">and</span> xs</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (<span class="dt">TypeRep</span> <span class="op">@</span><span class="dt">Int</span>)    <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">&gt;</span> <span class="dv">50</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (<span class="dt">TypeRep</span> <span class="op">@</span><span class="dt">Double</span>) <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">&gt;</span> <span class="fl">5.0</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Just</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> testEquality tr (<span class="dt">TypeRep</span> <span class="op">@</span><span class="dt">String</span>) <span class="ot">=</span> <span class="ch">&#39;e&#39;</span> <span class="ot">`elem`</span> xs</span></code></pre></div>
<p>This pattern is overall similar to how lists are often used in dynamic languages: just <em>some</em> list of the same type of each element is expected, but what is <em>in</em> those lists is dynamically determined. Ultimately I think Level 1 more closely matches lists in dynamic languages than Level 2, if only because the idea of a list of all elements of the same type is such a half-hearted sort of type safety that neither dynamic languages nor statically typed languages would ever embrace it — it’s a “worst of both worlds” in many ways.</p>
<p>For all of these levels, we’ll take a moment to describe how to “ascend to” the new level, and how to “descend from” the new level.</p>
<p>Moving from Level 1 to Level 2 is actually impossible in the general case; we can only do for <code>HList TypeRep</code> and <code>SomeList TypeRep</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hlistToSomeList ::</span> <span class="dt">HList</span> <span class="dt">TypeRep</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">SomeList</span> <span class="dt">TypeRep</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>hlistToSomeList (<span class="dt">HList</span> [])     <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">MkSomeList</span> (typeRep <span class="op">@</span>()) []  <span class="co">-- this could be anything</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>hlistToSomeList (<span class="dt">HList</span> (x<span class="op">:</span>xs)) <span class="ot">=</span> </span></code></pre></div>
<h2 id="level-3-homogeneous-typed-list">Level 3: Homogeneous Typed List</h2>
<p>At the halfway point, we’ve reached Haskell’s ubiquitous list type! It is essentially:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> a</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</span></code></pre></div>
<p>I don’t have too much to say here, other than to acknowledge that this is truly a “sweet spot” in terms of safety vs. unsafety and usability. This simple <code>List a</code> / <code>[a]</code> type has so many benefits from type-safety:</p>
<ul>
<li>It lets us write functions that can meaningfully say that the input and result types are the same, like <code>take :: Int -&gt; [a] -&gt; [a]</code></li>
<li>It lets us write functions that can meaningfully link lists and the items in the list, like <code>head :: [a] -&gt; a</code> and <code>replicate :: Int -&gt; a -&gt; [a]</code>.</li>
<li>It lets us write functions that can meaningfully state relationships between input and results, like <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></li>
<li>We can require two input lists to have the same type of items, like <code>(++)     :: [a] -&gt; [a] -&gt; [a]</code></li>
<li>We can express complex relationships between inputs and outputs, like <code>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code>.</li>
</ul>
<p>The property of being able to state and express relationships between the values of input lists and output lists and the items in those lists is extremely powerful, and also extremely ergonomic to use in Haskell. It can be argued that Haskell, as a language, was tuned explicitly to be used with the least friction at this exact level of type safety.</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!
</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/seven-levels-of-type-safety-haskell-lists.html';
    this.page.identifier = 'type-levels';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>